<Type Name="KnowledgeModel" FullName="SemWeb.KnowledgeModel">
  <TypeSignature Language="C#" Value="public class KnowledgeModel : SemWeb.Store" />
  <AssemblyInfo>
    <AssemblyName>SemWeb</AssemblyName>
    <AssemblyVersion>1.0.1915.28028</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>SemWeb.Store</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Reflection.DefaultMember(MemberName="Item")</AttributeName>
    </Attribute>
  </Attributes>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public KnowledgeModel ();" />
      <MemberType>Constructor</MemberType>
      <Parameters />
      <Docs>
        <summary>Constructs a new empty KnowledgeModel.</summary>
        <remarks>None.</remarks>
      </Docs>
    </Member>
    
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public KnowledgeModel (SemWeb.RdfParser parser);" />
      <MemberType>Constructor</MemberType>
      <Parameters>
        <Parameter Name="parser" Type="SemWeb.RdfParser" />
      </Parameters>
      <Docs>
        <param name="parser">A parser containing statements to load into the memory store.</param>
        <summary>Creates a new KnowledgeModel, adds to it a <see cref="T:SemWeb.Stores.MemoryStore" />, and loads in the statements from the given parser.</summary>
        <remarks>This is a convenience function.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public void Add (SemWeb.Store storage);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="storage" Type="SemWeb.Store" />
      </Parameters>
      <Docs>
        <param name="storage">The store to add into the model.</param>
        <summary>Adds a store into the KnowledgeModel.</summary>
        <remarks>
          <para>The statements in <paramref name="store" /> become available through calls to this KnowledgeModel's select and contains methods.</para>

<para>The store should have been created passing this KnowledgeModel to its constructor so that the store is associated with this KnowledgeModel.</para></remarks>
      </Docs>
    </Member>
    <Member MemberName="AddReasoning">
      <MemberSignature Language="C#" Value="public void AddReasoning (SemWeb.ReasoningEngine engine);" />
      <MemberType>Method</MemberType>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="engine" Type="SemWeb.ReasoningEngine" />
      </Parameters>
      <Docs>
        <param name="engine">An inference engine.</param>
        <summary>Adds an inference engine to the KnowledgeModel.</summary>
        <remarks>
          <para>Calls to Select and Contains on this KnowledgeModel will reflect the capabilities of the added inference engine.</para>
<para>Inference engines are executed in the order in which they were added.  The inferences made by a later engine are not available as input to an earlier engine.</para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Storage">
      <MemberSignature Language="C#" Value="public SemWeb.Stores.MultiStore Storage { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>SemWeb.Stores.MultiStore</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>The MultiStore that maintains the list of stores within this KnowledgeModel.</summary>
        <value>The list of stores within this KnowledgeModel.</value>
        <remarks>
          <para>It is safe to manipulate the object returned by this property to change the stores associated with the KnowledgeModel.</para>
<para>Calls to Contains and Select on the MultiStore reflect the contents of the stores contained in it without the application of the KnowledgeModel's inference engines.</para></remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public SemWeb.Entity Item[string uri] { get; };" />
      <MemberType>Property</MemberType>
      <ReturnValue>
        <ReturnType>SemWeb.Entity</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="uri" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="uri">A URI.</param>
        <summary>Gets the <see cref="T:SemWeb.Entity" /> with the given URI.</summary>
        <value>The entity from the first store that contains an entity with the given URI.</value>
        <remarks>None.</remarks>
      </Docs>
    </Member>
  </Members>
  <Docs>
    <summary>A store for combining multiple stores and inference engines.</summary>
    <remarks>
      <para>Resources and stores can be associated with KnowledgeModels through their constructors.  Associating a KnowledgeModel is optional, but doing so enables the default accessor of Resources, which allows for easy traversal of the RDF graph.</para>

<para>Associating resources and stores with KnowledgeModels can only be done through their constructors.  But, doing so to stores does not add the store into the KnowledgeModel to make the statements available for calls to <see cref="M:SemWeb.Store.Select(SemWeb.Statement,SemWeb.StatementSink)" />.  <see cref="M:SemWeb.KnowledgeModel.Add(SemWeb.Store)" /> must be called separately.  Likewise, calling <see cref="M:SemWeb.KnowledgeModel.Add(SemWeb.Store)" /> does not change which KnowledgeModel a store is associate with (if any).</para>

<example>
  <para>The following is a basic example of an RDF application using a KnowledgeModel.  It reads an RDF/XML file on standard input and writes an N3 version of the statements to standard output.</para>
  <code lang="C#" src="../examples/simple.cs">// Compile with: mcs -r:../bin/SemWeb.dll simple.cs
// Execute with: MONO_PATH=../bin mono simple.exe &lt; testfile.rdf

using System;
using SemWeb;
using SemWeb.IO;
using SemWeb.Stores;

public class Simple {
	public static void Main() {
		KnowledgeModel model = new KnowledgeModel();
		
		MemoryStore store = new MemoryStore(model);
		model.Add(store);
		
		store.Import(new RdfXmlParser(Console.In));
		store.Write(new N3Writer(Console.Out));
	}
}
</code>
</example></remarks>
  </Docs>
</Type>
