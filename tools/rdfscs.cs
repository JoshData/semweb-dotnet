using System;
using System.Collections;
using System.IO;
using System.Reflection;

using SemWeb;

[assembly: AssemblyTitle("RDFS2CS - Create C# Classes for RDF Schemas")]
[assembly: AssemblyCopyright("Copyright (c) 2005 Joshua Tauberer <tauberer@for.net>\nreleased under the GPL.")]
[assembly: AssemblyDescription("A tool for creating C# classes based on RDFS class schema.")]

[assembly: Mono.UsageComplement("name schemafile")]

public class RDFSCS {
	private class Opts : Mono.GetOptions.Options {
	}
	
	static Entity rdfType = new Entity("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
	static Entity rdfsResource = new Entity("http://www.w3.org/2000/01/rdf-schema#Resource");
	static Entity rdfsSubClass = new Entity("http://www.w3.org/2000/01/rdf-schema#subClassOf");
	static Entity rdfsSubProperty = new Entity("http://www.w3.org/2000/01/rdf-schema#subPropertyOf");
	static Entity rdfsDomain = new Entity("http://www.w3.org/2000/01/rdf-schema#domain");
	static Entity rdfsRange = new Entity("http://www.w3.org/2000/01/rdf-schema#range");
	static Entity rdfsClass = new Entity("http://www.w3.org/2000/01/rdf-schema#Class");
	static Entity rdfsLiteral = new Entity("http://www.w3.org/2000/01/rdf-schema#Literal");
	static Entity owlOntology = new Entity("http://www.w3.org/2002/07/owl#Ontology");
	static Entity owlFunctionalProperty = new Entity("http://www.w3.org/2002/07/owl#FunctionalProperty");
	static Entity owlInverseFunctionalProperty = new Entity("http://www.w3.org/2002/07/owl#InverseFunctionalProperty");

	static string ns, name;
	
	public static void Main(string[] args) {
		Opts opts = new Opts();
		opts.ProcessArgs(args);

		if (opts.RemainingArguments.Length != 2) {
			opts.DoHelp();
			return;
		}
		
		name = opts.RemainingArguments[0];
		string schemafile = opts.RemainingArguments[1];
		
		ns = "SemWeb.Schemas." + name;
		
		RdfReader reader;
		if (schemafile.EndsWith(".n3") || schemafile.EndsWith(".nt"))
			reader = new N3Reader(schemafile);
		else
			reader = new RdfXmlReader(schemafile);
		
		Store schema = new MemoryStore(reader);
		
		foreach (Entity type in schema.GetEntitiesOfType(rdfsClass)) {
			DoType(type, schema);
		}
		
	}
	
	private static string GetTypeName(string uri) {
		int hash = uri.LastIndexOf('#');
		if (hash > 0) {
			return uri.Substring(hash+1);
		}
		
		hash = uri.LastIndexOf('/');
		if (hash > 0) {
			return uri.Substring(hash+1);
		}
		
		return null;
	}
	
	private static void DoType(Entity type, Store model) {
		string classname = GetTypeName(type.Uri);
		if (classname == null) return;
		
		Console.WriteLine(ns + "." + classname + " ==> " + type.Uri);
		
		using (TextWriter output = new StreamWriter("rdfs2cs/" + ns + "." + classname + ".cs")) {

		output.WriteLine("// This file was generated by rdfs2cs.");
		output.WriteLine("// The class below represents the type " + type + ".");
		output.WriteLine();
		output.WriteLine("using System;");
		output.WriteLine("using System.Collections;");
		output.WriteLine("using SemWeb;");
		output.WriteLine();
		output.WriteLine("namespace " + ns + " {");
		
		output.WriteLine("\tpublic class Any {");
		output.WriteLine("\t\tEntity entity;");
		output.WriteLine("\t\tStore model;");
		output.WriteLine();
		output.WriteLine("\t\tpublic Any(Entity entity, Store model) { this.entity = entity; this.model = model; }");
		output.WriteLine();
		output.WriteLine("\t\tpublic Entity Entity { get { return entity; } }");
		output.WriteLine("\t\tpublic Store Model { get { return model; } }");
		output.WriteLine();
		output.WriteLine("\t\tpublic static implicit operator Entity(" + classname + " entity) { return Entity; }");
		output.WriteLine("\t}");
		
		output.WriteLine("\tpublic class " + classname + " : Any {");
		output.WriteLine();
		output.WriteLine("\t\tpublic const string ClassUri = \"" + type.Uri + "\";");
		output.WriteLine();
		output.WriteLine("\t\tpublic " + classname + "(Entity entity, Store model) : base(entity, model) { }");
		output.WriteLine();

		foreach (Entity p in model.SelectSubjects(rdfsDomain, type))
			DoProperty(p, true, model, output);
		
		foreach (Entity p in model.SelectSubjects(rdfsRange, type))
			DoProperty(p, false, model, output);

		output.WriteLine("\t}");
		output.WriteLine("}");
		
		}
	}
	
	private static void DoProperty(Entity property, bool direction, Store model, TextWriter output) {
		if (property.Uri == null) return;

		string name = GetTypeName(property.Uri);
		if (name == null) return;
		
		if (!direction) {
			if (name.EndsWith("Of") || name.EndsWith("By"))
				name = name.Substring(0, name.Length-2);
			else
				name += "Of";
		}
		
		Resource[] range;
		if (direction) range = model.SelectObjects(property, rdfsRange);
		else range = model.SelectObjects(property, rdfsDomain);
		Entity propertyType = null;
		string returnType = "Any";
		if (range.Length == 1 && range[0] is Entity) {
			propertyType = (Entity)range[0];
			if (propertyType == rdfsLiteral)
				returnType = "string";
			else {
				returnType = GetTypeName(propertyType.Uri);
				if (returnType == null) {
					returnType = "Any";
					propertyType = null;
				}
			}
		}
		
		
		bool functional = model.Contains(new Statement(property, rdfType,
			direction ? owlFunctionalProperty : owlInverseFunctionalProperty));
		
		output.WriteLine("\tprivate static readonly Entity " + name + "Property = new Entity(\"" + property.Uri + "\");");
		
		// Property signature
		
		output.WriteLine("\t\t\tpublic " + returnType + (!functional ? "[]" : "") + " @" + name + " {");
		output.WriteLine("\t\t\tget {");
		
		// Get the possible resources
		
		if (direction)
			output.WriteLine("\t\t\t\tResource[] resources = model.SelectObjects(Entity, " + name + "Property);");
		else
			output.WriteLine("\t\t\t\tResource[] resources = model.SelectSubjects(" + name + "Property, Entity);");
		
		// Transform the type of the resources
		
		if (returnType == "string") {
			output.WriteLine("\t\t\t\tstring[] objects = new string[resources.Length];");
			output.WriteLine("\t\t\t\tfor (int i = 0; i < resources.Length; i++)");
			output.WriteLine("\t\t\t\t\tobjects[i] = resources[i] is Literal ? ((Literal)resources[i]).Value ? \"\";");
		} else {
			output.WriteLine("\t\t\t\tAny[] objects = new Any[resources.Length];");
			output.WriteLine("\t\t\t\tfor (int i = 0; i < resources.Length; i++)");
			output.WriteLine("\t\t\t\t\tobjects[i] = new " + returnType + "(resources[i] is Entity ? (Entity)resources[i] : new Entity(null), Model);");
		}
		
		// Return
		
		if (!functional)
			output.WriteLine("\t\t\t\treturn objects;");
		else
			output.WriteLine("\t\t\t\treturn objects.Length == 0 ? null : objects[0];");		

		output.WriteLine("\t\t\t}");
		output.WriteLine("\t\t\t}");

		output.WriteLine();
	}
	
}

