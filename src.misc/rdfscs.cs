using System;
using System.Collections;
using System.IO;
using System.Reflection;

using SemWeb;
using SemWeb.IO;
using SemWeb.Stores;

[assembly: AssemblyTitle("RDFS2CS - Create C# Classes for RDF Classes")]
[assembly: AssemblyCopyright("Copyright (c) 2005 Joshua Tauberer <tauberer@for.net>\nreleased under the GPL.")]
[assembly: AssemblyDescription("A tool for creating C# classes based on RDFS class schema.")]

[assembly: Mono.UsageComplement("file1 file2...")]

public class RDFSCS {
	private class Opts : Mono.GetOptions.Options {
		[Mono.GetOptions.Option("The {format} for the input schema files: xml or n3.")]
		public string @in = "xml";

		[Mono.GetOptions.Option(-1, "A {C#-namespace:RDF-namespace} mapping.")]
		public string[] ns;
	}
	
	static Entity rdfType = new Entity("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
	static Entity rdfsResource = new Entity("http://www.w3.org/2000/01/rdf-schema#Resource");
	static Entity rdfsSubClass = new Entity("http://www.w3.org/2000/01/rdf-schema#subClassOf");
	static Entity rdfsSubProperty = new Entity("http://www.w3.org/2000/01/rdf-schema#subPropertyOf");
	static Entity rdfsDomain = new Entity("http://www.w3.org/2000/01/rdf-schema#domain");
	static Entity rdfsRange = new Entity("http://www.w3.org/2000/01/rdf-schema#range");
	static Entity rdfsClass = new Entity("http://www.w3.org/2000/01/rdf-schema#Class");
	static Entity rdfsLiteral = new Entity("http://www.w3.org/2000/01/rdf-schema#Literal");
	static Entity owlFunctionalProperty = new Entity("http://www.w3.org/2002/07/owl#FunctionalProperty");
	static Entity owlInverseFunctionalProperty = new Entity("http://www.w3.org/2002/07/owl#InverseFunctionalProperty");

	static Hashtable classNamespaces = new Hashtable();	

	static Hashtable noDomainProperties = new Hashtable();
	static Hashtable noRangeProperties = new Hashtable();
	
	public static void Main(string[] args) {
		Opts opts = new Opts();
		opts.ProcessArgs(args);

		if (opts.RemainingArguments.Length == 0) {
			opts.DoHelp();
			return;
		}
		
		foreach (string s in opts.ns) {
			int c = s.IndexOf(':');
			if (c == -1) { opts.DoHelp(); return; }
			classNamespaces[s.Substring(c+1)] = s.Substring(0,c);
		}
		
		KnowledgeModel model = new KnowledgeModel();
		model.AddReasoning(new RDFSReasoning());

		MemoryStore storage = new MemoryStore(model);
		model.Storage.Add(storage);
		
		foreach (string infile in opts.RemainingArguments) {
			try {
				RdfParser parser;
				if (opts.@in == "xml")
					parser = new RdfXmlParser(infile);
				else if (opts.@in == "n3")
					parser = new N3Parser(infile);
				else
					throw new ArgumentException("The in argument must be one of xml or n3.");
				storage.Import(parser);
			} catch (Exception e) {
				Console.Error.WriteLine("Error: " + infile + ": " + e);
			}
		}
		
		foreach (Statement t in model.Select(new Statement(null, rdfsDomain, rdfsResource)))
			noDomainProperties[t.Subject] = t.Subject;
		foreach (Statement t in model.Select(new Statement(null, rdfsRange, rdfsResource)))
			noRangeProperties[t.Subject] = t.Subject;

		foreach (Entity type in model.GetEntitiesOfType(rdfsClass)) {
			DoType(type, model);
		}
		
	}
	
	private static string GetTypeName(string uri, out string ns) {
		int hash = uri.LastIndexOf('#');
		if (hash > 0) {
			ns = (string)classNamespaces[uri.Substring(0, hash+1)];
			return uri.Substring(hash+1);
		}
		
		hash = uri.LastIndexOf('/');
		if (hash > 0) {
			ns = (string)classNamespaces[uri.Substring(0, hash+1)];
			return uri.Substring(hash+1);
		}
		
		ns = null;
		return null;
	}
	
	private static void DoType(Entity type, KnowledgeModel model) {
		string typens;
		
		string classname = GetTypeName(type.Uri, out typens);
		if (classname == null || typens == null) return;
		
		Console.WriteLine(typens + "." + classname + " ==> " + type.Uri);
		
		using (TextWriter output = new StreamWriter("rdfs2cs/" + typens + "." + classname + ".cs")) {

		output.WriteLine("// This file was generated by rdfs2cs.");
		output.WriteLine("// The class below represents the type " + type + ".");
		output.WriteLine();
		output.WriteLine("using System;");
		output.WriteLine("using System.Collections;");
		output.WriteLine("using SemWeb;");
		output.WriteLine();
		output.WriteLine("namespace " + typens + " {");
		output.WriteLine("public class " + classname + " {");
		output.WriteLine();
		output.WriteLine("\tpublic const string Uri = \"" + type.Uri + "\";");
		output.WriteLine();
		output.WriteLine("\tprivate Entity entity;");
		output.WriteLine();
		output.WriteLine("\tpublic " + classname + "(Entity entity) { this.entity = entity; }");
		output.WriteLine();
		
		output.WriteLine("\tpublic static implicit operator " + classname + "(Entity entity) { return new " + classname + "(entity); }");
		output.WriteLine();
		
		output.WriteLine("\tpublic static implicit operator Entity(" + classname + " entity) { return entity; }");
		output.WriteLine();

		foreach (Entity p in model.SelectSubjects(rdfsDomain, type))
			if (!noDomainProperties.ContainsKey(p))
				DoProperty(p, true, model, output, typens);
		
		foreach (Entity p in model.SelectSubjects(rdfsRange, type))
			if (!noRangeProperties.ContainsKey(p))
				DoProperty(p, false, model, output, typens);

		output.WriteLine("}");
		output.WriteLine("}");
		
		}
	}
	
	private static void DoProperty(Entity property, bool direction, KnowledgeModel model, TextWriter output, string typens) {
		if (property.Uri == null) return;

		string propns;
		string name = GetTypeName(property.Uri, out propns);
		if (name == null || propns == null) return;
		
		if (propns != typens)
			name = propns + "_" + name;
		
		if (!direction) {
			if (name.EndsWith("Of") || name.EndsWith("By"))
				name = name.Substring(0, name.Length-2);
			else
				name += "Of";
		}
		
		// Don't use the KnowledgeModel for this because we want only
		// the domain and range as it was defined by the user.
		Resource[] range;
		if (direction) range = model.Storage.SelectObjects(property, rdfsRange);
		else range = model.Storage.SelectObjects(property, rdfsDomain);
		Entity propertyType = null;
		string returnType = "Resource";
		if (range.Length == 1 && range[0] is Entity) {
			propertyType = (Entity)range[0];
			if (propertyType == rdfsLiteral)
				returnType = "string";
			else {
				string ns;
				returnType = GetTypeName(propertyType.Uri, out ns);
				if (returnType == null || ns == null) {
					returnType = "Resource";
					propertyType = null;
				} else {
					returnType = ns + "." + returnType;
				}
			}
			if (returnType == null) {
				returnType = "Resource";
				propertyType = null;
			}
		}
		
		
		bool functional = false;
		if (direction && model.Contains(new Statement(property, rdfType, owlFunctionalProperty))) functional = true;
		if (!direction && model.Contains(new Statement(property, rdfType, owlInverseFunctionalProperty))) functional = true;
		
		output.WriteLine("\tprivate static readonly Entity " + name + "Property = new Entity(\"" + property.Uri + "\");");
		
		output.WriteLine("\tpublic " + returnType + (!functional ? "[]" : "") + " @" + name + " {");
		output.WriteLine("\t\tget {");

		if (!functional) {		
			output.WriteLine("\t\t\tResource[] rets = entity[" + name + "Property, " + (direction ? "true" : "false") + "];");
			if (propertyType != null) {
				output.WriteLine("\t\t\tArrayList list = new ArrayList();");
				output.WriteLine("\t\t\tforeach (Resource ret in rets) {");
				output.WriteLine("\t\t\tobject r = ret;");
			}
			else
				output.WriteLine("\t\t\treturn rets;");
		} else {
			output.WriteLine("\t\t\tResource[] resources = entity[" + name + "Property, " + (direction ? "true" : "false") + "];");
			output.WriteLine("\t\t\tobject r = null;");
			output.WriteLine("\t\t\tif (resources.Length == 0) return null; else r = resources[0];");
		}
		
		if (propertyType == rdfsLiteral) {
			output.WriteLine("\t\t\tif (r is Literal) r = ((Literal)r).Value;");
		} else if (propertyType != null) {
			output.WriteLine("\t\t\tr = new " + returnType + "((Entity)r);");
		}
		
		if (!functional) {		
			if (propertyType != null) {
				output.WriteLine("\t\t\tlist.Add(r);");
				output.WriteLine("\t\t\t}");
				output.WriteLine("\t\t\treturn (" + returnType + "[])list.ToArray(typeof(" + returnType + "));");
			}
		} else {
			output.WriteLine("\t\t\treturn (" + returnType + ")r;");
		}

		output.WriteLine("\t\t}");
		output.WriteLine("\t}");

		output.WriteLine();
	}
	
}

