using System;
using System.Collections;
using System.IO;
using System.Reflection;

using SemWeb;

[assembly: AssemblyTitle("RDFS2CS - Create C# Classes for RDF Classes")]
[assembly: AssemblyCopyright("Copyright (c) 2005 Joshua Tauberer <tauberer@for.net>\nreleased under the GPL.")]
[assembly: AssemblyDescription("A tool for creating C# classes based on RDFS class schema.")]

[assembly: Mono.UsageComplement("file1 file2...")]

public class RDFSCS {
	private class Opts : Mono.GetOptions.Options {
		[Mono.GetOptions.Option("The {format} for the input schema files: xml or n3.")]
		public string @in = "xml";

		[Mono.GetOptions.Option("The C# {namespace} to use for generated classes.")]
		public string @ns = "SemWeb.RDF";
	}
	
	static Entity rdfType = new Entity("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
	static Entity rdfsResource = new Entity("http://www.w3.org/2000/01/rdf-schema#Resource");
	static Entity rdfsSubClass = new Entity("http://www.w3.org/2000/01/rdf-schema#subClassOf");
	static Entity rdfsSubProperty = new Entity("http://www.w3.org/2000/01/rdf-schema#subPropertyOf");
	static Entity rdfsDomain = new Entity("http://www.w3.org/2000/01/rdf-schema#domain");
	static Entity rdfsRange = new Entity("http://www.w3.org/2000/01/rdf-schema#range");
	static Entity rdfsClass = new Entity("http://www.w3.org/2000/01/rdf-schema#Class");
	static Entity rdfsLiteral = new Entity("http://www.w3.org/2000/01/rdf-schema#Literal");
	static Entity owlFunctionalProperty = new Entity("http://www.w3.org/2002/07/owl#FunctionalProperty");
	static Entity owlInverseFunctionalProperty = new Entity("http://www.w3.org/2002/07/owl#InverseFunctionalProperty");	

	static Hashtable noDomainProperties = new Hashtable();
	static Hashtable noRangeProperties = new Hashtable();
	
	public static void Main(string[] args) {
		Opts opts = new Opts();
		opts.ProcessArgs(args);

		if (opts.RemainingArguments.Length == 0) {
			opts.DoHelp();
			return;
		}
		
		KnowledgeModel model = new KnowledgeModel();
		model.AddReasoning(new RDFSReasoning());

		MemoryStore storage = new MemoryStore(model);
		model.Storage.Add(storage);
		
		foreach (string infile in opts.RemainingArguments) {
			try {
				RdfParser parser;
				if (opts.@in == "xml")
					parser = new RdfXmlParser(infile);
				else if (opts.@in == "n3")
					parser = new N3Parser(infile);
				else
					throw new ArgumentException("The in argument must be one of xml or n3.");
				storage.Import(parser);
			} catch (Exception e) {
				Console.Error.WriteLine("Error: " + infile + ": " + e);
			}
		}
		
		foreach (Statement t in model.Select(new Statement(null, rdfsDomain, rdfsResource)))
			noDomainProperties[t.Subject] = t.Subject;
		foreach (Statement t in model.Select(new Statement(null, rdfsRange, rdfsResource)))
			noRangeProperties[t.Subject] = t.Subject;

		foreach (Entity type in model.GetEntitiesOfType(rdfsClass)) {
			DoType(type, model);
		}
		
	}
	
	private static string GetTypeName(string uri) {
		uri = uri.Replace(".", "_");
		
		int hash = uri.LastIndexOf('#');
		if (hash > 0)
			return uri.Substring(hash+1);
		
		hash = uri.LastIndexOf('/');
		if (hash > 0)
			return uri.Substring(hash+1);
		
		return null;
	}
	
	private static void DoType(Entity type, KnowledgeModel model) {
		
		string classname = GetTypeName(type.Uri);
		if (classname == null) return;
		
		using (TextWriter output = new StreamWriter("rdfs2cs/" + classname + ".cs")) {

		output.WriteLine("// This file was generated by rdfs2cs.");
		output.WriteLine("// The class below represents the type " + type + ".");
		output.WriteLine();
		output.WriteLine("using System;");
		output.WriteLine("using SemWeb;");
		output.WriteLine();
		output.WriteLine("public class " + classname + " {");
		output.WriteLine();
		output.WriteLine("\tpublic const string Uri = \"" + type.Uri + "\";");
		output.WriteLine();
		output.WriteLine("\tprivate Entity entity;");
		output.WriteLine();
		output.WriteLine("\tpublic " + classname + "(Entity entity) { this.entity = entity; }");
		output.WriteLine();
		
		output.WriteLine("\tpublic static implicit operator " + classname + "(Entity entity) { return new " + classname + "(entity); }");
		output.WriteLine();
		
		output.WriteLine("\tpublic static implicit operator Entity(" + classname + " entity) { return entity; }");
		output.WriteLine();

		foreach (Entity p in model.SelectSubjects(rdfsDomain, type))
			if (!noDomainProperties.ContainsKey(p))
				DoProperty(p, true, model, output);
		
		foreach (Entity p in model.SelectSubjects(rdfsRange, type))
			if (!noRangeProperties.ContainsKey(p))
				DoProperty(p, false, model, output);

		output.WriteLine("}");
		
		}
	}
	
	private static void DoProperty(Entity property, bool direction, KnowledgeModel model, TextWriter output) {
		if (property.Uri == null) return;

		string name = GetTypeName(property.Uri);
		if (name == null) return;
		
		if (!direction) {
			if (name.EndsWith("Of") || name.EndsWith("By"))
				name = name.Substring(0, name.Length-2);
			else
				name += "Of";
		}
		
		// Don't use the KnowledgeModel for this because we want only
		// the domain and range as it was defined by the user.
		Resource[] range;
		if (direction) range = model.Storage.SelectObjects(property, rdfsRange);
		else range = model.Storage.SelectObjects(property, rdfsDomain);
		Entity propertyType = null;
		string returnType = "Resource";
		if (range.Length == 1 && range[0] is Entity) {
			propertyType = (Entity)range[0];
			if (propertyType == rdfsLiteral)
				returnType = "string";
			else
				returnType = GetTypeName(propertyType.Uri);
			if (returnType == null) {
				returnType = "Resource";
				propertyType = null;
			}
		}
		
		
		bool functional = false;
		if (direction && model.Contains(new Statement(property, rdfType, owlFunctionalProperty))) functional = true;
		if (!direction && model.Contains(new Statement(property, rdfType, owlInverseFunctionalProperty))) functional = true;
		
		output.WriteLine("\tprivate static readonly Entity " + name + "Property = new Entity(\"" + property.Uri + "\");");
		
		output.WriteLine("\tpublic " + returnType + (!functional ? "[]" : "") + " @" + name + " {");
		output.WriteLine("\t\tget {");

		if (!functional) {		
			output.WriteLine("\t\t\tResource[] rets = entity[" + name + "Property, " + (direction ? "true" : "false") + "];");
			if (propertyType != null) {
				output.WriteLine("\t\t\tArrayList list = new ArrayList();");
				output.WriteLine("\t\t\tforeach (Resource ret in rets) {");
				output.WriteLine("\t\t\tobject r = null;");
			}
			else
				output.WriteLine("\t\t\treturn rets;");
		} else {
			output.WriteLine("\t\t\tResource[] resources = entity[" + name + "Property, " + (direction ? "true" : "false") + "];");
			output.WriteLine("\t\t\tResource ret = null;");
			output.WriteLine("\t\t\tobject r = null;");
			output.WriteLine("\t\t\tif (resources.Length == 0) return null; else ret = resources[0];");
		}
		
		if (propertyType == rdfsLiteral) {
			output.WriteLine("\t\t\tif (ret is Literal) r = ((Literal)ret).Value;");
		} else if (propertyType != null) {
			output.WriteLine("\t\t\tr = new " + returnType + "((Entity)ret);");
		}
		
		if (!functional) {		
			if (propertyType != null) {
				output.WriteLine("\t\t\tif (r != null) list.Add(r);");
				output.WriteLine("\t\t\t}");
				output.WriteLine("\t\t\treturn (" + returnType + "[])list.ToArray(typeof(" + returnType + "));");
			}
		} else {
			output.WriteLine("\t\t\treturn (" + returnType + ")o;");
		}

		output.WriteLine("\t\t}");
		output.WriteLine("\t}");

		output.WriteLine();
	}
	
}

