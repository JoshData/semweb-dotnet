diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/build.xml work-copy/build.xml
--- upstream/build.xml	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/build.xml	2007-10-21 11:58:06.000000000 -0400
@@ -33,7 +33,7 @@
 
 	<!-- CONFIGURABLE PROPERTIES -->
 	<property name="javacc_home" value="../JavaCC" />
-	<property name="current_grammar" value="20060616-ext" />
+	<property name="current_grammar" value="20070624" />
 	<property name="library" value="sparql-core.jar" />
 	<property name="test_library" value="sparql-tests.jar" />
 	<property name="version" value="0.9" />
@@ -149,4 +149,4 @@
 	<!-- THIS WILL BUILD THE WHOLE DISTRIBUTION FROM GRAMMAR -->
 	<target name="dist_from_grammar" depends="grammar,dist" />
 
-</project>
\ No newline at end of file
+</project>
Binary files upstream/dist/sparql-core.jar and work-copy/dist/sparql-core.jar differ
Binary files upstream/dist/sparql-tests.jar and work-copy/dist/sparql-tests.jar differ
Binary files upstream/sparql-0.8.zip and work-copy/sparql-0.8.zip differ
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/common/AdvancedRdfSource.java work-copy/src/main/name/levering/ryan/sparql/common/AdvancedRdfSource.java
--- upstream/src/main/name/levering/ryan/sparql/common/AdvancedRdfSource.java	1969-12-31 19:00:00.000000000 -0500
+++ work-copy/src/main/name/levering/ryan/sparql/common/AdvancedRdfSource.java	2007-10-21 12:35:15.000000000 -0400
@@ -0,0 +1,25 @@
+/*
+ * SPARQL Engine
+ * Copyright (C) 2005 Ryan Levering, All rights reserved.
+ * See LICENSE for full license information
+ */
+package name.levering.ryan.sparql.common;
+
+import java.util.Iterator;
+import java.util.List;
+
+import name.levering.ryan.sparql.common.URI;
+import name.levering.ryan.sparql.common.Value;
+
+/**
+ * Description...
+ * 
+ * @author Joshua Tauberer
+ * @version 1.0
+ */
+public interface AdvancedRdfSource extends RdfSource {
+    public Iterator getStatements(Value[] subj, Value[] pred, Value[] obj, URI[] graph, Object[] litFilters, int limit);
+    public Iterator getDefaultStatements(Value[] subj, Value[] pred, Value[] obj, Object[] litFilters, int limit);
+    public Iterator getStatements(Value[] subj, Value[] pred, Value[] obj, Object[] litFilters, int limit);
+}
+
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/common/impl/InternalSPARQLValueFactory.java work-copy/src/main/name/levering/ryan/sparql/common/impl/InternalSPARQLValueFactory.java
--- upstream/src/main/name/levering/ryan/sparql/common/impl/InternalSPARQLValueFactory.java	2007-10-07 07:19:17.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/common/impl/InternalSPARQLValueFactory.java	2007-10-21 12:35:15.000000000 -0400
@@ -52,7 +52,7 @@
 	}
 
 	public URI createURI(String namespace, String localName) {
-		return new URIImpl(namespace, localName);
+		return new URIImpl(namespace + localName);
 	}
 
 	public URI createURI(URI baseURI) {
@@ -279,11 +279,8 @@
 		| Variables                              |
 		+---------------------------------------*/
 
-		/** The namespace. * */
-		private String _namespace;
-
-		/** local name * */
-		private String _localName;
+		/** complete URI * */
+		private String _uri;
 
 		/*---------------------------------------+
 		| Constructors                           |
@@ -297,68 +294,12 @@
 		 *             (absolute) URI.
 		 */
 		public URIImpl(String uri) {
-			// Find the place to split the uri
-			int i = uri.length() - 1;
-			while (i >= 0) {
-				char c = uri.charAt(i);
-				if (c == '#' || c == ':' || c == '/') {
-					break;
-				}
-				i--;
-			}
-
-			if (i > 0) {
-				// Split the uri
-				_namespace = uri.substring(0, i + 1);
-				_localName = uri.substring(i + 1);
-			} else {
-				throw new IllegalArgumentException("'" + uri + "' is not a legal (absolute) URI");
-			}
-		}
-
-		/**
-		 * Creates a new URI that will get the supplied namespace and local
-		 * name.
-		 * 
-		 * @param namespace A namespace.
-		 * @param localName A legal local name. A legal local name adheres to
-		 *            the definition of an NCName as specified at <a
-		 *            href="http://www.w3.org/TR/REC-xml-names/#NT-NCName">http://www.w3.org/TR/REC-xml-names/#NT-NCName</a>.
-		 */
-		public URIImpl(String namespace, String localName) {
-			if (namespace == null) {
-				throw new IllegalArgumentException("namespace must not be null");
-			}
-			if (localName == null) {
-				throw new IllegalArgumentException("localName must not be null");
-			}
-
-			_namespace = namespace;
-			_localName = localName;
-		}
-
-		/*---------------------------------------+
-		| Methods                                |
-		+---------------------------------------*/
-
-		// inherit comments
-		public String getNamespace() {
-			return _namespace;
-		}
-
-		// inherit comments
-		public String getLocalName() {
-			return _localName;
+			this._uri = uri;
 		}
 
 		// inherit comments
 		public String getURI() {
-			// This code is (much) more efficient then just concatenating the
-			// two strings.
-			char[] result = new char[_namespace.length() + _localName.length()];
-			_namespace.getChars(0, _namespace.length(), result, 0);
-			_localName.getChars(0, _localName.length(), result, _namespace.length());
-			return new String(result);
+			return _uri;
 		}
 
 		/**
@@ -376,7 +317,7 @@
 			if (o instanceof URI) {
 				URI other = (URI) o;
 
-				return _localName.equals(other.getLocalName()) && _namespace.equals(other.getNamespace());
+				return _uri.equals(other.getURI());
 			}
 
 			return false;
@@ -384,7 +325,7 @@
 
 		// Implements Object.hashCode()
 		public int hashCode() {
-			return _namespace.hashCode() ^ _localName.hashCode();
+			return _uri.hashCode();
 		}
 
 		/**
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/common/impl/RdfBindingSetImpl.java work-copy/src/main/name/levering/ryan/sparql/common/impl/RdfBindingSetImpl.java
--- upstream/src/main/name/levering/ryan/sparql/common/impl/RdfBindingSetImpl.java	2007-10-07 07:19:17.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/common/impl/RdfBindingSetImpl.java	2007-10-21 12:35:14.000000000 -0400
@@ -98,6 +98,8 @@
 		for (Iterator oldRows = oldSet.iterator(); oldRows.hasNext();) {
 			this.addRow((RdfBindingRow) oldRows.next());
 		}
+		setDistinct(oldSet.isDistinct());
+		setOrdered(oldSet.isOrdered());
 	}
 
 	/**
@@ -141,11 +143,10 @@
 		if (row == null) {
 			throw new NullPointerException("RdfBindingRow 'row' cannot be null");
 		}
-		List newValues = new ArrayList();
-		for (int i = 0; i < this.variables.length; i++) {
-			newValues.add(row.getValue(this.variables[i]));
-		}
-		this.values.add(newValues.toArray(new Value[0]));
+		Value[] newValues = new Value[this.variables.length];
+		for (int i = 0; i < this.variables.length; i++)
+			newValues[i] = row.getValue(this.variables[i]);
+		this.values.add(newValues);
 	}
 
 	/**
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/common/URI.java work-copy/src/main/name/levering/ryan/sparql/common/URI.java
--- upstream/src/main/name/levering/ryan/sparql/common/URI.java	2007-10-07 07:19:17.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/common/URI.java	2007-10-21 12:35:15.000000000 -0400
@@ -3,17 +3,10 @@
 public interface URI extends Resource {
 	
 	/**
-	 * Gets the namespace of this URI.
+	 * Gets the URI of this URI.
 	 *
-	 * @return The URI's namespace.
+	 * @return The URI as a string.
 	 **/
-	public String getNamespace();
-
-	/**
-	 * Gets the local name of this URI.
-	 *
-	 * @return The URI's local name.
-	 **/
-	public String getLocalName();
+	public String getURI();
 
 }
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/extensions/fpredicates/FunctionalPredicateLogic.java work-copy/src/main/name/levering/ryan/sparql/extensions/fpredicates/FunctionalPredicateLogic.java
--- upstream/src/main/name/levering/ryan/sparql/extensions/fpredicates/FunctionalPredicateLogic.java	2006-08-20 20:00:59.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/extensions/fpredicates/FunctionalPredicateLogic.java	2007-10-21 12:35:16.000000000 -0400
@@ -1,6 +1,7 @@
 package name.levering.ryan.sparql.extensions.fpredicates;
 
 import java.util.Collection;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
 import name.levering.ryan.sparql.common.RdfSource;
@@ -41,10 +42,9 @@
 	 * @param namedDatasets the named graphs, ignored
 	 * @return a binding set according to the function
 	 */
-	public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets,
-			Collection namedDatasets) {
+	public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
 		
-		return this.function.getBindingSet(this.data.getSubjectExpression(), this.data.getObjectExpression(), source);
+		return this.function.getBindingSet(this.data.getSubjectExpression(), this.data.getObjectExpression(), p.source);
 	}
 
 }
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/extensions/functions/aggregate/IsMaxFunction.java work-copy/src/main/name/levering/ryan/sparql/extensions/functions/aggregate/IsMaxFunction.java
--- upstream/src/main/name/levering/ryan/sparql/extensions/functions/aggregate/IsMaxFunction.java	2007-10-07 07:19:16.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/extensions/functions/aggregate/IsMaxFunction.java	2007-10-21 12:35:16.000000000 -0400
@@ -128,7 +128,7 @@
 		return new ExternalFunctionFactory() {
 
 			public ExternalFunction create(LogicFactory logicFactory, SPARQLValueFactory valueFactory) {
-				return new IsMaxFunction(logicFactory.getValueOrderingLogic());
+				return new IsMaxFunction(logicFactory.getValueOrderingLogic(valueFactory));
 			}
 
 		};
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/extensions/functions/aggregate/IsMinFunction.java work-copy/src/main/name/levering/ryan/sparql/extensions/functions/aggregate/IsMinFunction.java
--- upstream/src/main/name/levering/ryan/sparql/extensions/functions/aggregate/IsMinFunction.java	2007-10-07 07:19:16.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/extensions/functions/aggregate/IsMinFunction.java	2007-10-21 12:35:16.000000000 -0400
@@ -126,7 +126,7 @@
 		return new ExternalFunctionFactory() {
 
 			public ExternalFunction create(LogicFactory logicFactory, SPARQLValueFactory valueFactory) {
-				return new IsMinFunction(logicFactory.getValueOrderingLogic());
+				return new IsMinFunction(logicFactory.getValueOrderingLogic(valueFactory));
 			}
 
 		};
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/extensions/functions/aggregate/MaxFunction.java work-copy/src/main/name/levering/ryan/sparql/extensions/functions/aggregate/MaxFunction.java
--- upstream/src/main/name/levering/ryan/sparql/extensions/functions/aggregate/MaxFunction.java	2007-10-07 07:19:16.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/extensions/functions/aggregate/MaxFunction.java	2007-10-21 12:35:16.000000000 -0400
@@ -121,7 +121,7 @@
 		return new ExternalFunctionFactory() {
 
 			public ExternalFunction create(LogicFactory logicFactory, SPARQLValueFactory valueFactory) {
-				return new MaxFunction(logicFactory.getValueOrderingLogic());
+				return new MaxFunction(logicFactory.getValueOrderingLogic(valueFactory));
 			}
 
 		};
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/extensions/functions/aggregate/MinFunction.java work-copy/src/main/name/levering/ryan/sparql/extensions/functions/aggregate/MinFunction.java
--- upstream/src/main/name/levering/ryan/sparql/extensions/functions/aggregate/MinFunction.java	2007-10-07 07:19:16.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/extensions/functions/aggregate/MinFunction.java	2007-10-21 12:35:16.000000000 -0400
@@ -121,7 +121,7 @@
 		return new ExternalFunctionFactory() {
 
 			public ExternalFunction create(LogicFactory logicFactory, SPARQLValueFactory valueFactory) {
-				return new MinFunction(logicFactory.getValueOrderingLogic());
+				return new MinFunction(logicFactory.getValueOrderingLogic(valueFactory));
 			}
 
 		};
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/extensions/with/DefaultWithConstraintLogic.java work-copy/src/main/name/levering/ryan/sparql/extensions/with/DefaultWithConstraintLogic.java
--- upstream/src/main/name/levering/ryan/sparql/extensions/with/DefaultWithConstraintLogic.java	2006-08-20 20:00:59.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/extensions/with/DefaultWithConstraintLogic.java	2007-10-21 12:35:16.000000000 -0400
@@ -1,6 +1,7 @@
 package name.levering.ryan.sparql.extensions.with;
 
 import java.util.Collection;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
 import name.levering.ryan.sparql.common.RdfSource;
@@ -43,10 +44,9 @@
 	 * @param namedDatasets the named data sets to query against, ignored
 	 * @return the binding set created by the extension
 	 */
-	public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets,
-			Collection namedDatasets) {
+	public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
 		return this.extension.getBindingSet((ExpressionLogic[]) this.data.getArguments().toArray(
-				new ExpressionLogic[] {}), source);
+				new ExpressionLogic[] {}), p.source);
 	}
 
 }
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/BaseLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/BaseLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/BaseLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/BaseLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -25,7 +25,6 @@
 import name.levering.ryan.sparql.logic.function.LangLogic;
 import name.levering.ryan.sparql.logic.function.LangMatchesLogic;
 import name.levering.ryan.sparql.logic.function.RegexLogic;
-import name.levering.ryan.sparql.logic.function.SameTermLogic;
 import name.levering.ryan.sparql.logic.function.StrLogic;
 import name.levering.ryan.sparql.model.data.BinaryExpressionData;
 import name.levering.ryan.sparql.model.data.CallExpressionData;
@@ -279,17 +278,6 @@
 	}
 
 	/**
-	 * Gets the default 'sameTerm' function logic.
-	 * 
-	 * @param data the function data containing arguments passed to the
-	 *            langMatches function
-	 * @return the logic handling the langMatches function
-	 */
-	public ExpressionLogic getSameTermLogic(CallExpressionData data, SPARQLValueFactory valueFactory) {
-		return new SameTermLogic(data, getValueConversionLogic(valueFactory));
-	}
-
-	/**
 	 * Gets the default 'regex' function logic.
 	 * 
 	 * @param data the function data containing arguments passed to the regex
@@ -357,8 +345,8 @@
 	 * 
 	 * @return the logic that orders Value objects
 	 */
-	public ValueOrderingLogic getValueOrderingLogic() {
-		return new DefaultValueOrderingLogic();
+	public ValueOrderingLogic getValueOrderingLogic(SPARQLValueFactory valueFactory) {
+		return new DefaultValueOrderingLogic(getNumericPromotionLogic(valueFactory), getValueConversionLogic(valueFactory));
 	}
 
 }
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/BNodeRenamingConstructQueryLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/BNodeRenamingConstructQueryLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/BNodeRenamingConstructQueryLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/BNodeRenamingConstructQueryLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -22,6 +22,7 @@
 import name.levering.ryan.sparql.model.GroupConstraint;
 import name.levering.ryan.sparql.model.TripleConstraint;
 import name.levering.ryan.sparql.model.data.ConstructQueryData;
+import name.levering.ryan.sparql.model.logic.ConstraintLogic;
 import name.levering.ryan.sparql.model.logic.ConstructQueryLogic;
 import name.levering.ryan.sparql.model.logic.OrderExpressionLogic;
 import name.levering.ryan.sparql.model.logic.helper.SetRangeLogic;
@@ -85,16 +86,20 @@
 	 * @return an RDF graph containing the formed triples
 	 */
 	public RdfGraph execute(RdfSource source) {
+		ConstraintLogic.CallParams p = new ConstraintLogic.CallParams();
+		p.bindings = new RdfBindingSetImpl();
+		p.source = source;
+		
 		// Grab the necessary fields from the data
 		GroupConstraint constraint = this.data.getConstraint();
-		Collection defaultDatasets = this.data.getDefaultDatasets();
-		Collection namedDatasets = this.data.getNamedDatasets();
+		p.defaultDatasets = this.data.getDefaultDatasets();
+		p.namedDatasets = this.data.getNamedDatasets();
 		List orderExpressions = this.data.getOrderExpressions();
 		int limit = this.data.getLimit();
 		int offset = this.data.getOffset();
 
 		// First bind the result table
-		RdfBindingSet results = constraint.constrain(new RdfBindingSetImpl(), source, defaultDatasets, namedDatasets);
+		RdfBindingSet results = constraint.constrain(p);
 
 		// Now apply ordering in reverse order to give priority to the first
 		// variable
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/debug/DebugLogicWrapper.java work-copy/src/main/name/levering/ryan/sparql/logic/debug/DebugLogicWrapper.java
--- upstream/src/main/name/levering/ryan/sparql/logic/debug/DebugLogicWrapper.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/debug/DebugLogicWrapper.java	2007-10-21 12:35:15.000000000 -0400
@@ -145,10 +145,6 @@
 		return this.baseFactory.getLangMatchesLogic(data, valueFactory);
 	}
 
-	public ExpressionLogic getSameTermLogic(CallExpressionData data, SPARQLValueFactory valueFactory) {
-		return this.baseFactory.getSameTermLogic(data, valueFactory);
-	}
-
 	public ExpressionLogic getLTELogic(BinaryExpressionData data, SPARQLValueFactory valueFactory) {
 		return this.baseFactory.getLTELogic(data, valueFactory);
 	}
@@ -177,8 +173,8 @@
 		return new OptionalConstraintDebug(this.baseFactory.getOptionalConstraintLogic(data, valueFactory), this.out);
 	}
 
-	public OrderExpressionLogic getOrderExpressionLogic(OrderExpressionData data) {
-		return this.baseFactory.getOrderExpressionLogic(data);
+	public OrderExpressionLogic getOrderExpressionLogic(OrderExpressionData data, SPARQLValueFactory valueFactory) {
+		return this.baseFactory.getOrderExpressionLogic(data, valueFactory);
 	}
 
 	public ExpressionLogic getOrLogic(BinaryExpressionData data, SPARQLValueFactory valueFactory) {
@@ -240,8 +236,8 @@
 		return this.baseFactory.getValueConversionLogic(valueFactory);
 	}
 
-	public ValueOrderingLogic getValueOrderingLogic() {
-		return this.baseFactory.getValueOrderingLogic();
+	public ValueOrderingLogic getValueOrderingLogic(SPARQLValueFactory valueFactory) {
+		return this.baseFactory.getValueOrderingLogic(valueFactory);
 	}
 
 	public ConstructQueryLogic getConstructQueryLogic(ExtendedConstructQueryData data, SPARQLValueFactory valueFactory) {
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/debug/FilterConstraintDebug.java work-copy/src/main/name/levering/ryan/sparql/logic/debug/FilterConstraintDebug.java
--- upstream/src/main/name/levering/ryan/sparql/logic/debug/FilterConstraintDebug.java	2006-08-20 20:01:00.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/debug/FilterConstraintDebug.java	2007-10-21 12:35:15.000000000 -0400
@@ -1,6 +1,7 @@
 package name.levering.ryan.sparql.logic.debug;
 
 import java.util.Collection;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
 import name.levering.ryan.sparql.common.RdfSource;
@@ -19,11 +20,10 @@
 		this.out = listener;
 	}
 	
-	public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets,
-			Collection namedDatasets) {
-        this.out.filterConstraintPreExecute(this.data, bindings);
+	public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
+        this.out.filterConstraintPreExecute(this.data, p.bindings);
         long start = System.currentTimeMillis();
-        RdfBindingSet returnSet = this.filterLogic.constrain(bindings, source, defaultDatasets, namedDatasets);
+        RdfBindingSet returnSet = this.filterLogic.constrain(p);
         long end = System.currentTimeMillis();
         this.out.filterConstraintPostExecute(end-start, returnSet);
         return returnSet;
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/debug/GraphConstraintDebug.java work-copy/src/main/name/levering/ryan/sparql/logic/debug/GraphConstraintDebug.java
--- upstream/src/main/name/levering/ryan/sparql/logic/debug/GraphConstraintDebug.java	2006-08-20 20:01:00.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/debug/GraphConstraintDebug.java	2007-10-21 12:35:15.000000000 -0400
@@ -1,6 +1,7 @@
 package name.levering.ryan.sparql.logic.debug;
 
 import java.util.Collection;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
 import name.levering.ryan.sparql.common.RdfSource;
@@ -16,11 +17,10 @@
 		this.out = listener;
 	}
 
-	public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets,
-			Collection namedDatasets) {
+	public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
         this.out.graphConstraintPreExecute();
         long start = System.currentTimeMillis();
-        RdfBindingSet returnSet = this.logic.constrain(bindings, source, defaultDatasets, namedDatasets);
+        RdfBindingSet returnSet = this.logic.constrain(p);
         long end = System.currentTimeMillis();
         this.out.graphConstraintPostExecute(end-start, returnSet);
         return returnSet;
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/debug/GroupConstraintDebug.java work-copy/src/main/name/levering/ryan/sparql/logic/debug/GroupConstraintDebug.java
--- upstream/src/main/name/levering/ryan/sparql/logic/debug/GroupConstraintDebug.java	2006-08-20 20:01:00.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/debug/GroupConstraintDebug.java	2007-10-21 12:35:15.000000000 -0400
@@ -1,6 +1,7 @@
 package name.levering.ryan.sparql.logic.debug;
 
 import java.util.Collection;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
 import name.levering.ryan.sparql.common.RdfSource;
@@ -16,11 +17,10 @@
 		this.out = listener;
 	}
 
-	public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets,
-			Collection namedDatasets) {
+	public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
         this.out.groupConstraintPreExecute();
         long start = System.currentTimeMillis();
-        RdfBindingSet returnSet = this.logic.constrain(bindings, source, defaultDatasets, namedDatasets);
+        RdfBindingSet returnSet = this.logic.constrain(p);
         long end = System.currentTimeMillis();
         this.out.groupConstraintPostExecute(end-start, returnSet);
         return returnSet;
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/debug/OptionalConstraintDebug.java work-copy/src/main/name/levering/ryan/sparql/logic/debug/OptionalConstraintDebug.java
--- upstream/src/main/name/levering/ryan/sparql/logic/debug/OptionalConstraintDebug.java	2006-08-20 20:01:00.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/debug/OptionalConstraintDebug.java	2007-10-21 12:35:15.000000000 -0400
@@ -1,6 +1,7 @@
 package name.levering.ryan.sparql.logic.debug;
 
 import java.util.Collection;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
 import name.levering.ryan.sparql.common.RdfSource;
@@ -16,11 +17,10 @@
 		this.out = listener;
 	}
 
-	public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets,
-			Collection namedDatasets) {
+	public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
         this.out.optionalConstraintPreExecute();
         long start = System.currentTimeMillis();
-        RdfBindingSet returnSet = this.logic.constrain(bindings, source, defaultDatasets, namedDatasets);
+        RdfBindingSet returnSet = this.logic.constrain(p);
         long end = System.currentTimeMillis();
         this.out.optionalConstraintPostExecute(end-start, returnSet);
         return returnSet;
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/debug/TripleConstraintDebug.java work-copy/src/main/name/levering/ryan/sparql/logic/debug/TripleConstraintDebug.java
--- upstream/src/main/name/levering/ryan/sparql/logic/debug/TripleConstraintDebug.java	2006-08-20 20:01:00.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/debug/TripleConstraintDebug.java	2007-10-21 12:35:15.000000000 -0400
@@ -6,6 +6,7 @@
 package name.levering.ryan.sparql.logic.debug;
 
 import java.util.Collection;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
 import name.levering.ryan.sparql.common.RdfSource;
@@ -24,11 +25,10 @@
         this.out = listener;
     }
 
-    public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source,
-            Collection defaultDatasets, Collection namedDatasets) {
+    public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
         this.out.tripleFetchPreExecute(this.data);
         long start = System.currentTimeMillis();
-        RdfBindingSet returnSet = this.logic.constrain(bindings, source, defaultDatasets, namedDatasets);
+        RdfBindingSet returnSet = this.logic.constrain(p);
         long end = System.currentTimeMillis();
         this.out.tripleFetchPostExecute(end-start, returnSet);
         return returnSet;
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/debug/UnionConstraintDebug.java work-copy/src/main/name/levering/ryan/sparql/logic/debug/UnionConstraintDebug.java
--- upstream/src/main/name/levering/ryan/sparql/logic/debug/UnionConstraintDebug.java	2006-08-20 20:01:00.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/debug/UnionConstraintDebug.java	2007-10-21 12:35:15.000000000 -0400
@@ -1,6 +1,7 @@
 package name.levering.ryan.sparql.logic.debug;
 
 import java.util.Collection;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
 import name.levering.ryan.sparql.common.RdfSource;
@@ -16,11 +17,10 @@
 		this.out = listener;
 	}
 
-	public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets,
-			Collection namedDatasets) {
+	public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
         this.out.unionConstrainPreExecute();
         long start = System.currentTimeMillis();
-        RdfBindingSet returnSet = this.unionLogic.constrain(bindings, source, defaultDatasets, namedDatasets);
+        RdfBindingSet returnSet = this.unionLogic.constrain(p);
         long end = System.currentTimeMillis();
         this.out.unionConstraintPostExecute(end-start, returnSet);
         return returnSet;
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/DefaultAskQueryLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/DefaultAskQueryLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/DefaultAskQueryLogic.java	2006-08-20 20:01:01.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/DefaultAskQueryLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -13,6 +13,7 @@
 import name.levering.ryan.sparql.model.GroupConstraint;
 import name.levering.ryan.sparql.model.data.AskQueryData;
 import name.levering.ryan.sparql.model.logic.AskQueryLogic;
+import name.levering.ryan.sparql.model.logic.ConstraintLogic;
 
 /**
  * This is the simplest query logic in SPARQL, as it doesn't have to deal with
@@ -48,14 +49,18 @@
      * @return true if the delegated query data binds any value rows
      */
     public boolean execute(RdfSource source) {
-        // Grab the necessary fields from the data
+		  ConstraintLogic.CallParams p = new ConstraintLogic.CallParams();
+		  p.bindings = new RdfBindingSetImpl();
+		  p.source = source;
+
+		  // Grab the necessary fields from the data
         GroupConstraint constraint = this.data.getConstraint();
-        Collection defaultDatasets = this.data.getDefaultDatasets();
-        Collection namedDatasets = this.data.getNamedDatasets();
+        p.defaultDatasets = this.data.getDefaultDatasets();
+        p.namedDatasets = this.data.getNamedDatasets();
+        p.limit = 1;
 
         // First bind the result table
-        RdfBindingSet results = constraint.constrain(new RdfBindingSetImpl(),
-                source, defaultDatasets, namedDatasets);
+        RdfBindingSet results = constraint.constrain(p);
 
         // Return whether or not the iterator returns any rows
         return results.iterator().hasNext();
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/DefaultConstructQueryLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/DefaultConstructQueryLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/DefaultConstructQueryLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/DefaultConstructQueryLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -6,19 +6,32 @@
 package name.levering.ryan.sparql.logic;
 
 import java.util.Collection;
+import java.util.HashMap;
+import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 
+import name.levering.ryan.sparql.common.RdfBindingRow;
 import name.levering.ryan.sparql.common.RdfBindingSet;
 import name.levering.ryan.sparql.common.RdfGraph;
 import name.levering.ryan.sparql.common.RdfSource;
 import name.levering.ryan.sparql.common.impl.RdfBindingSetImpl;
+import name.levering.ryan.sparql.common.impl.RdfGraphImpl;
+import name.levering.ryan.sparql.common.impl.StatementImpl;
 import name.levering.ryan.sparql.model.GroupConstraint;
+import name.levering.ryan.sparql.model.TripleConstraint;
 import name.levering.ryan.sparql.model.data.ConstructQueryData;
+import name.levering.ryan.sparql.model.logic.ConstraintLogic;
 import name.levering.ryan.sparql.model.logic.ConstructQueryLogic;
 import name.levering.ryan.sparql.model.logic.OrderExpressionLogic;
 import name.levering.ryan.sparql.model.logic.helper.GraphTranslationLogic;
 import name.levering.ryan.sparql.model.logic.helper.SetRangeLogic;
 
+import name.levering.ryan.sparql.common.BNode;
+import name.levering.ryan.sparql.common.URI;
+import name.levering.ryan.sparql.common.Value;
+import name.levering.ryan.sparql.common.BNode;
+
 /**
  * This query logic constructs an RDF graph by applying an RDF template to a set
  * of value bindings. It must first bind the variables values, then apply
@@ -67,17 +80,23 @@
      * @return an RDF graph containing the formed triples
      */
     public RdfGraph execute(RdfSource source) {
+		  ConstraintLogic.CallParams p = new ConstraintLogic.CallParams();
+		  p.bindings = new RdfBindingSetImpl();
+		  p.source = source;
+		
         // Grab the necessary fields from the data
         GroupConstraint constraint = this.data.getConstraint();
-        Collection defaultDatasets = this.data.getDefaultDatasets();
-        Collection namedDatasets = this.data.getNamedDatasets();
+        p.defaultDatasets = this.data.getDefaultDatasets();
+        p.namedDatasets = this.data.getNamedDatasets();
         List orderExpressions = this.data.getOrderExpressions();
         int limit = this.data.getLimit();
         int offset = this.data.getOffset();
+		  
+		  if (limit >= 0 && orderExpressions.size() == 0)
+			  p.limit = limit;
 
         // First bind the result table
-        RdfBindingSet results = constraint.constrain(new RdfBindingSetImpl(),
-                source, defaultDatasets, namedDatasets);
+        RdfBindingSet results = constraint.constrain(p);
 
         // Now apply ordering in reverse order to give priority to the first
         // variable
@@ -93,7 +112,7 @@
         if (offset >= 0) {
             results = this.rangeLogic.offset(results, offset);
         }
-
+		
         return this.translationLogic.translate(this.data.getTriples(), results);
     }
 
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/DefaultDescribeQueryLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/DefaultDescribeQueryLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/DefaultDescribeQueryLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/DefaultDescribeQueryLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -25,6 +25,7 @@
 import name.levering.ryan.sparql.common.impl.RdfGraphImpl;
 import name.levering.ryan.sparql.model.GroupConstraint;
 import name.levering.ryan.sparql.model.data.DescribeQueryData;
+import name.levering.ryan.sparql.model.logic.ConstraintLogic;
 import name.levering.ryan.sparql.model.logic.DescribeQueryLogic;
 import name.levering.ryan.sparql.model.logic.OrderExpressionLogic;
 import name.levering.ryan.sparql.model.logic.helper.SetProjectionLogic;
@@ -82,17 +83,26 @@
 	 * @return an RDF graph containing the formed triples
 	 */
 	public RdfGraph execute(RdfSource source) {
+		ConstraintLogic.CallParams p = new ConstraintLogic.CallParams();
+		p.bindings = new RdfBindingSetImpl();
+		p.source = source;
+		
 		// Grab the necessary fields from the data
 		GroupConstraint constraint = this.data.getConstraint();
-		Collection defaultDatasets = this.data.getDefaultDatasets();
-		Collection namedDatasets = this.data.getNamedDatasets();
+		p.defaultDatasets = this.data.getDefaultDatasets();
+		p.namedDatasets = this.data.getNamedDatasets();
 		List orderExpressions = this.data.getOrderExpressions();
 		List queryResources = this.data.getQueryResources();
 		int limit = this.data.getLimit();
 		int offset = this.data.getOffset();
 
+	  if (limit >= 0 && orderExpressions.size() == 0)
+		  p.limit = limit;
+		  
 		// First bind the result table
-		RdfBindingSet results = constraint.constrain(new RdfBindingSetImpl(), source, defaultDatasets, namedDatasets);
+		RdfBindingSet results = new RdfBindingSetImpl();
+		if (constraint != null)
+			results = constraint.constrain(p);
 
 		// Now project to the solution set
 		List variables = new ArrayList();
@@ -105,7 +115,7 @@
 		results = this.logic.project(results, variables);
 
 		// Now apply ordering in reverse order
-		for (int i = orderExpressions.size(); i >= 0; i--) {
+		for (int i = orderExpressions.size()-1; i >= 0; i--) {
 			OrderExpressionLogic orderer = (OrderExpressionLogic) orderExpressions.get(i);
 			orderer.order(results);
 		}
@@ -147,7 +157,7 @@
 		RdfGraphImpl graph = new RdfGraphImpl();
 		for (int i = 0; i < resources.length; i++) {
 			for (Iterator varResources = resources[i].iterator(); varResources.hasNext();) {
-				graph.addTriples(describe((Resource) varResources.next(), source, new HashSet()));
+				graph.addTriples(describe((Resource) varResources.next(), source, new HashSet(), 0));
 			}
 		}
 
@@ -163,26 +173,38 @@
 	 * @return all of the statements that give a one-level description of a
 	 *         resource
 	 */
-	private Collection describe(Value value, RdfSource source, Set alreadyDescribed) {
+	private Collection describe(Value value, RdfSource source, Set alreadyDescribed, int direction) {
 		// First add the current node to the described list
 		alreadyDescribed.add(value);
 
 		// Now accumulate statements
 		Collection descriptions = new ArrayList();
-		Iterator statements = source.getDefaultStatements(value, null, null);
-		while (statements.hasNext()) {
-			LenientStatement statement = (LenientStatement) statements.next();
-
-			// If the statement points to a blank node, recurse and describe
-			// that
-			if (statement.getObject() instanceof BNode) {
-				// Check if we covered the blank node already to prevent loops
-				if (!alreadyDescribed.contains(statement.getObject())) {
-					descriptions.addAll(describe(statement.getObject(), source, alreadyDescribed));
+
+		// do forward, then back links
+		for (int i = 0; i <= 1; i++) {
+			if (direction != -1 && direction != i) continue;
+			
+			Iterator statements;
+			if (i == 0)
+				statements = source.getDefaultStatements(value, null, null);
+			else
+				statements = source.getDefaultStatements(null, null, value);
+				
+			while (statements.hasNext()) {
+				LenientStatement statement = (LenientStatement) statements.next();
+
+				// If the statement points to a blank node, recurse and describe
+				// that. But only do forward-links on bnodes.
+				if (statement.getObject() instanceof BNode) {
+					// Check if we covered the blank node already to prevent loops
+					if (!alreadyDescribed.contains(statement.getObject())) {
+						descriptions.addAll(describe(statement.getObject(), source, alreadyDescribed, 0));
+					}
 				}
+				descriptions.add(statement);
 			}
-			descriptions.add(statements.next());
 		}
+		
 		return descriptions;
 	}
 
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/DefaultGraphTranslationLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/DefaultGraphTranslationLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/DefaultGraphTranslationLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/DefaultGraphTranslationLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -5,18 +5,20 @@
 import java.util.Iterator;
 import java.util.Map;
 
-import name.levering.ryan.sparql.common.BNode;
 import name.levering.ryan.sparql.common.RdfBindingRow;
 import name.levering.ryan.sparql.common.RdfBindingSet;
 import name.levering.ryan.sparql.common.RdfGraph;
-import name.levering.ryan.sparql.common.SPARQLValueFactory;
-import name.levering.ryan.sparql.common.URI;
-import name.levering.ryan.sparql.common.Value;
 import name.levering.ryan.sparql.common.impl.RdfGraphImpl;
+import name.levering.ryan.sparql.common.SPARQLValueFactory;
 import name.levering.ryan.sparql.common.impl.StatementImpl;
+import name.levering.ryan.sparql.model.TripleConstraint;
 import name.levering.ryan.sparql.model.data.UnboundStatement;
 import name.levering.ryan.sparql.model.logic.helper.GraphTranslationLogic;
 
+import name.levering.ryan.sparql.common.BNode;
+import name.levering.ryan.sparql.common.URI;
+import name.levering.ryan.sparql.common.Value;
+
 public class DefaultGraphTranslationLogic implements GraphTranslationLogic {
 
 	private final SPARQLValueFactory valueFactory;
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/DefaultGraphTranslationLogic.java.rej work-copy/src/main/name/levering/ryan/sparql/logic/DefaultGraphTranslationLogic.java.rej
--- upstream/src/main/name/levering/ryan/sparql/logic/DefaultGraphTranslationLogic.java.rej	1969-12-31 19:00:00.000000000 -0500
+++ work-copy/src/main/name/levering/ryan/sparql/logic/DefaultGraphTranslationLogic.java.rej	2007-10-07 07:45:08.000000000 -0400
@@ -0,0 +1,40 @@
+***************
+*** 5,23 ****
+  import java.util.Iterator;
+  import java.util.Map;
+  
+  import name.levering.ryan.sparql.common.RdfBindingRow;
+  import name.levering.ryan.sparql.common.RdfBindingSet;
+  import name.levering.ryan.sparql.common.RdfGraph;
+  import name.levering.ryan.sparql.common.impl.RdfGraphImpl;
+- import name.levering.ryan.sparql.common.impl.SPARQLValueFactory;
+  import name.levering.ryan.sparql.common.impl.StatementImpl;
+  import name.levering.ryan.sparql.model.data.UnboundStatement;
+  import name.levering.ryan.sparql.model.logic.helper.GraphTranslationLogic;
+  
+- import org.openrdf.model.BNode;
+- import org.openrdf.model.URI;
+- import org.openrdf.model.Value;
+- 
+  public class DefaultGraphTranslationLogic implements GraphTranslationLogic {
+  
+  	private final SPARQLValueFactory valueFactory;
+--- 5,22 ----
+  import java.util.Iterator;
+  import java.util.Map;
+  
++ import name.levering.ryan.sparql.common.BNode;
+  import name.levering.ryan.sparql.common.RdfBindingRow;
+  import name.levering.ryan.sparql.common.RdfBindingSet;
+  import name.levering.ryan.sparql.common.RdfGraph;
++ import name.levering.ryan.sparql.common.SPARQLValueFactory;
++ import name.levering.ryan.sparql.common.URI;
++ import name.levering.ryan.sparql.common.Value;
+  import name.levering.ryan.sparql.common.impl.RdfGraphImpl;
+  import name.levering.ryan.sparql.common.impl.StatementImpl;
+  import name.levering.ryan.sparql.model.data.UnboundStatement;
+  import name.levering.ryan.sparql.model.logic.helper.GraphTranslationLogic;
+  
+  public class DefaultGraphTranslationLogic implements GraphTranslationLogic {
+  
+  	private final SPARQLValueFactory valueFactory;
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/DefaultIntersectOrderLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/DefaultIntersectOrderLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/DefaultIntersectOrderLogic.java	2006-08-20 20:01:01.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/DefaultIntersectOrderLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -119,6 +119,7 @@
 						for (int i = 0; i < otherSets.size(); i++) {
 							if (otherSets.get(i) == set || otherSets.get(i) == oldAgg) {
 								otherSets.remove(i);
+								i--;
 							}
 						}
 						// And check to make sure this wasn't a final set, so we
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/DefaultSelectQueryLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/DefaultSelectQueryLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/DefaultSelectQueryLogic.java	2006-08-20 20:01:01.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/DefaultSelectQueryLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -12,6 +12,7 @@
 import name.levering.ryan.sparql.common.RdfSource;
 import name.levering.ryan.sparql.model.GroupConstraint;
 import name.levering.ryan.sparql.model.data.SelectQueryData;
+import name.levering.ryan.sparql.model.logic.ConstraintLogic;
 import name.levering.ryan.sparql.model.logic.OrderExpressionLogic;
 import name.levering.ryan.sparql.model.logic.SelectQueryLogic;
 import name.levering.ryan.sparql.model.logic.helper.SetDistinctionLogic;
@@ -74,19 +75,24 @@
      * @return an RDF graph containing the formed triples
      */
     public RdfBindingSet execute(RdfSource source) {
+		  ConstraintLogic.CallParams p = new ConstraintLogic.CallParams();
+		  p.source = source;
+		
         // Grab the necessary fields from the data
         GroupConstraint constraint = this.data.getConstraint();
-        Collection defaultDatasets = this.data.getDefaultDatasets();
-        Collection namedDatasets = this.data.getNamedDatasets();
+        p.defaultDatasets = this.data.getDefaultDatasets();
+        p.namedDatasets = this.data.getNamedDatasets();
         List orderExpressions = this.data.getOrderExpressions();
         List queryExpressions = this.data.getQueryVariables();
         int limit = this.data.getLimit();
         int offset = this.data.getOffset();
         boolean distinct = this.data.getDistinct();
+		  
+		  if (limit >= 0 && orderExpressions.size() == 0)
+			  p.limit = limit;
 
         // First bind the result table
-        RdfBindingSet results = constraint.constrain(null,
-                source, defaultDatasets, namedDatasets);
+        RdfBindingSet results = constraint.constrain(p);
 
         // Now project to the solution set or the variable set
         if (!queryExpressions.isEmpty()) {
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/DefaultValueOrderingLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/DefaultValueOrderingLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/DefaultValueOrderingLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/DefaultValueOrderingLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -1,5 +1,9 @@
 package name.levering.ryan.sparql.logic;
 
+import name.levering.ryan.sparql.common.impl.DateTime;
+
+import name.levering.ryan.sparql.model.logic.NumericPromotionLogic;
+import name.levering.ryan.sparql.model.logic.helper.ValueConversionLogic;
 import name.levering.ryan.sparql.model.logic.helper.ValueOrderingLogic;
 
 import name.levering.ryan.sparql.common.BNode;
@@ -22,6 +26,13 @@
  * @version 1.0
  */
 public class DefaultValueOrderingLogic implements ValueOrderingLogic {
+	NumericPromotionLogic promoter;
+	ValueConversionLogic converter;
+	
+	public DefaultValueOrderingLogic(NumericPromotionLogic promoter, ValueConversionLogic converter) {
+		this.promoter = promoter;
+		this.converter = converter;
+	}
 
 	/**
 	 * Compares two value objects according to section 10.1.
@@ -64,14 +75,41 @@
 			return -1;
 		}
 
-		// First value is an untyped literal
-		if (value1 instanceof Literal && ((Literal) value1).getDatatype() == null) {
-			if (value2 == null || value2 instanceof BNode || value2 instanceof URI) {
+		// First value is a literal
+		if (value1 instanceof Literal) {
+			if (value2 == null || value2 instanceof BNode || value2 instanceof URI)
 				return 1;
+
+			if (value2 instanceof Literal) {
+				if (((Literal) value1).getDatatype() == null && ((Literal) value2).getDatatype() == null)
+					return ((Literal) value1).getLabel().compareTo(((Literal) value2).getLabel());
+					
+				if (((Literal) value1).getDatatype() == null)
+					return -1;
+				if (((Literal) value2).getDatatype() == null)
+					return 1;
+				
+				Literal[] promoted = promoter.promote(new Literal[] { (Literal) value1, (Literal) value2 } );
+				
+				Object v1 = converter.convertLiteral(promoted[0]);
+				Object v2 = converter.convertLiteral(promoted[1]);
+				
+				if (v1 instanceof Double)
+					return ((Double)v1).compareTo((Double)v2);
+				if (v1 instanceof Float)
+					return ((Float)v1).compareTo((Float)v2);
+				if (v1 instanceof Long)
+					return ((Long)v1).compareTo((Long)v2);
+				if (v1 instanceof Integer)
+					return ((Integer)v1).compareTo((Integer)v2);
+				if (v1 instanceof Boolean)
+					return ((Boolean)v1).compareTo((Boolean)v2);
+				if (v1 instanceof DateTime)
+					return ((DateTime)v1).compareTo((DateTime)v2);
+				if (v1 instanceof String)
+					return ((String)v1).compareTo((String)v2);
 			}
-			if (value2 instanceof Literal && ((Literal) value2).getDatatype() == null) {
-				return ((Literal) value1).getLabel().compareTo(((Literal) value2).getLabel());
-			}
+			
 			return -1;
 		}
 
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/expression/GreaterThanEqualsLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/expression/GreaterThanEqualsLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/expression/GreaterThanEqualsLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/expression/GreaterThanEqualsLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -96,11 +96,10 @@
      * 
      * @param string1 the first String to compare
      * @param string2 the second String to compare
-     * @return never
-     * @throws UnsupportedOperationException always
+     * @return true if the first string is greater than or equal to the second
      */
     public boolean evaluateString(String string1, String string2) {
-        throw new UnsupportedOperationException("Strings cannot be compared using a >= operation");
+        return string1.compareTo(string2) >= 0;
     }
 
     /**
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/expression/GreaterThanLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/expression/GreaterThanLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/expression/GreaterThanLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/expression/GreaterThanLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -96,11 +96,10 @@
      * 
      * @param string1 the first String to compare
      * @param string2 the second String to compare
-     * @return never
-     * @throws UnsupportedOperationException always
+     * @return true if the first string is greater than the second
      */
     public boolean evaluateString(String string1, String string2) {
-        throw new UnsupportedOperationException("Strings cannot be compared using a > operation");
+        return string1.compareTo(string2) > 0;
     }
 
     /**
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/expression/LessThanEqualsLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/expression/LessThanEqualsLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/expression/LessThanEqualsLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/expression/LessThanEqualsLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -96,11 +96,10 @@
      * 
      * @param string1 the first String to compare
      * @param string2 the second String to compare
-     * @return never
-     * @throws UnsupportedOperationException always
+     * @return true if the first string is less than or equal to the second
      */
     public boolean evaluateString(String string1, String string2) {
-        throw new UnsupportedOperationException("Strings cannot be compared using a <= operation");
+        return string1.compareTo(string2) <= 0;
     }
 
     /**
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/expression/LessThanLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/expression/LessThanLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/expression/LessThanLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/expression/LessThanLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -96,11 +96,10 @@
      * 
      * @param string1 the first String to compare
      * @param string2 the second String to compare
-     * @return never
-     * @throws UnsupportedOperationException always
+     * @return true if the first string is less than the second
      */
     public boolean evaluateString(String string1, String string2) {
-        throw new UnsupportedOperationException("Fix this");
+        return string1.compareTo(string2) < 0;
     }
     
     /**
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/ExtendedConstructQueryLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/ExtendedConstructQueryLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/ExtendedConstructQueryLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/ExtendedConstructQueryLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -87,17 +87,24 @@
 	 * @return an RDF graph containing the formed triples
 	 */
 	public RdfGraph execute(RdfSource source) {
+		ConstraintLogic.CallParams p = new ConstraintLogic.CallParams();
+		p.bindings = new RdfBindingSetImpl();
+		p.source = source;
+
 		// Grab the necessary fields from the data
 		GroupConstraint constraint = this.data.getConstraint();
-		Collection defaultDatasets = this.data.getDefaultDatasets();
-		Collection namedDatasets = this.data.getNamedDatasets();
+		p.defaultDatasets = this.data.getDefaultDatasets();
+		p.namedDatasets = this.data.getNamedDatasets();
 		List orderExpressions = this.data.getOrderExpressions();
 		int limit = this.data.getLimit();
 		int offset = this.data.getOffset();
 		boolean distinct = this.data.isDistinct();
 
+		if (limit >= 0 && orderExpressions.size() == 0)
+			p.limit = limit;
+		  
 		// First bind the result table
-		RdfBindingSet results = constraint.constrain(new RdfBindingSetImpl(), source, defaultDatasets, namedDatasets);
+		RdfBindingSet results = constraint.constrain(p);
 
 		// Now apply ordering in reverse order to give priority to the first
 		// variable
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/function/BoundLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/function/BoundLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/function/BoundLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/function/BoundLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -9,6 +9,7 @@
 import name.levering.ryan.sparql.common.Variable;
 import name.levering.ryan.sparql.model.data.CallExpressionData;
 import name.levering.ryan.sparql.model.logic.ExpressionLogic;
+import name.levering.ryan.sparql.model.logic.LogicFactory;
 import name.levering.ryan.sparql.model.logic.helper.ValueConversionLogic;
 
 import name.levering.ryan.sparql.common.Value;
@@ -21,12 +22,7 @@
  * @author Ryan Levering
  * @version 1.0
  */
-public class BoundLogic implements ExpressionLogic {
-
-    /**
-     * The data holding the arguments of the bound function.
-     */
-    private final CallExpressionData data;
+public class BoundLogic extends FunctionLogic {
 
     /**
      * The logic to return the correct boolean value.
@@ -41,7 +37,7 @@
      */
     public BoundLogic(CallExpressionData data, ValueConversionLogic converter) {
         //TODO Check for whether the argument is a variable
-        this.data = data;
+        super(data);
         this.converter = converter;
     }
 
@@ -56,5 +52,5 @@
         boolean result = (bindings.getValue(variable) != null);
         return this.converter.convertBoolean(result);
     }
-
+ 
 }
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/function/DataTypeLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/function/DataTypeLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/function/DataTypeLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/function/DataTypeLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -21,22 +21,17 @@
  * @author Ryan Levering
  * @version 1.0
  */
-public class DataTypeLogic implements ExpressionLogic {
+public class DataTypeLogic extends FunctionLogic {
 
-	/**
-	 * The data holding the argument to evaluate.
-	 */
-	private final CallExpressionData data;
-
-	/**
-	 * Creates a new logic object that returns the IRI of the datatype of a
-	 * particular typed literal.
-	 * 
-	 * @param data the argument data
-	 */
-	public DataTypeLogic(CallExpressionData data) {
-		this.data = data;
-	}
+    /**
+     * Creates a new logic object that returns the IRI of the datatype of a
+     * particular typed literal.
+     * 
+     * @param data the argument data
+     */
+    public DataTypeLogic(CallExpressionData data) {
+        super(data);
+    }
 
 	/**
 	 * Evaluates the datatype of a typed literal that is an argument.
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/function/DecimalCastFunction.java work-copy/src/main/name/levering/ryan/sparql/logic/function/DecimalCastFunction.java
--- upstream/src/main/name/levering/ryan/sparql/logic/function/DecimalCastFunction.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/function/DecimalCastFunction.java	2007-10-21 12:35:15.000000000 -0400
@@ -144,11 +144,11 @@
      */
     public Value castLiteral(Literal literal) throws IllegalCastException {
         try {
-            Long.parseLong(literal.getLabel());
+            Double.parseDouble(literal.getLabel());
             return this.factory.createLiteral(literal.getLabel(),
                     SPARQLConstants.DECIMAL_TYPE);
         } catch (NumberFormatException e) {
-            throw new IllegalCastException("Unable to cast string to integer");
+            throw new IllegalCastException("Unable to cast string to double");
         }
     }
     
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/function/ExternalFunctionLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/function/ExternalFunctionLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/function/ExternalFunctionLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/function/ExternalFunctionLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -23,34 +23,29 @@
  * @author Ryan Levering
  * @version 1.1
  */
-public class ExternalFunctionLogic implements ExpressionLogic {
+public class ExternalFunctionLogic extends FunctionLogic {
 
-	/**
-	 * The data containing the argument expressions to evaluate
-	 */
-	private final CallExpressionData data;
-
-	/**
-	 * The function to delegate the logic to.
-	 */
-	private final ExternalFunction function;
-
-	/**
-	 * The factory that's used to convert returns into SPARQL values.
-	 */
-	private final SPARQLValueFactory factory;
-
-	/**
-	 * Creates a new external function logic that evaluates a function call to
-	 * produce a Value.
-	 * 
-	 * @param data the data containing the function arguments and it's name
-	 */
-	public ExternalFunctionLogic(CallExpressionData data, ExternalFunction function, SPARQLValueFactory factory) {
-		this.data = data;
-		this.function = function;
-		this.factory = factory;
-	}
+    /**
+     * The function to delegate the logic to.
+     */
+    private final ExternalFunction function;
+
+    /**
+     * The factory that's used to convert returns into SPARQL values.
+     */
+    private SPARQLValueFactory factory;
+    
+    /**
+     * Creates a new external function logic that evaluates a function call to
+     * produce a Value.
+     * 
+     * @param data the data containing the function arguments and it's name
+     */
+    public ExternalFunctionLogic(CallExpressionData data, ExternalFunction function, SPARQLValueFactory factory) {
+        super(data);
+        this.function = function;
+        this.factory = factory;
+    }
 
 	/**
 	 * Evaluates the function by evaluating the arguments and passing them to
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/function/FunctionLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/function/FunctionLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/function/FunctionLogic.java	1969-12-31 19:00:00.000000000 -0500
+++ work-copy/src/main/name/levering/ryan/sparql/logic/function/FunctionLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -0,0 +1,41 @@
+/*
+ * SPARQL Engine
+ * Copyright (C) 2005 Ryan Levering, All rights reserved.
+ * See LICENSE for full license information
+ */
+package name.levering.ryan.sparql.logic.function;
+
+import java.util.Iterator;
+import java.util.Set;
+
+import name.levering.ryan.sparql.common.RdfBindingRow;
+import name.levering.ryan.sparql.common.Variable;
+import name.levering.ryan.sparql.model.data.CallExpressionData;
+import name.levering.ryan.sparql.model.logic.ExpressionLogic;
+import name.levering.ryan.sparql.model.logic.helper.ValueConversionLogic;
+
+import name.levering.ryan.sparql.common.Value;
+
+/**
+ * The base class of function-type logics.
+ * 
+ * @author Ryan Levering
+ * @version 1.0
+ */
+public abstract class FunctionLogic implements ExpressionLogic {
+
+    /**
+     * The data holding the arguments of the bound function.
+     */
+    protected CallExpressionData data;
+
+    /**
+     * Creates a new logic object that handles sop:bound function calls.
+     * 
+     * @param data the data holding the expression arguments to evaluate
+     * @param converter
+     */
+    public FunctionLogic(CallExpressionData data) {
+        this.data = data;
+    }
+}
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/function/IsBlankLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/function/IsBlankLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/function/IsBlankLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/function/IsBlankLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -21,30 +21,23 @@
  * @author Ryan Levering
  * @version 1.0
  */
-public class IsBlankLogic implements ExpressionLogic {
-
-	/**
-	 * The data that holds the argument to evaluate for blank node.
-	 */
-	private final CallExpressionData data;
-
+public class IsBlankLogic extends FunctionLogic {
 	/**
 	 * The converter used to return the true or false value.
 	 */
 	private final ValueConversionLogic converter;
 
-	/**
-	 * Creates a new logic object that can evaluate whether a bound variable or
-	 * value is a blank node.
-	 * 
-	 * @param data the data holding the argument for evaluation
-	 * @param converter the value conversion logic to convert the boolean to a
-	 *            literal
-	 */
-	public IsBlankLogic(CallExpressionData data, ValueConversionLogic converter) {
-		this.data = data;
-		this.converter = converter;
-	}
+    /**
+     * Creates a new logic object that can evaluate whether a bound variable or
+     * value is a blank node.
+     * 
+     * @param data the data holding the argument for evaluation
+     * @param converter the value conversion logic to convert the boolean to a literal
+     */
+    public IsBlankLogic(CallExpressionData data, ValueConversionLogic converter) {
+        super(data);
+        this.converter = converter;
+    }
 
 	/**
 	 * Evaluates whether the value returned by an expression is a blank node.
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/function/IsIRILogic.java work-copy/src/main/name/levering/ryan/sparql/logic/function/IsIRILogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/function/IsIRILogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/function/IsIRILogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -21,38 +21,30 @@
  * @author Ryan Levering
  * @version 1.0
  */
-public class IsIRILogic implements ExpressionLogic {
-
-	/**
-	 * The data that holds the argument to evaluate for IRI.
-	 */
-	private final CallExpressionData data;
-
-	/**
-	 * The converter used to return the true or false value.
-	 */
-	private final ValueConversionLogic converter;
-
-	/**
-	 * Creates a new logic object that can evaluate whether a bound variable or
-	 * value is an IRI.
-	 * 
-	 * @param data the data holding the argument for evaluation
-	 * @param converter the value conversion logic to convert the boolean to a
-	 *            literal
-	 */
-	public IsIRILogic(CallExpressionData data, ValueConversionLogic converter) {
-		this.data = data;
-		this.converter = converter;
-	}
-
-	/**
-	 * Evaluates whether the value returned by an expression is an IRI.
-	 * 
-	 * @param bindings the value bindings to use in argument evaluation
-	 * @return true or false literals representing whether the argument is an
-	 *         IRI
-	 */
+public class IsIRILogic extends FunctionLogic {
+    /**
+     * The converter used to return the true or false value.
+     */
+    private final ValueConversionLogic converter;
+    
+    /**
+     * Creates a new logic object that can evaluate whether a bound variable or
+     * value is an IRI.
+     * 
+     * @param data the data holding the argument for evaluation
+     * @param converter the value conversion logic to convert the boolean to a literal
+     */
+    public IsIRILogic(CallExpressionData data, ValueConversionLogic converter) {
+        super(data);
+        this.converter = converter;
+    }
+    
+    /**
+     * Evaluates whether the value returned by an expression is an IRI.
+     * 
+     * @param bindings the value bindings to use in argument evaluation
+     * @return true or false literals representing whether the argument is an IRI
+     */
 	public Value evaluate(RdfBindingRow bindings) {
 		ExpressionLogic expression = (ExpressionLogic) this.data.getArguments().get(0);
 		Object value = expression.evaluate(bindings);
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/function/IsLiteralLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/function/IsLiteralLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/function/IsLiteralLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/function/IsLiteralLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -21,38 +21,31 @@
  * @author Ryan Levering
  * @version 1.0
  */
-public class IsLiteralLogic implements ExpressionLogic {
-
-	/**
-	 * The data that holds the argument to evaluate for literal.
-	 */
-	private final CallExpressionData data;
-
-	/**
-	 * The converter used to return the true or false value.
-	 */
-	private final ValueConversionLogic converter;
-
-	/**
-	 * Creates a new logic object that can evaluate whether a bound variable or
-	 * value is a literal.
-	 * 
-	 * @param data the data holding the argument for evaluation
-	 * @param converter the value conversion logic to convert the boolean to a
-	 *            literal
-	 */
-	public IsLiteralLogic(CallExpressionData data, ValueConversionLogic converter) {
-		this.data = data;
-		this.converter = converter;
-	}
-
-	/**
-	 * Evaluates whether the value returned by an expression is a literal.
-	 * 
-	 * @param bindings the value bindings to use in argument evaluation
-	 * @return true or false literals representing whether the argument is an
-	 *         literal
-	 */
+public class IsLiteralLogic extends FunctionLogic {
+   
+    /**
+     * The converter used to return the true or false value.
+     */
+    private final ValueConversionLogic converter;
+    
+    /**
+     * Creates a new logic object that can evaluate whether a bound variable or
+     * value is a literal.
+     * 
+     * @param data the data holding the argument for evaluation
+     * @param converter the value conversion logic to convert the boolean to a literal
+     */
+    public IsLiteralLogic(CallExpressionData data, ValueConversionLogic converter) {
+        super(data);
+        this.converter = converter;
+    }
+    
+    /**
+     * Evaluates whether the value returned by an expression is a literal.
+     * 
+     * @param bindings the value bindings to use in argument evaluation
+     * @return true or false literals representing whether the argument is an literal
+     */
 	public Value evaluate(RdfBindingRow bindings) {
 		ExpressionLogic expression = (ExpressionLogic) this.data.getArguments().get(0);
 		Object value = expression.evaluate(bindings);
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/function/LangLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/function/LangLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/function/LangLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/function/LangLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -20,30 +20,22 @@
  * @author Ryan Levering
  * @version 1.0
  */
-public class LangLogic implements ExpressionLogic {
-
-	/**
-	 * The data that holds the argument to evaluate for literal language.
-	 */
-	private final CallExpressionData data;
-
+public class LangLogic extends FunctionLogic {
 	/**
 	 * The converter used to return the string value.
 	 */
 	private final ValueConversionLogic converter;
 
-	/**
-	 * Creates a new logic object that can return the language of a given
-	 * literal.
-	 * 
-	 * @param data the data holding the argument for evaluation
-	 * @param converter the value conversion logic to convert the string to a
-	 *            literal
-	 */
-	public LangLogic(CallExpressionData data, ValueConversionLogic converter) {
-		this.data = data;
-		this.converter = converter;
-	}
+   /**
+    * Creates a new logic object that can return the language of a given literal.
+    * 
+    * @param data the data holding the argument for evaluation
+    * @param converter the value conversion logic to convert the string to a literal
+    */
+    public LangLogic(CallExpressionData data, ValueConversionLogic converter) {
+        super(data);
+        this.converter = converter;
+    }
 
 	/**
 	 * Returns the language of a language tagged literal.
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/function/LangMatchesLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/function/LangMatchesLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/function/LangMatchesLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/function/LangMatchesLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -20,14 +20,7 @@
  * @author Ryan Levering
  * @version 1.0
  */
-public class LangMatchesLogic implements ExpressionLogic {
-
-	/**
-	 * The data that holds the arguments to evaluate for language range and
-	 * literal to match.
-	 */
-	private final CallExpressionData data;
-
+public class LangMatchesLogic extends FunctionLogic {
 	/**
 	 * The converter used to return the boolean value.
 	 */
@@ -42,7 +35,7 @@
 	 *            literal
 	 */
 	public LangMatchesLogic(CallExpressionData data, ValueConversionLogic converter) {
-		this.data = data;
+		super(data);
 		this.converter = converter;
 	}
 
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/function/RegexLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/function/RegexLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/function/RegexLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/function/RegexLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -25,31 +25,25 @@
  * @author Ryan Levering
  * @version 1.1
  */
-public class RegexLogic implements ExpressionLogic {
-
-	/**
-	 * The data that holds the argument to evaluate for string matching.
-	 */
-	private final CallExpressionData data;
-
-	/**
-	 * The converter used to return the boolean literal and convert the string
-	 * value.
-	 */
-	private final ValueConversionLogic converter;
-
-	/**
-	 * Creates a new logic object that can evaluate whether one string occurs in
-	 * another.
-	 * 
-	 * @param data the data holding the argument for evaluation
-	 * @param converter the value conversion logic to convert the result to a
-	 *            literal and the strings to Java strings
-	 */
-	public RegexLogic(CallExpressionData data, ValueConversionLogic converter) {
-		this.data = data;
-		this.converter = converter;
-	}
+public class RegexLogic extends FunctionLogic {
+    /**
+     * The converter used to return the boolean literal and convert the string
+     * value.
+     */
+    private final ValueConversionLogic converter;
+
+    /**
+     * Creates a new logic object that can evaluate whether one string occurs in
+     * another.
+     * 
+     * @param data the data holding the argument for evaluation
+     * @param converter the value conversion logic to convert the result to a
+     *            literal and the strings to Java strings
+     */
+    public RegexLogic(CallExpressionData data, ValueConversionLogic converter) {
+        super(data);
+        this.converter = converter;
+    }
 
 	/**
 	 * Converts the evaluated arguments to strings and uses Java string matching
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/function/SameTermLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/function/SameTermLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/function/SameTermLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/function/SameTermLogic.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,65 +0,0 @@
-/*
- * SPARQL Engine
- * Copyright (C) 2005 Ryan Levering, All rights reserved.
- * See LICENSE for full license information
- */
-package name.levering.ryan.sparql.logic.function;
-
-import name.levering.ryan.sparql.common.RdfBindingRow;
-import name.levering.ryan.sparql.model.data.CallExpressionData;
-import name.levering.ryan.sparql.model.logic.ExpressionLogic;
-import name.levering.ryan.sparql.model.logic.helper.ValueConversionLogic;
-
-import name.levering.ryan.sparql.common.Value;
-
-/**
- * The logic to evaluate the sop:langMatches SPARQL function, found in section
- * 11.4.11 of the specification. It returns whether or not a literal has a
- * language tag in the language range specified by the second argument.
- * 
- * @author Ryan Levering
- * @version 1.0
- */
-public class SameTermLogic implements ExpressionLogic {
-
-	/**
-	 * The data that holds the arguments to evaluate for language range and
-	 * literal to match.
-	 */
-	private final CallExpressionData data;
-
-	/**
-	 * The converter used to return the boolean value.
-	 */
-	private final ValueConversionLogic converter;
-
-	/**
-	 * Creates a new logic object that can check a literal for being in a
-	 * certain language range.
-	 * 
-	 * @param data the data holding the argument for evaluation
-	 * @param converter the value conversion logic to convert the boolean to a
-	 *            literal
-	 */
-	public SameTermLogic(CallExpressionData data, ValueConversionLogic converter) {
-		this.data = data;
-		this.converter = converter;
-	}
-
-	/**
-	 * Returns whether or not a literal falls within a language range.
-	 * 
-	 * @param bindings the value bindings to use in argument evaluation
-	 * @return boolean literal representing the language match outcome
-	 */
-	public Value evaluate(RdfBindingRow bindings) {
-		ExpressionLogic expression = (ExpressionLogic) this.data.getArguments().get(0);
-		Value value = expression.evaluate(bindings);
-
-		expression = (ExpressionLogic) this.data.getArguments().get(1);
-		Value value2 = expression.evaluate(bindings);
-
-		return this.converter.convertBoolean(value.equals(value2));
-	}
-
-}
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/function/StrLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/function/StrLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/function/StrLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/function/StrLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -22,28 +22,22 @@
  * @author Ryan Levering
  * @version 1.2
  */
-public class StrLogic implements ExpressionLogic {
-
-	/**
-	 * The data that holds the argument to evaluate for string conversion.
-	 */
-	private final CallExpressionData data;
-
-	/**
-	 * The factory used to create new string literals.
-	 */
-	private final SPARQLValueFactory factory;
-
-	/**
-	 * Creates a new logic object that can evaluate the string representation of
-	 * a IRI or literal.
-	 * 
-	 * @param data the data holding the argument for evaluation
-	 */
-	public StrLogic(CallExpressionData data, SPARQLValueFactory factory) {
-		this.data = data;
-		this.factory = factory;
-	}
+public class StrLogic extends FunctionLogic {
+    /**
+     * The factory used to create new string literals.
+     */
+    private final SPARQLValueFactory factory;
+
+    /**
+     * Creates a new logic object that can evaluate the string representation of
+     * a IRI or literal.
+     * 
+     * @param data the data holding the argument for evaluation
+     */
+    public StrLogic(CallExpressionData data, SPARQLValueFactory factory) {
+        super(data);
+        this.factory = factory;
+    }
 
 	/**
 	 * Evaluates the argument to the function and does simplistic conversion to
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/naive/DefaultFilterConstraintLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/naive/DefaultFilterConstraintLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/naive/DefaultFilterConstraintLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/naive/DefaultFilterConstraintLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -8,6 +8,7 @@
 import java.util.Collection;
 import java.util.Collections;
 import java.util.Iterator;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.RdfBindingRow;
 import name.levering.ryan.sparql.common.RdfBindingSet;
@@ -74,17 +75,16 @@
      *            this constraint
      * @return a binding set with values that pass through the filter expression
      */
-    public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source,
-            Collection defaultDatasets, Collection namedDatasets) {
+    public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
         // Grab the necessary fields from the data
         ExpressionLogic filterExpression = this.data.getExpression();
 
         // Create a new binding set with the same variables
         RdfBindingSetImpl newBindings = new RdfBindingSetImpl(
-                bindings.getVariables());
+                p.bindings.getVariables());
 
         // Only add rows to the new set if they return true boolean literals
-        for (Iterator rows = bindings.iterator(); rows.hasNext();) {
+        for (Iterator rows = p.bindings.iterator(); rows.hasNext();) {
             RdfBindingRow row = (RdfBindingRow) rows.next();
             try {
                 Value rawEvaluate = filterExpression.evaluate(row);
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/naive/DefaultGroupConstraintLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/naive/DefaultGroupConstraintLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/naive/DefaultGroupConstraintLogic.java	2006-08-20 20:01:01.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/naive/DefaultGroupConstraintLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -9,6 +9,7 @@
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
 import name.levering.ryan.sparql.common.RdfSource;
@@ -73,18 +74,19 @@
 	 * @param namedDatasets the named datasets to query in an unbound graph
 	 *            query, passed on to subconstraints
 	 */
-	public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets,
-			Collection namedDatasets) {
-		return this.constrain(bindings, source, defaultDatasets, namedDatasets, true);
+	public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
+		return this.constrain(p, true);
 	}
 
-	private RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets,
-			Collection namedDatasets, boolean withFilter) {
+	private RdfBindingSet constrain(ConstraintLogic.CallParams p, boolean withFilter) {
 
 		List filterQueue = new LinkedList();
 		List optionalQueue = new LinkedList();
 		List graphQueue = new LinkedList();
 
+		ConstraintLogic.CallParams p2 = p.clone();
+		p2.bindings = null;
+
 		RdfBindingSet current = null;
 		// Constrain in order, unless we hit an optional, graph, or value filter
 		// These things all kind of depend on the previous bindings
@@ -99,7 +101,7 @@
 			} else if (c instanceof GraphConstraintData) {
 				graphQueue.add(c);
 			} else {
-				this.orderLogic.addBindingSet(c.constrain(null, source, defaultDatasets, namedDatasets));
+				this.orderLogic.addBindingSet(c.constrain(p2));
 			}
 
 		}
@@ -108,10 +110,17 @@
 		// This scoped graphing isn't required by the spec, but it's allowed
 		for (Iterator graphs = graphQueue.iterator(); graphs.hasNext();) {
 			ConstraintLogic c = (ConstraintLogic) graphs.next();
+			p2.bindings = current;
+			
+			// Only when the graph consists of a single triple constraint and
+			// there are no filters can we pass down a limit.
+			if (graphQueue.size() != -1 || filterQueue.size() > 0)
+				p2.limit = -1;
+				
 			if (current == null) {
-				current = c.constrain(null, source, defaultDatasets, namedDatasets);
+				current = c.constrain(p2);
 			} else {
-				current = this.logic.intersect(current, c.constrain(current, source, defaultDatasets, namedDatasets));
+				current = this.logic.intersect(current, c.constrain(p2));
 			}
 		}
 
@@ -123,11 +132,14 @@
 
 		for (Iterator optionals = optionalQueue.iterator(); optionals.hasNext();) {
 			ConstraintLogic c = (ConstraintLogic) optionals.next();
-			current = c.constrain(current, source, defaultDatasets, namedDatasets);
+			p2.bindings = current;
+			// note that we pass down the limit
+			current = c.constrain(p2);
 		}
 		for (Iterator filters = filterQueue.iterator(); filters.hasNext();) {
 			ConstraintLogic c = (ConstraintLogic) filters.next();
-			current = c.constrain(current, source, defaultDatasets, namedDatasets);
+			p2.bindings = current;
+			current = c.constrain(p2);
 		}
 		return current;
 	}
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/naive/DefaultOptionalConstraintLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/naive/DefaultOptionalConstraintLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/naive/DefaultOptionalConstraintLogic.java	2006-08-20 20:01:01.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/naive/DefaultOptionalConstraintLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -9,6 +9,7 @@
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
 import name.levering.ryan.sparql.common.RdfSource;
@@ -74,13 +75,16 @@
 	 * @param namedDatasets the named datasets for named queries, passed onto
 	 *            the grouped constraint
 	 */
-	public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets,
-			Collection namedDatasets) {
+	public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
 		List filterQueue = new LinkedList();
 		List optionalQueue = new LinkedList();
 		List graphQueue = new LinkedList();
 
 		RdfBindingSet current = null;
+		
+		ConstraintLogic.CallParams p2 = p.clone();
+		p2.bindings = null;
+
 		// Constrain in order, unless we hit an optional, graph, or value filter
 		// These things all kind of depend on the previous bindings
 		// Graph probably shouldn't technically, but I think in this
@@ -94,7 +98,7 @@
 			} else if (c instanceof GraphConstraint) {
 				graphQueue.add(c);
 			} else {
-				this.orderLogic.addBindingSet(c.constrain(null, source, defaultDatasets, namedDatasets));
+				this.orderLogic.addBindingSet(c.constrain(p2));
 			}
 
 		}
@@ -103,11 +107,17 @@
 		// This isn't required by the spec, but it's allowed
 		for (Iterator graphs = graphQueue.iterator(); graphs.hasNext();) {
 			ConstraintLogic c = (ConstraintLogic) graphs.next();
+			
+			// Only when the graph consists of a single triple constraint and
+			// there are no filters can we pass down a limit.
+			if (graphQueue.size() != -1 || filterQueue.size() > 0)
+				p2.limit = -1;
+			
 			if (current == null) {
-				current = c.constrain(null, source, defaultDatasets, namedDatasets);
+				current = c.constrain(p2);
 			} else {
-				current = this.intersectLogic.intersect(current, c.constrain(current, source, defaultDatasets,
-						namedDatasets));
+				p2.bindings = current;
+				current = this.intersectLogic.intersect(current, c.constrain(p2));
 			}
 		}
 
@@ -119,10 +129,11 @@
 
 		for (Iterator optionals = optionalQueue.iterator(); optionals.hasNext();) {
 			ConstraintLogic c = (ConstraintLogic) optionals.next();
-			current = c.constrain(current, source, defaultDatasets, namedDatasets);
+			p2.bindings = current;
+			current = c.constrain(p2);
 		}
 		
-		return this.logic.join(bindings, current, filterQueue);
+		return this.logic.join(p.bindings, current, filterQueue);
 	}
 
 }
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/naive/DefaultTripleConstraintLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/naive/DefaultTripleConstraintLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/naive/DefaultTripleConstraintLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/naive/DefaultTripleConstraintLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -9,6 +9,7 @@
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.GraphStatement;
 import name.levering.ryan.sparql.common.LenientStatement;
@@ -62,8 +63,7 @@
      *            used in this constraint
      * 
      */
-    public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source,
-            Collection defaultDatasets, Collection namedDatasets) {
+    public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
 
         ExpressionLogic subExpr = this.data.getSubjectExpression();
         ExpressionLogic predExpr = this.data.getPredicateExpression();
@@ -109,25 +109,25 @@
 
         Iterator statements;
         if (!variables.isEmpty()) {
-            if (defaultDatasets == null) {
+            if (p.defaultDatasets == null) {
                 // This adds an extra column to the returned set for the GRAPH
                 // constraint to process
                 variables.add(StreamedGraphConstraintLogic.CONTEXT_VARIABLE);
                 newBindings = new RdfBindingSetImpl(
                         (Variable[]) variables.toArray(new Variable[0]));
-                statements = source.getStatements(subject, verb, object);
+                statements = p.source.getStatements(subject, verb, object);
                 addGraphStatements(newBindings, statements, flags);
             } else {
-                if (defaultDatasets.isEmpty()) {
+                if (p.defaultDatasets.isEmpty()) {
                     // This is if no FROM graphs are specified
-                    statements = source.getDefaultStatements(subject, verb,
+                    statements = p.source.getDefaultStatements(subject, verb,
                             object);
                     addStatements(newBindings, statements, flags);
                 } else {
                     // This is if FROM graphs are specified or FROM NAMED and
                     // we're in a GRAPH constraint
-                    for (Iterator i = defaultDatasets.iterator(); i.hasNext();) {
-                        statements = source.getStatements(subject, verb,
+                    for (Iterator i = p.defaultDatasets.iterator(); i.hasNext();) {
+                        statements = p.source.getStatements(subject, verb,
                                 object, (URI) i.next());
                         addStatements(newBindings, statements, flags);
                     }
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/naive/DefaultUnionConstraintLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/naive/DefaultUnionConstraintLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/naive/DefaultUnionConstraintLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/naive/DefaultUnionConstraintLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -7,9 +7,12 @@
 
 import java.util.Collection;
 import java.util.Iterator;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
 import name.levering.ryan.sparql.common.RdfSource;
+import name.levering.ryan.sparql.common.impl.RdfBindingSetImpl;
+import name.levering.ryan.sparql.model.GroupConstraint;
 import name.levering.ryan.sparql.model.data.UnionConstraintData;
 import name.levering.ryan.sparql.model.logic.ConstraintLogic;
 import name.levering.ryan.sparql.model.logic.helper.SetUnionLogic;
@@ -60,15 +63,24 @@
 	 * @return a set containing the union of all the bound values of all the sub
 	 *         constraints
 	 */
-	public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets,
-			Collection namedDatasets) {
+	public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
 		RdfBindingSet current = null;
+		ConstraintLogic.CallParams p2 = p.clone();
 		for (Iterator groupOrUnions = this.data.getConstraints().iterator(); groupOrUnions.hasNext();) {
 			ConstraintLogic group = (ConstraintLogic) groupOrUnions.next();
+			p2.bindings = current;
 			if (current == null) {
-				current = group.constrain(current, source, defaultDatasets, namedDatasets);
+				current = group.constrain(p2);
 			} else {
-				current = this.logic.union(current, group.constrain(current, source, defaultDatasets, namedDatasets));
+				// If a limit is provided, subtract from the limit the number
+				// of rows found already, and if we don't need any more, stop.
+				if (p.limit >= 0) {
+					p2.limit = p.limit - current.size();
+					if (p2.limit <= 0)
+						break;
+				}
+				
+				current = this.logic.union(current, group.constrain(p2));
 			}
 		}
 
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/naive/NaiveSetJoinLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/naive/NaiveSetJoinLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/naive/NaiveSetJoinLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/naive/NaiveSetJoinLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -121,6 +121,7 @@
                 }
             }
             if (!outerMatched) {
+                List values = new ArrayList();
                 RdfBindingRowImpl newRow = new RdfBindingRowImpl();
                 for (Iterator k = oldVariables.iterator(); k.hasNext();) {
                 	Variable var = (Variable) k.next();
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/naive/StaticSetRangeLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/naive/StaticSetRangeLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/naive/StaticSetRangeLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/naive/StaticSetRangeLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -5,6 +5,7 @@
  */
 package name.levering.ryan.sparql.logic.naive;
 
+import java.util.ArrayList;
 import java.util.Iterator;
 import java.util.List;
 
@@ -13,8 +14,11 @@
 import name.levering.ryan.sparql.common.Variable;
 import name.levering.ryan.sparql.common.impl.RdfBindingRowImpl;
 import name.levering.ryan.sparql.common.impl.RdfBindingSetImpl;
+import name.levering.ryan.sparql.model.logic.ExpressionLogic;
 import name.levering.ryan.sparql.model.logic.helper.SetRangeLogic;
 
+import name.levering.ryan.sparql.common.Value;
+
 /**
  * This is the default in-memory algorithm to do set ranges and offsets. It
  * should only be used if caching of some sort is important, so a concrete
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/naive/StaticSetUnionLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/naive/StaticSetUnionLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/naive/StaticSetUnionLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/naive/StaticSetUnionLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -16,6 +16,8 @@
 import name.levering.ryan.sparql.common.impl.RdfBindingSetImpl;
 import name.levering.ryan.sparql.model.logic.helper.SetUnionLogic;
 
+import name.levering.ryan.sparql.common.Value;
+
 /**
  * This implements the default set union logic, which returns a binding set that
  * is the aggregation of two other binding sets. This implementation does this
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/streamed/AdvancedGroupConstraintLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/streamed/AdvancedGroupConstraintLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/streamed/AdvancedGroupConstraintLogic.java	1969-12-31 19:00:00.000000000 -0500
+++ work-copy/src/main/name/levering/ryan/sparql/logic/streamed/AdvancedGroupConstraintLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -0,0 +1,578 @@
+/*
+ * SPARQL Engine
+ * Copyright (C) 2005 Ryan Levering, All rights reserved.
+ * See LICENSE for full license information
+ */
+package name.levering.ryan.sparql.logic;
+
+import java.util.Collection;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Iterator;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+import name.levering.ryan.sparql.common.URI;
+import name.levering.ryan.sparql.common.BNode;
+import name.levering.ryan.sparql.common.Literal;
+import name.levering.ryan.sparql.common.Value;
+
+import name.levering.ryan.sparql.common.impl.AbstractRdfBindingRow;
+import name.levering.ryan.sparql.common.impl.InternalSPARQLValueFactory;
+import name.levering.ryan.sparql.common.RdfBindingSet;
+import name.levering.ryan.sparql.common.RdfBindingRow;
+import name.levering.ryan.sparql.common.RdfSource;
+import name.levering.ryan.sparql.common.Variable;
+import name.levering.ryan.sparql.common.impl.RdfBindingSetImpl;
+import name.levering.ryan.sparql.logic.function.ExternalFunctionLogic;
+import name.levering.ryan.sparql.model.TripleConstraint;
+import name.levering.ryan.sparql.model.data.FilterConstraintData;
+import name.levering.ryan.sparql.model.data.GroupConstraintData;
+import name.levering.ryan.sparql.model.data.OptionalConstraintData;
+import name.levering.ryan.sparql.model.logic.ConstraintLogic;
+import name.levering.ryan.sparql.model.logic.ExpressionLogic;
+import name.levering.ryan.sparql.model.logic.helper.SetIntersectLogic;
+import name.levering.ryan.sparql.parser.model.ASTAndNode;
+import name.levering.ryan.sparql.parser.model.ASTEqualsNode;
+import name.levering.ryan.sparql.parser.model.ASTOrNode;
+import name.levering.ryan.sparql.parser.model.ASTVar;
+import name.levering.ryan.sparql.parser.model.BinaryExpressionNode;
+import name.levering.ryan.sparql.parser.model.DelegatingTripleConstraint;
+import name.levering.ryan.sparql.parser.model.EmptyVisitor;
+import name.levering.ryan.sparql.parser.model.SimpleNode;
+
+/**
+ * This logic is the default logic for the main constraint that is used as an
+ * aggregate of other constraints. TripleConstraints, UnionConstraints, and
+ * GraphConstraints all are intersected with the running binding set. After
+ * that, OptionalConstraints and FilterConstraints modify the set themselves.
+ * 
+ * @author Ryan Levering
+ * @version 1.0
+ */
+public class AdvancedGroupConstraintLogic implements ConstraintLogic {
+
+    /**
+     * The data that holds the constraints that this group constraint
+     * aggregates.
+     */
+    private final GroupConstraintData data;
+
+    /**
+     * This logic that intersects the parts of the graph pattern.
+     */
+    private final SetIntersectLogic logic;
+	 
+	 InternalSPARQLValueFactory valueFactory = new InternalSPARQLValueFactory();
+
+    
+    private static final Map
+		isFunctional = new HashMap(),
+    	isInverseFunctional = new HashMap();
+    
+    /**
+     * Creates a new default group logic, with the given subconstraints found in
+     * the data.
+     * 
+     * @param data the data holding the subconstraints to bind
+     */
+    public AdvancedGroupConstraintLogic(GroupConstraintData data, SetIntersectLogic logic) {
+        this.logic = logic;
+        this.data = data;
+    }
+
+    /**
+     * Applies each subconstraint in turn, saving filter and optional
+     * constraints for last, as according to specification.
+     * 
+     * @param bindings the current running bindings, ignored here
+     * @param source the source to query RDF triples, passed on to
+     *            subconstraints
+     * @param defaultDatasets the datasets to query by default, passed on to
+     *            subconstraints
+     * @param namedDatasets the named datasets to query in an unbound graph
+     *            query, passed on to subconstraints
+     */
+    public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
+	
+		// Build separate lists for the different constraints that this group may contain.
+
+		List tripleConstraints = new LinkedList();
+        List filterQueue = new LinkedList();
+        List optionalQueue = new LinkedList();
+		List otherQueue = new LinkedList();
+
+		// Clone knownValues and knownFilters so we can freely modify it without affecting the caller.
+		
+		p = p.clone();
+		if (p.knownValues == null)
+			p.knownValues = new HashMap();
+		else
+			p.knownValues = new HashMap(p.knownValues);
+			
+		if (p.knownFilters == null)
+			p.knownFilters = new HashMap();
+		else
+			p.knownFilters = new HashMap(p.knownFilters);
+		
+		// Get a list of variables that have known values, and of those the ones that are really cheap
+		// (i.e. have just a few values).
+		// We'll build these sets in the course of reordering the statements to query most efficiently.
+
+		Set knownVars = new HashSet();
+		Set cheapVars = new HashSet();
+		
+		// Any variables known by groups on top of us are known here, and cheap (I guess).
+		knownVars.addAll(p.knownValues.keySet());
+		cheapVars.addAll(p.knownValues.keySet());
+		
+		// Split out the types of constraints and look for filters that tell us interesting things.
+		
+        for (Iterator cons = data.getConstraints().iterator(); cons.hasNext();) {
+            ConstraintLogic c = (ConstraintLogic) cons.next();
+            if (c instanceof OptionalConstraintData) {
+				optionalQueue.add(c);
+            } else if (c instanceof FilterConstraintData) {
+				filterQueue.add(c);
+				
+				FilterConstraintData f = (FilterConstraintData)c;
+				if (f.getExpression() instanceof BinaryExpressionNode) {
+					// If this filter is of the form FILTER(?var = <uri> || ?var = <uri> || ...)
+					// then this is giving us some known values for the variable.
+					BinaryExpressionNode b = (BinaryExpressionNode)f.getExpression();
+					Variable v = getFilterPrimaryVariable(b);
+					if (v != null) {
+						Set values = new HashSet();
+						getFilterValues(b, values);
+						if (!p.knownValues.containsKey(v)) {
+							p.knownValues.put(v, values);
+							knownVars.add(v);
+							cheapVars.add(v);
+						} else {
+							Set othervalues = (Set)p.knownValues.get(v);
+							othervalues.retainAll(values);
+						}
+					}
+				}
+				
+				// This by default does nothing, but subclassors may decide to do things here.
+				extractLiteralFilters(f.getExpression(), p.knownFilters);
+				
+			} else if (c instanceof TripleConstraint) {
+				tripleConstraints.add(c);
+			} else {
+				otherQueue.add(c);
+			}
+		}
+		
+		// Reorder the triple constraints so that complex constraints are done
+		// after some of their variables have already been evaluated.  This is
+		// a bit N^2-ish in the number of triple constraints, but it can be improved.
+		List constraintOrder = new LinkedList();
+		Set selectedVars = new HashSet();
+		while (tripleConstraints.size() > 0) {
+			TripleConstraint leastConstraint = null;
+			float leastComplexity = -1;
+			
+			if (tripleConstraints.size() == 1) {
+				leastConstraint = (TripleConstraint)tripleConstraints.get(0);
+			} else {
+				//System.err.println(">>>");
+				
+				for (Iterator cons = tripleConstraints.iterator(); cons.hasNext();) {
+					TripleConstraint c = (TripleConstraint) cons.next();
+					float complexity = getComplexity(c, knownVars, cheapVars, p.knownFilters, p.source);
+					//System.err.println(">>> " + complexity + "\t" + c);
+					if (leastConstraint == null || complexity < leastComplexity) {
+						leastComplexity = complexity;
+						leastConstraint = c;
+					}
+				}
+			}
+
+			tripleConstraints.remove(leastConstraint);
+			constraintOrder.add(leastConstraint);
+			
+			// Get the variables mentioned in this triple constraint
+			Set constraintVars = new HashSet();
+			getVariables(leastConstraint, constraintVars);
+			
+			// Keep a list of variables that have been selected on so far
+			selectedVars.addAll(constraintVars);
+			
+			// And all of these variables are now considered 'known' for the purposes of
+			// selecting which statement goes next.  But they're not considered 'cheap'.
+			knownVars.addAll(constraintVars);
+			
+			// Well, if this triple was functional or inverse functional, we *can*
+			// consider the variables mentioned in the triple cheap.
+			if (leastComplexity <= 1)
+				cheapVars.addAll(constraintVars);
+			
+			// Perform any filters that are such that all of the
+			// variables mentioned in the filter have already been selected
+			// on.  The earlier we filter the better.  (We have to know not just
+			// which variables are known so far, because ones that are known from
+			// filters may not yet be actually bound in the binding set.  Rather,
+			// we have to know which ones have actually been selected on in a
+			// triple.  Here, we only know what's been selected on in this group,
+			// and not at a higher level.)
+	        for (Iterator filters = filterQueue.iterator(); filters.hasNext();) {
+	            FilterConstraintData c = (FilterConstraintData) filters.next();
+	            /*boolean allvarsknown = true;
+	            Set filterVars = getFilterVariables((SimpleNode)c);
+	            for (Iterator vars = filterVars.iterator(); vars.hasNext(); ) {
+	            	if (!selectedVars.contains(vars.next())) {
+	            		allvarsknown = false;
+	            		break;
+	            	}
+	            }
+	            if (allvarsknown) {
+	            	constraintOrder.add(c);
+	            	filters.remove();
+	            }*/
+	        }
+        }
+		
+		// Add the otherQueue back in.
+		constraintOrder.addAll(otherQueue);
+
+		// Run the constraints in the new order.
+        RdfBindingSet current = null;
+		
+		// Allow a subclass to take over running the constraints.
+		current = runTripleConstraints(constraintOrder, p.source, p.defaultDatasets, p.namedDatasets, p.knownValues, p.knownFilters, p.limit);
+		if (current != null) {
+			constraintOrder.clear();
+			if (optionalQueue.size() > 0)
+				current = updateKnownVariables(current, p.knownValues);
+		}
+		
+		for (Iterator cons = constraintOrder.iterator(); cons.hasNext();) {
+			ConstraintLogic c = (ConstraintLogic) cons.next();
+			
+			p.bindings = current;
+			
+			// Only when the graph consists of a single triple constraint and
+			// there are no filters can we pass down a limit.
+			if (constraintOrder.size() != 1 || filterQueue.size() > 0)
+				p.limit = -1;
+			
+			if (current == null) {
+				current = c.constrain(p);
+			} else if (c instanceof FilterConstraintData) {
+	            current = c.constrain(p);
+	            filterQueue.remove(c);
+			} else {
+				current = logic.intersect(current, c.constrain(p));
+			}
+
+			if (cons.hasNext() || optionalQueue.size() > 0)
+				current = updateKnownVariables(current, p.knownValues);
+        }
+        
+        // At this point, we're operating on the set, so let's make it an empty one
+        if (current == null) {
+            current = new RdfBindingSetImpl();
+        }
+
+		// Any optionals...
+        for (Iterator optionals = optionalQueue.iterator(); optionals.hasNext();) {
+            ConstraintLogic c = (ConstraintLogic) optionals.next();
+				p.bindings = current;
+				// note that we pass down the limit
+            current = c.constrain(p);
+        }
+		
+		// Any filters that were not moved up in the logic to process them as early as possible.
+        for (Iterator filters = filterQueue.iterator(); filters.hasNext();) {
+            ConstraintLogic c = (ConstraintLogic) filters.next();
+				p.bindings = current;
+            current = c.constrain(p);
+        }
+        return current;
+    }
+
+	protected RdfBindingSet runTripleConstraints(List tripleConstraints, RdfSource source,
+            Collection defaultDatasets, Collection namedDatasets, Map knownValues, Map knownFilters, int limit) {
+		return null;
+	}
+	
+	private RdfBindingSet updateKnownVariables(RdfBindingSet current, Map knownValues) {
+		// If there are more things happening later, update our knownValue
+		// mapping based on what has currently been queried.  We have to
+		// loop through all of the bindings found so far, so we'll put
+		// those bindings into a new set to cache them.
+		
+		current = new RdfBindingSetImpl(current);
+		List variables = current.getVariables();
+		
+		Set hadNewValues = new HashSet();
+		for (Iterator biter = current.iterator(); biter.hasNext(); ) {
+			RdfBindingRow row = (RdfBindingRow)biter.next();
+			List rowvalues = row.getValues();
+			
+			for (int i = 0; i < variables.size(); i++) {
+				Variable var = (Variable) variables.get(i);
+				Value val = (Value) rowvalues.get(i);
+				
+				if (val == null) continue;
+				
+				Set values = (Set)knownValues.get(var);
+				
+				// If knownValues has no mapping for this variable yet,
+				// or if knownValues had a mapping, we want to clear
+				// the mapping and start fresh with the values actually
+				// found.
+				if (values == null || !hadNewValues.contains(var)) { 
+					values = new HashSet();
+					knownValues.put(var, values);
+					hadNewValues.add(var);
+				}
+					
+				values.add(val);
+			}
+		}
+		
+		extractVariableFunctions(knownValues);	
+		
+		return current;
+	}
+	
+    /**
+     * Creates a mapping from variables to a List of filters based on
+	 * the expression.
+     * 
+     * @param node the expression to extract filters from
+	 * @param literalFilters a map from variables to a List of filters (of any type
+	 *                       supported by the underlying AdvancedRdfSource).
+     */
+	protected void extractLiteralFilters(ExpressionLogic node, Map literalFilters) {
+		if (node instanceof ASTAndNode) {
+			extractLiteralFilters(((ASTAndNode)node).getLeftExpression(), literalFilters);
+			extractLiteralFilters(((ASTAndNode)node).getRightExpression(), literalFilters);
+		}
+	}
+	
+	protected void addLiteralFilter(Variable variable, Object filter, Map literalFilters) {
+		List list = (List)literalFilters.get(variable);
+		if (list == null) {
+			list = new java.util.ArrayList();
+			literalFilters.put(variable, list);
+		}
+		list.add(filter);
+	}
+	
+	private void extractVariableFunctions(Map knownValues) {
+        for (Iterator cons = data.getConstraints().iterator(); cons.hasNext();) {
+            ConstraintLogic c = (ConstraintLogic) cons.next();
+            if (c instanceof FilterConstraintData) {
+				FilterConstraintData f = (FilterConstraintData)c;
+				extractVariableFunctions(f.getExpression(), knownValues);
+			}
+		}
+	}
+	
+	private void extractVariableFunctions(ExpressionLogic node, Map knownValues) {
+		if (node instanceof ASTAndNode) {
+			extractVariableFunctions(((ASTAndNode)node).getLeftExpression(), knownValues);
+			extractVariableFunctions(((ASTAndNode)node).getRightExpression(), knownValues);
+		}
+		if (node instanceof ASTOrNode) {
+			Map a = new HashMap();
+			Map b = new HashMap();
+			extractVariableFunctions(((ASTOrNode)node).getLeftExpression(), a);
+			extractVariableFunctions(((ASTOrNode)node).getRightExpression(), b);
+			for (Iterator i = a.keySet().iterator(); i.hasNext(); ) {
+				Variable v = (Variable)i.next();
+				if (b.containsKey(v)) {
+					Set av = (Set)a.get(v);
+					Set bv = (Set)b.get(v);
+					av.addAll(bv);
+					if (knownValues.containsKey(v)) {
+						((Set)knownValues.get(v)).retainAll(av);
+					} else {
+						knownValues.put(v, av);
+					}
+				}
+			}
+		}
+		if (node instanceof ASTEqualsNode) {
+			extractVariableFunctions(((ASTEqualsNode)node).getLeftExpression(), ((ASTEqualsNode)node).getRightExpression(), knownValues);
+			extractVariableFunctions(((ASTEqualsNode)node).getRightExpression(), ((ASTEqualsNode)node).getLeftExpression(), knownValues);
+		}
+	}
+	
+	private void extractVariableFunctions(ExpressionLogic a, ExpressionLogic b, Map knownValues) {
+		if (!(a instanceof Variable)) return;
+		if (knownValues.containsKey(a)) return; // we could intersect with existing values, but be sure not to do this for values we just inserted into the hash
+		
+		if (b instanceof Variable && knownValues.containsKey(b)) {
+			knownValues.put(a, knownValues.get(b));
+		
+		} else if (b instanceof ExternalFunctionLogic) {
+			// if this is a function of one variable, get the values by applying the function
+			// to all of the variables values.  (if it's of more than one variable, we could
+			// permute through the variables...)
+			ExternalFunctionLogic f = (ExternalFunctionLogic)b;
+			Set varargs =  getFilterVariables((SimpleNode)b);
+			
+			if (varargs.size() == 0) { // a constant, ok
+				Value v = f.evaluate(new MyBindingRow(new HashMap()));
+				HashSet vs = new HashSet();
+				vs.add(v);
+				knownValues.put(a, vs);
+				return;
+			}
+			
+			if (varargs.size() > 1) return;
+			
+			for (Iterator i = varargs.iterator(); i.hasNext(); ) {
+				Variable var = (Variable)i.next();
+				if (!knownValues.containsKey(var))
+					return;
+				
+				Set varvalues = (Set)knownValues.get(var);
+				Set newvalues = new HashSet();
+				Map bindings = new HashMap();
+				for (Iterator j = varvalues.iterator(); j.hasNext(); ) {
+					bindings.put(var, j.next());
+					newvalues.add( f.evaluate(new MyBindingRow(bindings)) );
+				}
+				
+				knownValues.put(a, newvalues);
+			}
+		}
+		
+		
+		// TODO: if b is a function whose arguments are all constants or known values, evaluate the function
+	}
+	
+	private class MyBindingRow extends AbstractRdfBindingRow {
+		Map values;
+		public MyBindingRow(Map values) { super(null); this.values = values; }
+		public List getVariables() { return new java.util.ArrayList(values.keySet()); }
+		public Value getValue(Variable v) { return (Value)values.get(v); }
+	}
+	
+    /**
+     * Returns the complexity of the triple constraint, given a set of
+	 * variables that already have known values.  The return value is a
+	 * measure of the number of statements that we expect to match the
+	 * filter, on a nonsensical scale.
+     * 
+     * @param variablesKnown a set of variables whose values are known
+     */
+	private float getComplexity(TripleConstraint triple, Set variablesKnown, Set cheapVariables, Map knownFilters, RdfSource source) {
+		Object subject = triple.getSubjectExpression();
+		Object predicate = triple.getPredicateExpression();
+		Object object = triple.getObjectExpression();
+		
+		boolean isFunctional = predicate instanceof URI && isFunctional((URI)predicate, source, true);
+		boolean isInverseFunctional = predicate instanceof URI && isFunctional((URI)predicate, source, false);
+		
+		// Properties in RDF tend to be many-to-few.  That is, lots of people
+		// may have a particular foaf:name, and one person has very few foaf:names.
+		// Thus, we give a penalty when a new variable occurs in subject position.
+		// Predicate variables have a *low* penality because all things being equal,
+		// we would prefer a variable in predicate position than in the other positions.
+		
+		float subjComplexity = getComplexity2(subject, variablesKnown, cheapVariables, knownFilters, 4);
+		float predComplexity = getComplexity2(predicate, variablesKnown, cheapVariables, knownFilters, 2);
+		float objComplexity = getComplexity2(object, variablesKnown, cheapVariables, knownFilters, 3);
+
+		// If this is a functional or inverse functional statement, then we reduce the
+		// complexity of the object because we know it is in a 1-to-1 relation with
+		// the subject (or the other way around).  (And, in these cases the predicate
+		// isn't a variable, so its complexity is zero anyway.)  Note that these
+		// computations are based on the 1 + maximum possible complexity for the
+		// subject and object, so *modifications to the getComplexity2 function and
+		// the penalities should be reflected here.
+		
+		if (isFunctional) objComplexity /= (7 - subjComplexity);
+		if (isInverseFunctional) subjComplexity /= (6 - objComplexity);
+		// If both functional and inverse functional, then does this make sense?
+		
+		return subjComplexity + predComplexity + objComplexity;
+	}
+	
+	private int getComplexity2(Object thing, Set variablesKnown, Set cheapVariables, Map knownFilters, int penalty) {
+		int ret = 0;
+		if (thing instanceof Variable && !cheapVariables.contains(thing)) {
+			ret++;
+			if (!knownFilters.containsKey(thing)) ret++;
+			if (!variablesKnown.contains(thing)) ret += penalty;
+		}
+		return ret;
+	}
+	
+	private boolean isFunctional(URI predicate, RdfSource source, boolean forward) {
+		Map map = forward ? isFunctional : isInverseFunctional;
+		if (map.containsKey(predicate)) return ((Boolean)map.get(predicate)).booleanValue();
+	
+		URI rdftype = valueFactory.createURI("http://www.w3.org/1999/02/22-rdf-syntax-ns#type");
+		String typeuri = "http://www.w3.org/2002/07/owl#" +
+			( forward ? "FunctionalProperty" : "InverseFunctionalProperty");
+		boolean ret = source.hasDefaultStatement(predicate, rdftype, valueFactory.createURI(typeuri));
+		map.put(predicate, new Boolean(ret));
+		return ret;
+	}
+
+    /**
+     * Adds the variables in the constraint into the set.
+     * 
+     * @param variablesKnown a set of variables whose values are known
+     */
+	private void getVariables(TripleConstraint triple, Set variablesKnown) {
+		if (triple.getSubjectExpression() instanceof Variable) variablesKnown.add(triple.getSubjectExpression());
+		if (triple.getPredicateExpression() instanceof Variable) variablesKnown.add(triple.getPredicateExpression());
+		if (triple.getObjectExpression() instanceof Variable) variablesKnown.add(triple.getObjectExpression());
+	}
+	
+   /**
+     * Gets a variable for the filter.  If the filter is a ASTEqualsNode,
+	 * return the variable on the left hand side.  If the filter is a
+	 * ASTOrNode, return the variable if its the same on both sides,
+	 * or else null.
+     */
+	private Variable getFilterPrimaryVariable(BinaryExpressionNode expr) {
+		if (expr instanceof ASTOrNode
+			&& expr.getLeftExpression() instanceof BinaryExpressionNode
+			&& expr.getRightExpression() instanceof BinaryExpressionNode) {
+			Variable left = getFilterPrimaryVariable((BinaryExpressionNode)expr.getLeftExpression());
+			Variable right = getFilterPrimaryVariable((BinaryExpressionNode)expr.getRightExpression());
+			if (left != null && right != null && left.equals(right)) return left;
+		} else if (expr instanceof ASTEqualsNode
+			&& expr.getLeftExpression() instanceof Variable && (expr.getRightExpression() instanceof URI || expr.getRightExpression() instanceof BNode || expr.getRightExpression() instanceof Literal)) {
+			return (Variable)expr.getLeftExpression(); 
+		}
+		return null;
+	}
+	
+   /**
+     * Gets the values for a filter.  For an ASTEqualsNode, returns
+	 * the right hand side.  For an ASTOrNode, returns the values of its parts.
+     */
+	private void getFilterValues(BinaryExpressionNode expr, Set set) {
+		if (expr instanceof ASTOrNode) {
+			getFilterValues((BinaryExpressionNode)expr.getLeftExpression(), set);
+			getFilterValues((BinaryExpressionNode)expr.getRightExpression(), set);
+		} else if (expr instanceof ASTEqualsNode && (expr.getRightExpression() instanceof URI || expr.getRightExpression() instanceof BNode || expr.getRightExpression() instanceof Literal)) {
+			set.add(expr.getRightExpression());
+		}
+	}
+
+	private Set getFilterVariables(SimpleNode filter) {
+		final HashSet ret = new HashSet();
+		filter.jjtAccept(
+			new EmptyVisitor() {
+				public void visit(ASTVar node) {
+					ret.add(node);
+				}
+			}
+			);
+		return ret;
+	}
+}
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/streamed/IndexedSetIntersectLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/streamed/IndexedSetIntersectLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/streamed/IndexedSetIntersectLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/streamed/IndexedSetIntersectLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -64,7 +64,7 @@
         final List variables;
 
         final List commonVariables;
-
+		
         RdfBindingIntersect(RdfBindingSet set1, RdfBindingSet set2) {
             this.set1 = set1;
             this.set2 = set2;
@@ -259,10 +259,11 @@
             }
 
             public Value getValue(Variable variable) {
-                Value returnValue = this.row1.getValue(variable);
-                if (returnValue == null) {
+				Value returnValue = null;
+				if (set1.getVariables().contains(variable))
+					returnValue = this.row1.getValue(variable);
+                if (returnValue == null && set2.getVariables().contains(variable))
                     returnValue = this.row2.getValue(variable);
-                }
                 return returnValue;
             }
 
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/streamed/IndexedSetJoinLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/streamed/IndexedSetJoinLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/streamed/IndexedSetJoinLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/streamed/IndexedSetJoinLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -81,7 +81,7 @@
 		final List variables;
 
 		final List commonVariables;
-
+		
 		RdfBindingJoin(RdfBindingSet set1, RdfBindingSet set2, Collection filters) {
 			this.set1 = set1;
 			this.set2 = set2;
@@ -293,14 +293,11 @@
 			}
 
 			public Value getValue(Variable variable) {
-				Value returnValue = this.row1.getValue(variable);
-				if (returnValue == null) {
-					if (this.row2 == null) {
-						returnValue = null;
-					} else {
-						returnValue = this.row2.getValue(variable);
-					}
-				}
+				Value returnValue = null;
+				if (set1.getVariables().contains(variable))
+					returnValue = this.row1.getValue(variable);
+				if (returnValue == null && this.row2 != null && set2.getVariables().contains(variable))
+					returnValue = this.row2.getValue(variable);
 				return returnValue;
 			}
 
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/streamed/StreamedFilterConstraintLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/streamed/StreamedFilterConstraintLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/streamed/StreamedFilterConstraintLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/streamed/StreamedFilterConstraintLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -10,6 +10,7 @@
 import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.RdfBindingRow;
 import name.levering.ryan.sparql.common.RdfBindingSet;
@@ -76,9 +77,8 @@
 	 *            this constraint
 	 * @return a binding set with values that pass through the filter expression
 	 */
-	public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets,
-			Collection namedDatasets) {
-		return new FilterBindingSet(bindings, this.data.getExpression());
+	public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
+		return new FilterBindingSet(p.bindings, this.data.getExpression());
 	}
 
 	private class FilterBindingSet extends AbstractRdfBindingSet implements StackedRdfBindingSet {
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/streamed/StreamedGraphConstraintLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/streamed/StreamedGraphConstraintLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/streamed/StreamedGraphConstraintLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/streamed/StreamedGraphConstraintLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -10,6 +10,7 @@
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.RdfBindingRow;
 import name.levering.ryan.sparql.common.RdfBindingSet;
@@ -85,21 +86,21 @@
      * @return a binding set of values bound in the named graphs, potentially
      *         with a bound graph variable
      */
-    public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source,
-            Collection defaultDatasets, Collection namedDatasets) {
+    public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
 
         RdfBindingSet fullSet = new RdfBindingSetImpl();
-        if (bindings != null && bindings.iterator().hasNext()) {
-            for (Iterator i = bindings.iterator(); i.hasNext();) {
+        if (p.bindings != null && p.bindings.iterator().hasNext()) {
+            for (Iterator i = p.bindings.iterator(); i.hasNext();) {
                 RdfBindingRow row = (RdfBindingRow) i.next();
                 Object evaluation = this.data.getGraph().evaluate(row);
                 // If this evaluates to an un-bound variable, assume we want to
                 // apply the group to any named dataset
                 if (evaluation instanceof Variable) {
-                    if (namedDatasets.isEmpty()) {
+                    if (p.namedDatasets.isEmpty()) {
                         // Here we want to use any named dataset in the data
-                        RdfBindingSet namedResults = this.data.getConstraint().constrain(
-                                bindings, source, null, namedDatasets);
+								 ConstraintLogic.CallParams p2 = p.clone();
+								 p2.defaultDatasets = null;
+                        RdfBindingSet namedResults = this.data.getConstraint().constrain(p2);
 
                         RdfBindingSet sourcedSet = changeSource(
                                 (Variable) evaluation, namedResults);
@@ -107,12 +108,13 @@
                         fullSet = this.unionLogic.union(fullSet, sourcedSet);
                     } else {
                         // If there are named datasets, only use those
-                        for (Iterator j = namedDatasets.iterator(); j.hasNext();) {
+                        for (Iterator j = p.namedDatasets.iterator(); j.hasNext();) {
                             URI namedSet = (URI) j.next();
-                            Collection datasets = Arrays.asList(new Object[] { namedSet });
 
-                            RdfBindingSet namedResults = this.data.getConstraint().constrain(
-                                    bindings, source, datasets, namedDatasets);
+									  ConstraintLogic.CallParams p2 = p.clone();
+									  p2.defaultDatasets = Arrays.asList(new Object[] { namedSet });
+									  
+                            RdfBindingSet namedResults = this.data.getConstraint().constrain(p2);
 
                             RdfBindingSet sourcedSet = addSource(
                                     (Variable) evaluation, namedSet,
@@ -122,25 +124,27 @@
                         }
                     }
                 } else if (this.data.getGraph() instanceof Variable) {
-                    Collection datasets = Arrays.asList(new Object[] { evaluation });
-                    RdfBindingSet namedResults = this.data.getConstraint().constrain(
-                            bindings, source, datasets, namedDatasets);
+						   ConstraintLogic.CallParams p2 = p.clone();
+						   p2.defaultDatasets = Arrays.asList(new Object[] { evaluation });
+                    RdfBindingSet namedResults = this.data.getConstraint().constrain(p2);
                     fullSet = this.unionLogic.union(fullSet, addSource(
                             (Variable) this.data.getGraph(), (URI) evaluation,
                             namedResults));
                 } else {
-                    Collection datasets = Arrays.asList(new Object[] { evaluation });
+						   ConstraintLogic.CallParams p2 = p.clone();
+						   p2.defaultDatasets = Arrays.asList(new Object[] { evaluation });
                     fullSet = this.unionLogic.union(fullSet,
-                            this.data.getConstraint().constrain(bindings,
-                                    source, datasets, namedDatasets));
+                            this.data.getConstraint().constrain(p2));
                 }
             }
         } else {
             if (this.data.getGraph() instanceof Variable) {
-                if (namedDatasets.isEmpty()) {
+                if (p.namedDatasets.isEmpty()) {
                     // Here we want to use any named dataset in the data
-                    RdfBindingSet namedResults = this.data.getConstraint().constrain(
-                            bindings, source, null, namedDatasets);
+							ConstraintLogic.CallParams p2 = p.clone();
+							p2.defaultDatasets = null;
+
+							RdfBindingSet namedResults = this.data.getConstraint().constrain(p2);
 
                     RdfBindingSet sourcedSet = changeSource(
                             (Variable) this.data.getGraph(), namedResults);
@@ -148,12 +152,13 @@
                     fullSet = this.unionLogic.union(fullSet, sourcedSet);
                 } else {
                     // If there are named datasets, only use those
-                    for (Iterator j = namedDatasets.iterator(); j.hasNext();) {
+                    for (Iterator j = p.namedDatasets.iterator(); j.hasNext();) {
                         URI namedSet = (URI) j.next();
-                        Collection datasets = Arrays.asList(new Object[] { namedSet });
+							
+								 ConstraintLogic.CallParams p2 = p.clone();
+								 p2.defaultDatasets = Arrays.asList(new Object[] { namedSet });
 
-                        RdfBindingSet namedResults = this.data.getConstraint().constrain(
-                                bindings, source, datasets, namedDatasets);
+                        RdfBindingSet namedResults = this.data.getConstraint().constrain(p2);
 
                         RdfBindingSet sourcedSet = addSource(
                                 (Variable) this.data.getGraph(), namedSet,
@@ -163,10 +168,10 @@
                     }
                 }
             } else {
-                Collection datasets = Arrays.asList(new Object[] { this.data.getGraph() });
+					  ConstraintLogic.CallParams p2 = p.clone();
+					  p2.defaultDatasets = Arrays.asList(new Object[] { this.data.getGraph() });
                 fullSet = this.unionLogic.union(fullSet,
-                        this.data.getConstraint().constrain(bindings, source,
-                                datasets, namedDatasets));
+                        this.data.getConstraint().constrain(p2));
             }
         }
         return fullSet;
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/streamed/StreamedSetProjectionLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/streamed/StreamedSetProjectionLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/streamed/StreamedSetProjectionLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/streamed/StreamedSetProjectionLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -130,8 +130,10 @@
 			}
 
 			public Value getValue(Variable variable) {
-				return ((ExpressionLogic) RdfBindingProjection.this.variableExpressions.get(variable))
-						.evaluate(this.row);
+				ExpressionLogic expr = (ExpressionLogic) RdfBindingProjection.this.variableExpressions.get(variable);
+				if (expr == null)
+					throw new IllegalArgumentException("Variable " + variable + " is not bound in this row.");
+				return expr.evaluate(this.row);
 			}
 
 			public List getVariables() {
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/streamed/StreamedTripleConstraintLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/streamed/StreamedTripleConstraintLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/streamed/StreamedTripleConstraintLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/streamed/StreamedTripleConstraintLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -10,11 +10,14 @@
 import java.util.Iterator;
 import java.util.List;
 import java.util.NoSuchElementException;
+import java.util.Map;
+import java.util.Set;
 
 import name.levering.ryan.sparql.common.GraphStatement;
 import name.levering.ryan.sparql.common.RdfBindingRow;
 import name.levering.ryan.sparql.common.RdfBindingSet;
 import name.levering.ryan.sparql.common.RdfSource;
+import name.levering.ryan.sparql.common.AdvancedRdfSource;
 import name.levering.ryan.sparql.common.URI;
 import name.levering.ryan.sparql.common.Value;
 import name.levering.ryan.sparql.common.Variable;
@@ -62,8 +65,7 @@
 	 * @param namedDatasets the named datasets to use in graph constraints, not
 	 *            used in this constraint
 	 */
-	public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets,
-			Collection namedDatasets) {
+	public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
 
 		ExpressionLogic subExpr = this.data.getSubjectExpression();
 		ExpressionLogic predExpr = this.data.getPredicateExpression();
@@ -74,12 +76,12 @@
 		Value subject = null;
 		if (subExpr instanceof Variable) {
 			variables.add(subExpr);
-			flags[0] = 1;
+			flags[0] = variables.size();
 			if (subExpr.equals(predExpr)) {
-				flags[1] = 1;
+				flags[1] = flags[0];
 			}
 			if (subExpr.equals(objExpr)) {
-				flags[2] = 1;
+				flags[2] = flags[0];
 			}
 		} else {
 			subject = (Value) subExpr;
@@ -88,10 +90,10 @@
 		URI verb = null;
 		if (predExpr instanceof Variable && flags[1] == 0) {
 			variables.add(predExpr);
-			flags[1] = 2;
+			flags[1] = variables.size();
 			if (predExpr.equals(objExpr)) {
-				flags[2] = 2;
-			}
+				flags[2] = flags[2];
+			}                               
 		} else {
 			verb = (URI) predExpr;
 		}
@@ -99,46 +101,58 @@
 		Value object = null;
 		if (objExpr instanceof Variable && flags[2] == 0) {
 			variables.add(objExpr);
-			flags[2] = 3;
+			flags[2] = variables.size();
 		} else if (flags[2] == 0) {
 			object = (Value) objExpr;
 		}
+		
+		TripleQueryOptions query = new TripleQueryOptions();
+		query.source = p.source;
+		query.variables = variables;
+		query.flags = flags;
+		query.knownValues = p.knownValues;
+		query.knownFilters = p.knownFilters;
+		query.limit = p.limit;
+
+		if (p.defaultDatasets == null) {
+			query.includeSource = true;
 
-		if (defaultDatasets == null) {
 			// This adds an extra column to the returned set for the GRAPH
 			// constraint to process
-			if (source != null) {
-				StatementBindingSet bindingSet = new StatementBindingSet(source, variables, flags, true);
+			if (p.source != null) {
+				StatementBindingSet bindingSet = new StatementBindingSet(query);
 				bindingSet.addIterator(new StatementImpl(subject, verb, object));
 				return bindingSet;
 			} else {
-				StreamedTripleBindingSet bindingSet = new StreamedTripleBindingSet(variables, flags, true);
+				StreamedTripleBindingSet bindingSet = new StreamedTripleBindingSet(query);
 				bindingSet.addIterator(new StatementImpl(subject, verb, object));
 				return bindingSet;
 			}
 		} else {
-			if (source != null) {
-				StatementBindingSet bindingSet = new StatementBindingSet(source, variables, flags, false);
-				if (defaultDatasets.isEmpty()) {
+			query.includeSource = false;
+			
+			if (p.source != null) {
+				StatementBindingSet bindingSet = new StatementBindingSet(query);
+				if (p.defaultDatasets.isEmpty()) {
 					// This is if no FROM graphs are specified
 					bindingSet.addIterator(new StatementImpl(subject, verb, object));
 				} else {
 					// This is if FROM graphs are specified or FROM NAMED and
 					// we're in a GRAPH constraint
-					for (Iterator i = defaultDatasets.iterator(); i.hasNext();) {
+					for (Iterator i = p.defaultDatasets.iterator(); i.hasNext();) {
 						bindingSet.addIterator(new StatementImpl(subject, verb, object, (URI) i.next()));
 					}
 				}
 				return bindingSet;
 			} else {
-				StreamedTripleBindingSet bindingSet = new StreamedTripleBindingSet(variables, flags, false);
-				if (defaultDatasets.isEmpty()) {
+				StreamedTripleBindingSet bindingSet = new StreamedTripleBindingSet(query);
+				if (p.defaultDatasets.isEmpty()) {
 					// This is if no FROM graphs are specified
 					bindingSet.addIterator(new StatementImpl(subject, verb, object));
 				} else {
 					// This is if FROM graphs are specified or FROM NAMED and
 					// we're in a GRAPH constraint
-					for (Iterator i = defaultDatasets.iterator(); i.hasNext();) {
+					for (Iterator i = p.defaultDatasets.iterator(); i.hasNext();) {
 						bindingSet.addIterator(new StatementImpl(subject, verb, object, (URI) i.next()));
 					}
 				}
@@ -146,43 +160,73 @@
 			}
 		}
 	}
-
-	/**
-	 * This set is the lowest level binding set that wraps a request to an
-	 * RdfSource. It returns an iterator that uses the row iterators from the
-	 * RdfSource getStatement call to check if returned rows match the equality
-	 * criteria in the passed in flags.
-	 * 
-	 * @author Ryan Levering
-	 * @version 1.1
-	 */
-	private class StatementBindingSet extends AbstractRdfBindingSet {
-
+	
+	private class TripleQueryOptions implements Cloneable {
 		/**
 		 * The RDF source that's being queried.
 		 */
-		final RdfSource source;
+		RdfSource source;
 
 		/**
 		 * The variables that are being bound to values in the RDF source.
 		 */
-		final List variables;
+		List variables;
 
 		/**
 		 * Flags that allow a shortcut to checking for the equality of two
 		 * equivalent variables.
 		 */
-		final int[] flags;
+		int[] flags;
+		
+		/**
+		 * Whether or not to include the graph name in the returned bindings.
+		 */
+		boolean includeSource;
 
 		/**
-		 * The statements that are matched against the RDF source.
+		 * A mapping from variables to Lists of Values that the bindings
+		 * must be drawn from.  (Possibly null if not applicable.)
 		 */
-		final List statementIterators = new ArrayList();
+		Map knownValues;
 
 		/**
-		 * Whether or not to include the graph name in the returned bindings.
+		 * A mapping from variables to Lists of filters (objects) that the bindings
+		 * must satisfy.  (Possibly null if not applicable.)
 		 */
-		final boolean includeSource;
+		Map knownFilters;
+		
+		/**
+		 * -1 if no limit, otherwise the most number of statements to return (but
+		 * may be ignored).
+		 */
+		int limit;
+		
+		public TripleQueryOptions clone() {
+			try {
+				return (TripleQueryOptions)super.clone();
+			} catch (CloneNotSupportedException e) {
+				// lame
+				throw new RuntimeException(e);
+			}
+		}
+	}
+
+	/**
+	 * This set is the lowest level binding set that wraps a request to an
+	 * RdfSource. It returns an iterator that uses the row iterators from the
+	 * RdfSource getStatement call to check if returned rows match the equality
+	 * criteria in the passed in flags.
+	 * 
+	 * @author Ryan Levering
+	 * @version 1.1
+	 */
+	private class StatementBindingSet extends AbstractRdfBindingSet {
+		final TripleQueryOptions query;
+		
+		/**
+		 * The statements that are matched against the RDF source.
+		 */
+		final List statementIterators = new ArrayList();
 
 		/**
 		 * Creates a new binding set that queries a particular RdfSource,
@@ -194,11 +238,8 @@
 		 * @param flags indicates the presence of variable equivalency
 		 * @param includeSource whether to bind the graph name as well
 		 */
-		private StatementBindingSet(RdfSource source, List variables, int[] flags, boolean includeSource) {
-			this.source = source;
-			this.variables = variables;
-			this.flags = flags;
-			this.includeSource = includeSource;
+		private StatementBindingSet(TripleQueryOptions query) {
+			this.query = query;
 		}
 
 		void addIterator(GraphStatement statementIterator) {
@@ -210,8 +251,8 @@
 		}
 
 		public List getVariables() {
-			List extVariables = new ArrayList(this.variables);
-			if (this.includeSource) {
+			List extVariables = new ArrayList(this.query.variables);
+			if (this.query.includeSource) {
 				extVariables.add(StreamedGraphConstraintLogic.CONTEXT_VARIABLE);
 			}
 			return extVariables;
@@ -272,24 +313,70 @@
 				// We should only get here if there was never a chance
 				return null;
 			}
-
+			
 			private Iterator getStatements(GraphStatement statement) {
+				if (StatementBindingSet.this.query.source instanceof AdvancedRdfSource)
+					return getStatementsAdvanced(statement);
+				else
+					return getStatementsSimple(statement);
+			}
+			
+			private Iterator getStatementsSimple(GraphStatement statement) {
+				Value s = statement.getSubject();
+				URI p = statement.getPredicate();
+				Value o = statement.getObject();
+				
+				if (statement.getGraphName() == null) {
+					if (StatementBindingSet.this.query.includeSource) {
+						return StatementBindingSet.this.query.source.getStatements(s, p, o);
+					} else {
+						return StatementBindingSet.this.query.source.getDefaultStatements(s, p, o);
+					}
+				} else {
+					return StatementBindingSet.this.query.source.getStatements(s, p, o, statement.getGraphName());
+				}
+			}
+			
+			private Iterator getStatementsAdvanced(GraphStatement statement) {
+				AdvancedRdfSource source = (AdvancedRdfSource)StatementBindingSet.this.query.source;
+				
+				Value[] s = getValues(statement.getSubject(), 0);
+				Value[] p = getValues(statement.getPredicate(), 1);
+				Value[] o = getValues(statement.getObject(), 2);
+				Object[] litFilters = getFilters(statement.getObject());
+				
 				if (statement.getGraphName() == null) {
-					if (StatementBindingSet.this.includeSource) {
-						return StatementBindingSet.this.source.getStatements(statement.getSubject(), statement
-								.getPredicate(), statement.getObject());
+					if (StatementBindingSet.this.query.includeSource) {
+						return source.getStatements(s, p, o, litFilters, StatementBindingSet.this.query.limit);
 					} else {
-						return StatementBindingSet.this.source.getDefaultStatements(statement.getSubject(), statement
-								.getPredicate(), statement.getObject());
+						return source.getDefaultStatements(s, p, o, litFilters, StatementBindingSet.this.query.limit);
 					}
 				} else {
-					return StatementBindingSet.this.source.getStatements(statement.getSubject(), statement
-							.getPredicate(), statement.getObject(), statement.getGraphName());
+					return source.getStatements(s, p, o, new URI[] { statement.getGraphName() }, litFilters, StatementBindingSet.this.query.limit);
 				}
 			}
+			
+			private Value[] getValues(Value value, int index) {
+				if (value != null) return new Value[] { value };
+				if (StatementBindingSet.this.query.knownValues == null) return null;
+				int varIndex = StatementBindingSet.this.query.flags[index]-1;
+				Variable variable = (Variable)StatementBindingSet.this.query.variables.get(varIndex); 
+				Set values = (Set)StatementBindingSet.this.query.knownValues.get(variable);
+				if (values == null) return null;
+				return (Value[])values.toArray(new Value[0]);
+			}
+			private Object[] getFilters(Value value) {
+				if (value != null) return null;
+				if (StatementBindingSet.this.query.knownFilters == null) return null;
+				int varIndex = StatementBindingSet.this.query.flags[2]-1;
+				Variable variable = (Variable)StatementBindingSet.this.query.variables.get(varIndex);
+				List filters = (List)StatementBindingSet.this.query.knownFilters.get(variable);
+				if (filters == null) return null;
+				return filters.toArray();
+			}
 
 			private boolean checkStatement(GraphStatement statement) {
-				int[] localFlags = StatementBindingSet.this.flags;
+				int[] localFlags = StatementBindingSet.this.query.flags;
 
 				if (localFlags[0] != 0 && localFlags[0] == localFlags[2]) {
 					if (!statement.getSubject().equals(statement.getObject())) {
@@ -337,14 +424,14 @@
 
 				public Value getValue(Variable variable) {
 					// Special case for the source
-					if (StatementBindingSet.this.includeSource
+					if (StatementBindingSet.this.query.includeSource
 							&& variable.equals(StreamedGraphConstraintLogic.CONTEXT_VARIABLE)) {
 						return this.statement.getGraphName();
 					}
 					// First get the index
 					int index = getIndex(variable);
 
-					int[] localFlags = StatementBindingSet.this.flags;
+					int[] localFlags = StatementBindingSet.this.query.flags;
 					if (index == 2) {
 						// If the variable is in the last spot, it's got to be
 						// the object
@@ -374,7 +461,7 @@
 
 				private int getIndex(Variable variable) {
 					int index = 0;
-					for (Iterator vars = StatementBindingSet.this.variables.iterator(); vars.hasNext(); index++) {
+					for (Iterator vars = StatementBindingSet.this.query.variables.iterator(); vars.hasNext(); index++) {
 						Variable var = (Variable) vars.next();
 						if (variable.equals(var)) {
 							return index;
@@ -404,22 +491,18 @@
 
 	private class StreamedTripleBindingSet extends VirtualRdfBindingSet {
 
-		private final List variables;
-
-		private final int[] flags;
-
-		private final boolean includeSource;
-
+		private final TripleQueryOptions query;
+		
 		private final List statementIterators = new ArrayList();
 
-		public StreamedTripleBindingSet(List variables, int[] flags, boolean includeSource) {
-			this.variables = variables;
-			this.flags = flags;
-			this.includeSource = includeSource;
+		public StreamedTripleBindingSet(TripleQueryOptions query) {
+			this.query = query;
 		}
 
 		public void setSource(RdfSource source) {
-			StatementBindingSet set = new StatementBindingSet(source, this.variables, this.flags, this.includeSource);
+			TripleQueryOptions q = query.clone();
+			q.source = source;
+			StatementBindingSet set = new StatementBindingSet(q);
 			for (Iterator statementIt = statementIterators.iterator(); statementIt.hasNext();) {
 				set.addIterator((GraphStatement) statementIt.next());
 			}
@@ -440,4 +523,4 @@
 			setVisitor.visit(this);
 		}
 	}
-}
\ No newline at end of file
+}
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/streamed/StreamedTripleConstraintLogic.java.rej work-copy/src/main/name/levering/ryan/sparql/logic/streamed/StreamedTripleConstraintLogic.java.rej
--- upstream/src/main/name/levering/ryan/sparql/logic/streamed/StreamedTripleConstraintLogic.java.rej	1969-12-31 19:00:00.000000000 -0500
+++ work-copy/src/main/name/levering/ryan/sparql/logic/streamed/StreamedTripleConstraintLogic.java.rej	2007-10-07 07:45:09.000000000 -0400
@@ -0,0 +1,17 @@
+***************
+*** 15,20 ****
+  import name.levering.ryan.sparql.common.RdfBindingRow;
+  import name.levering.ryan.sparql.common.RdfBindingSet;
+  import name.levering.ryan.sparql.common.RdfSource;
+  import name.levering.ryan.sparql.common.Variable;
+  import name.levering.ryan.sparql.common.impl.AbstractRdfBindingRow;
+  import name.levering.ryan.sparql.common.impl.AbstractRdfBindingSet;
+--- 15,22 ----
+  import name.levering.ryan.sparql.common.RdfBindingRow;
+  import name.levering.ryan.sparql.common.RdfBindingSet;
+  import name.levering.ryan.sparql.common.RdfSource;
++ import name.levering.ryan.sparql.common.URI;
++ import name.levering.ryan.sparql.common.Value;
+  import name.levering.ryan.sparql.common.Variable;
+  import name.levering.ryan.sparql.common.impl.AbstractRdfBindingRow;
+  import name.levering.ryan.sparql.common.impl.AbstractRdfBindingSet;
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/StreamedLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/StreamedLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/StreamedLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/StreamedLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -377,8 +377,8 @@
 	 *            direction
 	 * @return the logic handling the ordering of an expression
 	 */
-	public OrderExpressionLogic getOrderExpressionLogic(OrderExpressionData data) {
-		return new DefaultOrderExpressionLogic(data, getValueOrderingLogic());
+	public OrderExpressionLogic getOrderExpressionLogic(OrderExpressionData data, SPARQLValueFactory valueFactory) {
+		return new DefaultOrderExpressionLogic(data, getValueOrderingLogic(valueFactory));
 	}
 
 	/**
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/logic/StreamedStrictLogic.java work-copy/src/main/name/levering/ryan/sparql/logic/StreamedStrictLogic.java
--- upstream/src/main/name/levering/ryan/sparql/logic/StreamedStrictLogic.java	2007-10-07 07:19:19.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/logic/StreamedStrictLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -269,8 +269,8 @@
 	 *            direction
 	 * @return the logic handling the ordering of an expression
 	 */
-	public OrderExpressionLogic getOrderExpressionLogic(OrderExpressionData data) {
-		return new DefaultOrderExpressionLogic(data, getValueOrderingLogic());
+	public OrderExpressionLogic getOrderExpressionLogic(OrderExpressionData data, SPARQLValueFactory valueFactory) {
+		return new DefaultOrderExpressionLogic(data, getValueOrderingLogic(valueFactory));
 	}
 
 	/**
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/model/data/SelectQueryData.java work-copy/src/main/name/levering/ryan/sparql/model/data/SelectQueryData.java
--- upstream/src/main/name/levering/ryan/sparql/model/data/SelectQueryData.java	2007-10-07 07:19:17.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/model/data/SelectQueryData.java	2007-10-21 12:35:15.000000000 -0400
@@ -8,9 +8,9 @@
 import java.util.List;
 
 /**
- * Represents the interface for the data accessors for a SELECT query. A SELECT
- * query has extra information for modifying the solutions as well as a list of
- * variables to project the value binding set onto.
+ * Represents the interface for the data accessors for a SELECT query. A
+ * SELECT query has extra information for modifying the solutions as well as a
+ * list of variables to project the value binding set onto.
  * 
  * @author Ryan Levering
  * @version 1.0
@@ -26,14 +26,6 @@
     public boolean getDistinct();
 
     /**
-     * Returns whether the query should possibly return distinct values in the
-     * resulting binding set.
-     * 
-     * @return true if the reduced keyword was included in the query
-     */
-    public boolean getReduced();
-
-    /**
      * Gets the variable list to project the value bindings onto. This limits
      * the columns returned in the value binding table.
      * 
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/model/logic/ConstraintLogic.java work-copy/src/main/name/levering/ryan/sparql/model/logic/ConstraintLogic.java
--- upstream/src/main/name/levering/ryan/sparql/model/logic/ConstraintLogic.java	2006-08-20 20:00:59.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/model/logic/ConstraintLogic.java	2007-10-21 12:35:15.000000000 -0400
@@ -6,6 +6,7 @@
 package name.levering.ryan.sparql.model.logic;
 
 import java.util.Collection;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
 import name.levering.ryan.sparql.common.RdfSource;
@@ -27,16 +28,58 @@
      * Constrains the value bindings by either constraining the current value
      * bindings or returning a set that will be constrained via intersection
      * with the current set.
-     * 
-     * @param bindings the set of current bindings to evaluate against
-     * @param source the RDF source, which is dealt with by the triple
-     *            constraint
-     * @param defaultDatasets the datasets that are currently being used for
-     *            binding
-     * @param namedDatasets the datasets that are used in the GRAPH constraint
-     *            for unbound variables
      */
-    public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source,
-            Collection defaultDatasets, Collection namedDatasets);
+    public RdfBindingSet constrain(CallParams p);
 
+	 public static class CallParams {
+		 /**
+		  * The set of current bindings to evaluate against, for
+		  * ConstraintLogics where it is used (like filters).
+		  */
+		 public RdfBindingSet bindings;
+		 
+		 /**
+		  * The RDF data source, which is dealt with by the triple constraint
+		  */
+		 public RdfSource source;
+       
+		 /**
+		  * The datasets that are currently being used for binding
+		  */
+		 public Collection defaultDatasets;
+		 
+		 /**
+		  * The datasets that are used in the GRAPH constraint for unbound variables
+		  */
+		 public Collection namedDatasets;
+		
+		 /**
+		  * A mapping from variables to Sets of values that the variable must be drawn from
+		  */
+		 public Map knownValues;
+		 
+		 /**
+		  * A mapping from variables to Lists of filters that the variable must satisfy.
+		  * A filter's type is determined by API implementors.
+		  */
+		 public Map knownFilters;
+		 
+		 /**
+		  * The most number of binding rows that is being requested, or -1
+		  * if all rows are requested. Can be freely ignored by the callee.
+		  */
+		 public int limit = -1;
+		 
+		 public CallParams clone() {
+			 CallParams p = new CallParams();
+			 p.bindings = bindings;
+			 p.source = source;
+			 p.defaultDatasets = defaultDatasets == null ? null : new java.util.ArrayList(defaultDatasets);
+			 p.namedDatasets = namedDatasets == null ? null : new java.util.ArrayList(namedDatasets);
+			 p.knownValues = knownValues == null ? null : new java.util.HashMap(knownValues);
+			 p.knownFilters = knownFilters == null ? null : new java.util.HashMap(knownFilters);
+			 p.limit = limit;
+			 return p;
+		 }
+	 }
 }
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/model/logic/LogicFactory.java work-copy/src/main/name/levering/ryan/sparql/model/logic/LogicFactory.java
--- upstream/src/main/name/levering/ryan/sparql/model/logic/LogicFactory.java	2007-10-07 07:19:17.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/model/logic/LogicFactory.java	2007-10-21 12:35:15.000000000 -0400
@@ -63,7 +63,7 @@
 
 	public ConstraintLogic getOptionalConstraintLogic(OptionalConstraintData data, SPARQLValueFactory valueFactory);
 
-	public OrderExpressionLogic getOrderExpressionLogic(OrderExpressionData data);
+	public OrderExpressionLogic getOrderExpressionLogic(OrderExpressionData data, SPARQLValueFactory valueFactory);
 
 	public ExpressionLogic getAdditionLogic(BinaryExpressionData data, SPARQLValueFactory valueFactory);
 
@@ -109,8 +109,6 @@
 
 	public ExpressionLogic getLangMatchesLogic(CallExpressionData data, SPARQLValueFactory valueFactory);
 
-    public ExpressionLogic getSameTermLogic(CallExpressionData sameTermFuncNode, SPARQLValueFactory valueFactory);
-
 	public ExpressionLogic getRegexLogic(CallExpressionData data, SPARQLValueFactory valueFactory);
 
 	public ExpressionLogic getStringLogic(CallExpressionData data, SPARQLValueFactory valueFactory);
@@ -121,7 +119,7 @@
 
 	public ValueConversionLogic getValueConversionLogic(SPARQLValueFactory valueFactory);
 
-	public ValueOrderingLogic getValueOrderingLogic();
+	public ValueOrderingLogic getValueOrderingLogic(SPARQLValueFactory valueFactory);
 
 	public void registerExternalFunction(URI functionIRI, ExternalFunctionFactory functionFactory);
 
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/JavaCharStream.java work-copy/src/main/name/levering/ryan/sparql/parser/JavaCharStream.java
--- upstream/src/main/name/levering/ryan/sparql/parser/JavaCharStream.java	2007-10-07 07:19:57.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/JavaCharStream.java	2007-10-21 12:35:16.000000000 -0400
@@ -1,4 +1,4 @@
-/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 3.0 */
+/* Generated By:JavaCC: Do not edit this line. JavaCharStream.java Version 4.0 */
 package name.levering.ryan.sparql.parser;
 
 /**
@@ -76,6 +76,10 @@
   protected int maxNextCharInd = 0;
   protected int nextCharInd = -1;
   protected int inBuf = 0;
+  protected int tabSize = 8;
+
+  protected void setTabSize(int i) { tabSize = i; }
+  protected int getTabSize(int i) { return tabSize; }
 
   protected void ExpandBuff(boolean wrapAround)
   {
@@ -234,7 +238,7 @@
            break;
         case '\t' :
            column--;
-           column += (8 - (column & 07));
+           column += (tabSize - (column % tabSize));
            break;
         default :
            break;
@@ -431,33 +435,66 @@
   {
      ReInit(dstream, 1, 1, 4096);
   }
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+     this(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
   public JavaCharStream(java.io.InputStream dstream, int startline,
   int startcolumn, int buffersize)
   {
      this(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
   }
 
+  public JavaCharStream(java.io.InputStream dstream, String encoding, int startline,
+                        int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+     this(dstream, encoding, startline, startcolumn, 4096);
+  }
+
   public JavaCharStream(java.io.InputStream dstream, int startline,
-                                                           int startcolumn)
+                        int startcolumn)
   {
      this(dstream, startline, startcolumn, 4096);
   }
 
+  public JavaCharStream(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+     this(dstream, encoding, 1, 1, 4096);
+  }
+
   public JavaCharStream(java.io.InputStream dstream)
   {
      this(dstream, 1, 1, 4096);
   }
 
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+  int startcolumn, int buffersize) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(encoding == null ? new java.io.InputStreamReader(dstream) : new java.io.InputStreamReader(dstream, encoding), startline, startcolumn, buffersize);
+  }
+
   public void ReInit(java.io.InputStream dstream, int startline,
   int startcolumn, int buffersize)
   {
-     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, 4096);
+     ReInit(new java.io.InputStreamReader(dstream), startline, startcolumn, buffersize);
+  }
+  public void ReInit(java.io.InputStream dstream, String encoding, int startline,
+                     int startcolumn) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(dstream, encoding, startline, startcolumn, 4096);
   }
   public void ReInit(java.io.InputStream dstream, int startline,
-                                                           int startcolumn)
+                     int startcolumn)
   {
      ReInit(dstream, startline, startcolumn, 4096);
   }
+  public void ReInit(java.io.InputStream dstream, String encoding) throws java.io.UnsupportedEncodingException
+  {
+     ReInit(dstream, encoding, 1, 1, 4096);
+  }
+
   public void ReInit(java.io.InputStream dstream)
   {
      ReInit(dstream, 1, 1, 4096);
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/ASTFilterConstraint.java work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTFilterConstraint.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/ASTFilterConstraint.java	2006-08-20 20:01:00.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTFilterConstraint.java	2007-10-21 12:35:16.000000000 -0400
@@ -4,6 +4,7 @@
 
 import java.util.Collection;
 import java.util.Collections;
+import java.util.Map;
 import java.util.Set;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
@@ -24,8 +25,8 @@
         return (ExpressionLogic) this.jjtGetChild(0);
     }
 
-    public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets, Collection namedDatasets) {
-        return this.logic.constrain(bindings, source, defaultDatasets, namedDatasets);
+    public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
+        return this.logic.constrain(p);
     }
 
     public Set getVariables() {
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/ASTGraphConstraint.java work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTGraphConstraint.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/ASTGraphConstraint.java	2006-08-20 20:01:00.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTGraphConstraint.java	2007-10-21 12:35:16.000000000 -0400
@@ -3,6 +3,7 @@
 package name.levering.ryan.sparql.parser.model;
 
 import java.util.Collection;
+import java.util.Map;
 import java.util.Set;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
@@ -40,8 +41,8 @@
         return null;
     }
 
-    public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets, Collection namedDatasets) {
-        return this.logic.constrain(bindings, source, defaultDatasets, namedDatasets);
+    public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
+        return this.logic.constrain(p);
     }
 
     public Set getVariables() {
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/ASTGroupConstraint.java work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTGroupConstraint.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/ASTGroupConstraint.java	2006-08-20 20:01:00.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTGroupConstraint.java	2007-10-21 12:35:16.000000000 -0400
@@ -6,6 +6,7 @@
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.Set;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
@@ -39,9 +40,8 @@
         return constraints;
     }
 
-    public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source,
-            Collection defaultDatasets, Collection namedDatasets) {
-        return this.logic.constrain(bindings, source, defaultDatasets, namedDatasets);
+    public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
+        return this.logic.constrain(p);
     }
 
     public Set getVariables() {
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/ASTLiteral.java work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTLiteral.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/ASTLiteral.java	2007-10-07 07:19:18.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTLiteral.java	2007-10-21 12:35:16.000000000 -0400
@@ -60,4 +60,15 @@
         }
     }
     
+	public int hashCode() {
+		return label.hashCode();
+	}
+	
+	public boolean equals(Object other) {
+		if (!(other instanceof Literal)) return false;
+		Literal lit = (Literal)other;
+		return label.equals(lit.getLabel())
+			&& ((language == null && lit.getLanguage() == null) || (language != null && lit.getLanguage() != null && language.equals(lit.getLanguage())))
+			&& ((datatype == null && lit.getDatatype() == null) || (datatype != null && lit.getDatatype() != null && datatype.equals(lit.getDatatype()))); 
+	}
 }
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/ASTOptionalConstraint.java work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTOptionalConstraint.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/ASTOptionalConstraint.java	2006-08-20 20:01:00.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTOptionalConstraint.java	2007-10-21 12:35:16.000000000 -0400
@@ -3,6 +3,7 @@
 package name.levering.ryan.sparql.parser.model;
 
 import java.util.Collection;
+import java.util.Map;
 import java.util.Set;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
@@ -24,8 +25,8 @@
         return (GroupConstraint) this.jjtGetChild(0);
     }
 
-    public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets, Collection namedDatasets) {
-        return this.logic.constrain(bindings, source, defaultDatasets, namedDatasets);
+    public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
+        return this.logic.constrain(p);
     }
 
     public Set getVariables() {
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/ASTSameTermFuncNode.java work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTSameTermFuncNode.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/ASTSameTermFuncNode.java	2007-10-07 07:19:18.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTSameTermFuncNode.java	1969-12-31 19:00:00.000000000 -0500
@@ -1,22 +0,0 @@
-package name.levering.ryan.sparql.parser.model;
-
-import name.levering.ryan.sparql.model.logic.ExpressionLogic;
-
-import name.levering.ryan.sparql.common.SPARQLValueFactory;
-import name.levering.ryan.sparql.common.URI;
-
-public class ASTSameTermFuncNode extends FunctionNode {
-
-    public ASTSameTermFuncNode(int id) {
-        super(id);
-    }
-
-    public ExpressionLogic getLogic(LogicBinder binder) {
-        return binder.getLogicFactory().getSameTermLogic(this, binder.getValueFactory());
-    }
-
-    public URI getName(SPARQLValueFactory factory) {
-        return factory.createURI("fn:sameTerm");
-    }
-
-}
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/ASTSelectQuery.java work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTSelectQuery.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/ASTSelectQuery.java	2007-10-07 07:19:18.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTSelectQuery.java	2007-10-21 12:35:16.000000000 -0400
@@ -22,8 +22,7 @@
     private SelectQueryLogic logic;
 
     private boolean distinct = false;
-    
-    private boolean reduced = false;
+	 private boolean reduced = false;
 
     public ASTSelectQuery(int id) {
         super(id);
@@ -37,10 +36,6 @@
         this.distinct = distinct;
     }
 
-    public boolean getReduced() {
-        return this.reduced;
-    }
-
     public void setReduced(boolean reduced) {
         this.reduced = reduced;
     }
@@ -124,10 +119,6 @@
             output.append("DISTINCT ");
         }
 
-        if (this.getReduced()) {
-            output.append("REDUCED ");
-        }
-
         List selectVars = this.getQueryVariables();
         if (!selectVars.isEmpty()) {
             for (Iterator i = selectVars.iterator(); i.hasNext();) {
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/ASTUnionConstraint.java work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTUnionConstraint.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/ASTUnionConstraint.java	2006-08-20 20:01:00.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTUnionConstraint.java	2007-10-21 12:35:16.000000000 -0400
@@ -6,6 +6,7 @@
 import java.util.Collection;
 import java.util.HashSet;
 import java.util.Iterator;
+import java.util.Map;
 import java.util.Set;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
@@ -31,8 +32,8 @@
         return constraints;
     }
 
-    public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets, Collection namedDatasets) {
-        return this.logic.constrain(bindings, source, defaultDatasets, namedDatasets);
+    public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
+        return this.logic.constrain(p);
     }
 
     public Set getVariables() {
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/ASTWithExtension.java work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTWithExtension.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/ASTWithExtension.java	2007-10-07 07:19:18.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/ASTWithExtension.java	2007-10-21 12:35:16.000000000 -0400
@@ -6,6 +6,7 @@
 import java.util.Collections;
 import java.util.List;
 import java.util.Set;
+import java.util.Map;
 
 import name.levering.ryan.sparql.common.QueryException;
 import name.levering.ryan.sparql.common.RdfBindingSet;
@@ -25,8 +26,8 @@
         super(id);
     }
     
-    public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets, Collection namedDatasets) {
-        return this.logic.constrain(bindings, source, defaultDatasets, namedDatasets);
+    public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
+        return this.logic.constrain(p);
     }
 
     public URI getName() {
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/DelegatingTripleConstraint.java work-copy/src/main/name/levering/ryan/sparql/parser/model/DelegatingTripleConstraint.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/DelegatingTripleConstraint.java	2006-08-20 20:01:00.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/DelegatingTripleConstraint.java	2007-10-21 12:35:16.000000000 -0400
@@ -7,6 +7,7 @@
 
 import java.util.Collection;
 import java.util.HashSet;
+import java.util.Map;
 import java.util.Set;
 
 import name.levering.ryan.sparql.common.RdfBindingSet;
@@ -39,8 +40,8 @@
         return this.statement.getObjectExpression();
     }
 
-    public RdfBindingSet constrain(RdfBindingSet bindings, RdfSource source, Collection defaultDatasets, Collection namedDatasets) {
-        return this.logic.constrain(bindings, source, defaultDatasets, namedDatasets);
+    public RdfBindingSet constrain(ConstraintLogic.CallParams p) {
+        return this.logic.constrain(p);
     }
 
     public Set getVariables() {
@@ -64,5 +65,5 @@
     public void setLogic(ConstraintLogic logic) {
         this.logic = logic;
     }
-
+	
 }
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/JJTSPARQLParserState.java work-copy/src/main/name/levering/ryan/sparql/parser/model/JJTSPARQLParserState.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/JJTSPARQLParserState.java	2006-08-20 20:05:43.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/JJTSPARQLParserState.java	2007-10-21 12:35:16.000000000 -0400
@@ -1,123 +1,123 @@
-/* Generated By:JJTree: Do not edit this line. /home/tauberer/dev/semweb/sparql/src/src/main/name/levering/ryan/sparql/parser/model/JJTSPARQLParserState.java */
-
-package name.levering.ryan.sparql.parser.model;
-
-class JJTSPARQLParserState {
-  private java.util.Stack nodes;
-  private java.util.Stack marks;
-
-  private int sp;		// number of nodes on stack
-  private int mk;		// current mark
-  private boolean node_created;
-
-  JJTSPARQLParserState() {
-    nodes = new java.util.Stack();
-    marks = new java.util.Stack();
-    sp = 0;
-    mk = 0;
-  }
-
-  /* Determines whether the current node was actually closed and
-     pushed.  This should only be called in the final user action of a
-     node scope.  */
-  boolean nodeCreated() {
-    return node_created;
-  }
-
-  /* Call this to reinitialize the node stack.  It is called
-     automatically by the parser's ReInit() method. */
-  void reset() {
-    nodes.removeAllElements();
-    marks.removeAllElements();
-    sp = 0;
-    mk = 0;
-  }
-
-  /* Returns the root node of the AST.  It only makes sense to call
-     this after a successful parse. */
-  Node rootNode() {
-    return (Node)nodes.elementAt(0);
-  }
-
-  /* Pushes a node on to the stack. */
-  void pushNode(Node n) {
-    nodes.push(n);
-    ++sp;
-  }
-
-  /* Returns the node on the top of the stack, and remove it from the
-     stack.  */
-  Node popNode() {
-    if (--sp < mk) {
-      mk = ((Integer)marks.pop()).intValue();
-    }
-    return (Node)nodes.pop();
-  }
-
-  /* Returns the node currently on the top of the stack. */
-  Node peekNode() {
-    return (Node)nodes.peek();
-  }
-
-  /* Returns the number of children on the stack in the current node
-     scope. */
-  int nodeArity() {
-    return sp - mk;
-  }
-
-
-  void clearNodeScope(Node n) {
-    while (sp > mk) {
-      popNode();
-    }
-    mk = ((Integer)marks.pop()).intValue();
-  }
-
-
-  void openNodeScope(Node n) {
-    marks.push(new Integer(mk));
-    mk = sp;
-    n.jjtOpen();
-  }
-
-
-  /* A definite node is constructed from a specified number of
-     children.  That number of nodes are popped from the stack and
-     made the children of the definite node.  Then the definite node
-     is pushed on to the stack. */
-  void closeNodeScope(Node n, int num) {
-    mk = ((Integer)marks.pop()).intValue();
-    while (num-- > 0) {
-      Node c = popNode();
-      c.jjtSetParent(n);
-      n.jjtAddChild(c, num);
-    }
-    n.jjtClose();
-    pushNode(n);
-    node_created = true;
-  }
-
-
-  /* A conditional node is constructed if its condition is true.  All
-     the nodes that have been pushed since the node was opened are
-     made children of the the conditional node, which is then pushed
-     on to the stack.  If the condition is false the node is not
-     constructed and they are left on the stack. */
-  void closeNodeScope(Node n, boolean condition) {
-    if (condition) {
-      int a = nodeArity();
-      mk = ((Integer)marks.pop()).intValue();
-      while (a-- > 0) {
-	Node c = popNode();
-	c.jjtSetParent(n);
-	n.jjtAddChild(c, a);
-      }
-      n.jjtClose();
-      pushNode(n);
-      node_created = true;
-    } else {
-      mk = ((Integer)marks.pop()).intValue();
-      node_created = false;
-    }
-  }
-}
+/* Generated By:JJTree: Do not edit this line. /home/tauberer/dev/semweb/sparql/src/src/main/name/levering/ryan/sparql/parser/model/JJTSPARQLParserState.java */
+
+package name.levering.ryan.sparql.parser.model;
+
+class JJTSPARQLParserState {
+  private java.util.Stack nodes;
+  private java.util.Stack marks;
+
+  private int sp;		// number of nodes on stack
+  private int mk;		// current mark
+  private boolean node_created;
+
+  JJTSPARQLParserState() {
+    nodes = new java.util.Stack();
+    marks = new java.util.Stack();
+    sp = 0;
+    mk = 0;
+  }
+
+  /* Determines whether the current node was actually closed and
+     pushed.  This should only be called in the final user action of a
+     node scope.  */
+  boolean nodeCreated() {
+    return node_created;
+  }
+
+  /* Call this to reinitialize the node stack.  It is called
+     automatically by the parser's ReInit() method. */
+  void reset() {
+    nodes.removeAllElements();
+    marks.removeAllElements();
+    sp = 0;
+    mk = 0;
+  }
+
+  /* Returns the root node of the AST.  It only makes sense to call
+     this after a successful parse. */
+  Node rootNode() {
+    return (Node)nodes.elementAt(0);
+  }
+
+  /* Pushes a node on to the stack. */
+  void pushNode(Node n) {
+    nodes.push(n);
+    ++sp;
+  }
+
+  /* Returns the node on the top of the stack, and remove it from the
+     stack.  */
+  Node popNode() {
+    if (--sp < mk) {
+      mk = ((Integer)marks.pop()).intValue();
+    }
+    return (Node)nodes.pop();
+  }
+
+  /* Returns the node currently on the top of the stack. */
+  Node peekNode() {
+    return (Node)nodes.peek();
+  }
+
+  /* Returns the number of children on the stack in the current node
+     scope. */
+  int nodeArity() {
+    return sp - mk;
+  }
+
+
+  void clearNodeScope(Node n) {
+    while (sp > mk) {
+      popNode();
+    }
+    mk = ((Integer)marks.pop()).intValue();
+  }
+
+
+  void openNodeScope(Node n) {
+    marks.push(new Integer(mk));
+    mk = sp;
+    n.jjtOpen();
+  }
+
+
+  /* A definite node is constructed from a specified number of
+     children.  That number of nodes are popped from the stack and
+     made the children of the definite node.  Then the definite node
+     is pushed on to the stack. */
+  void closeNodeScope(Node n, int num) {
+    mk = ((Integer)marks.pop()).intValue();
+    while (num-- > 0) {
+      Node c = popNode();
+      c.jjtSetParent(n);
+      n.jjtAddChild(c, num);
+    }
+    n.jjtClose();
+    pushNode(n);
+    node_created = true;
+  }
+
+
+  /* A conditional node is constructed if its condition is true.  All
+     the nodes that have been pushed since the node was opened are
+     made children of the the conditional node, which is then pushed
+     on to the stack.  If the condition is false the node is not
+     constructed and they are left on the stack. */
+  void closeNodeScope(Node n, boolean condition) {
+    if (condition) {
+      int a = nodeArity();
+      mk = ((Integer)marks.pop()).intValue();
+      while (a-- > 0) {
+	Node c = popNode();
+	c.jjtSetParent(n);
+	n.jjtAddChild(c, a);
+      }
+      n.jjtClose();
+      pushNode(n);
+      node_created = true;
+    } else {
+      mk = ((Integer)marks.pop()).intValue();
+      node_created = false;
+    }
+  }
+}
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/OrderExpressionNode.java work-copy/src/main/name/levering/ryan/sparql/parser/model/OrderExpressionNode.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/OrderExpressionNode.java	2006-08-20 20:01:00.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/OrderExpressionNode.java	2007-10-21 12:35:16.000000000 -0400
@@ -31,6 +31,6 @@
     }
 
     public void applyLogic(LogicBinder binder) {
-        this.logic = binder.getLogicFactory().getOrderExpressionLogic(this);
+        this.logic = binder.getLogicFactory().getOrderExpressionLogic(this, binder.getValueFactory());
     }
 }
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/QueryNode.java work-copy/src/main/name/levering/ryan/sparql/parser/model/QueryNode.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/QueryNode.java	2007-10-07 07:19:18.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/QueryNode.java	2007-10-21 12:35:16.000000000 -0400
@@ -25,6 +25,8 @@
 
 	private static final LogicFactory DEFAULT_LOGIC = new StreamedLogic();
 	
+	boolean didBindValues = false, didBindLogic = false;
+	
 	public QueryNode(int i) {
 		super(i);
 	}
@@ -86,13 +88,21 @@
 	}
 
 	public void bindValues(SPARQLValueFactory valueFactory) {
+		if (didBindValues) return;
+		
 		SPARQLParserVisitor resolver = new ValueBinder(valueFactory, getPrefixExpansions(), getBase());
 		this.jjtAccept(resolver);
+		
+		didBindValues = true;
 	}
 
 	public void bindLogic(LogicFactory currentLogic, SPARQLValueFactory valueFactory) {
+		if (didBindLogic) return;
+		
 		LogicBinder logicBinder = new LogicBinder(currentLogic, valueFactory);
 		this.jjtAccept(logicBinder);
+		
+		didBindLogic = true;
 	}
 
 	public String toString() {
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/SPARQLParserTreeConstants.java work-copy/src/main/name/levering/ryan/sparql/parser/model/SPARQLParserTreeConstants.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/SPARQLParserTreeConstants.java	2007-10-07 07:19:57.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/SPARQLParserTreeConstants.java	2007-10-21 12:35:16.000000000 -0400
@@ -1,4 +1,4 @@
-/* Generated By:JJTree: Do not edit this line. C:/workspaces/sparql/SPARQL Engine Trunk/src/main/name/levering/ryan/sparql/parser/model\SPARQLParserTreeConstants.java */
+/* Generated By:JJTree: Do not edit this line. /home/tauberer/dev/semweb/sparql/work-copy/src/main/name/levering/ryan/sparql/parser/model/SPARQLParserTreeConstants.java */
 
 package name.levering.ryan.sparql.parser.model;
 
@@ -37,38 +37,37 @@
   public int JJTTYPEVERB = 30;
   public int JJTBLANKNODEPROPERTYLIST = 31;
   public int JJTCOLLECTION = 32;
-  public int JJTWITHEXTENSION = 33;
-  public int JJTVAR = 34;
-  public int JJTEMPTYNODE = 35;
-  public int JJTORNODE = 36;
-  public int JJTANDNODE = 37;
-  public int JJTEQUALSNODE = 38;
-  public int JJTNOTEQUALSNODE = 39;
-  public int JJTLESSTHANNODE = 40;
-  public int JJTLESSTHANEQUALSNODE = 41;
-  public int JJTGREATERTHANNODE = 42;
-  public int JJTGREATERTHANEQUALSNODE = 43;
-  public int JJTADDITIONNODE = 44;
-  public int JJTSUBTRACTIONNODE = 45;
-  public int JJTMULTIPLICATIONNODE = 46;
-  public int JJTDIVISIONNODE = 47;
-  public int JJTNOTNODE = 48;
-  public int JJTPLUSNODE = 49;
-  public int JJTMINUSNODE = 50;
-  public int JJTSTRFUNCNODE = 51;
-  public int JJTLANGFUNCNODE = 52;
-  public int JJTLANGMATCHESFUNCNODE = 53;
-  public int JJTDTFUNCNODE = 54;
-  public int JJTBOUNDFUNCNODE = 55;
-  public int JJTURIFUNCNODE = 56;
-  public int JJTBLANKFUNCNODE = 57;
-  public int JJTLITERALFUNCNODE = 58;
-  public int JJTREGEXFUNCNODE = 59;
-  public int JJTLITERAL = 60;
-  public int JJTQNAME = 61;
-  public int JJTLABELEDBLANKNODE = 62;
-  public int JJTGENERICBLANKNODE = 63;
-  public int JJTQUOTEDIRIREF = 64;
+  public int JJTVAR = 33;
+  public int JJTEMPTYNODE = 34;
+  public int JJTORNODE = 35;
+  public int JJTANDNODE = 36;
+  public int JJTEQUALSNODE = 37;
+  public int JJTNOTEQUALSNODE = 38;
+  public int JJTLESSTHANNODE = 39;
+  public int JJTLESSTHANEQUALSNODE = 40;
+  public int JJTGREATERTHANNODE = 41;
+  public int JJTGREATERTHANEQUALSNODE = 42;
+  public int JJTADDITIONNODE = 43;
+  public int JJTSUBTRACTIONNODE = 44;
+  public int JJTMULTIPLICATIONNODE = 45;
+  public int JJTDIVISIONNODE = 46;
+  public int JJTNOTNODE = 47;
+  public int JJTPLUSNODE = 48;
+  public int JJTMINUSNODE = 49;
+  public int JJTSTRFUNCNODE = 50;
+  public int JJTLANGFUNCNODE = 51;
+  public int JJTLANGMATCHESFUNCNODE = 52;
+  public int JJTDTFUNCNODE = 53;
+  public int JJTBOUNDFUNCNODE = 54;
+  public int JJTURIFUNCNODE = 55;
+  public int JJTBLANKFUNCNODE = 56;
+  public int JJTLITERALFUNCNODE = 57;
+  public int JJTREGEXFUNCNODE = 58;
+  public int JJTLITERAL = 59;
+  public int JJTQNAME = 60;
+  public int JJTLABELEDBLANKNODE = 61;
+  public int JJTGENERICBLANKNODE = 62;
+  public int JJTQUOTEDIRIREF = 63;
 
 
   public String[] jjtNodeName = {
@@ -105,7 +104,6 @@
     "TypeVerb",
     "BlankNodePropertyList",
     "Collection",
-    "WithExtension",
     "Var",
     "EmptyNode",
     "OrNode",
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/SPARQLParserTreeConstants.java.rej work-copy/src/main/name/levering/ryan/sparql/parser/model/SPARQLParserTreeConstants.java.rej
--- upstream/src/main/name/levering/ryan/sparql/parser/model/SPARQLParserTreeConstants.java.rej	1969-12-31 19:00:00.000000000 -0500
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/SPARQLParserTreeConstants.java.rej	2007-10-07 07:45:08.000000000 -0400
@@ -0,0 +1,11 @@
+***************
+*** 1,4 ****
+- /* Generated By:JJTree: Do not edit this line. C:/workspaces/sparql/SPARQL Engine/src/main/name/levering/ryan/sparql/parser/model\SPARQLParserTreeConstants.java */
+  
+  package name.levering.ryan.sparql.parser.model;
+  
+--- 1,4 ----
++ /* Generated By:JJTree: Do not edit this line. C:/workspaces/sparql/SPARQL Engine Trunk/src/main/name/levering/ryan/sparql/parser/model\SPARQLParserTreeConstants.java */
+  
+  package name.levering.ryan.sparql.parser.model;
+  
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/SPARQLURI.java work-copy/src/main/name/levering/ryan/sparql/parser/model/SPARQLURI.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/SPARQLURI.java	2007-10-07 07:19:18.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/SPARQLURI.java	2007-10-21 12:35:16.000000000 -0400
@@ -30,21 +30,12 @@
     }
 
     /**
-     * Delegates this method to return the internal URI's namespace.
+     * Delegates this method to return the internal URI's URI.
      * 
-     * @return the string namespace of the base URI
+     * @return the string URI of the base URI
      */
-    public String getNamespace() {
-        return this.baseURI.getNamespace();
-    }
-
-    /**
-     * Delegates this method to return the internal URI's local name.
-     * 
-     * @return the string local name of the base URI
-     */
-    public String getLocalName() {
-        return this.baseURI.getLocalName();
+    public String getURI() {
+        return this.baseURI.getURI();
     }
 
     /**
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/URINode.java work-copy/src/main/name/levering/ryan/sparql/parser/model/URINode.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/URINode.java	2007-10-07 07:19:18.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/URINode.java	2007-10-21 12:35:16.000000000 -0400
@@ -21,15 +21,13 @@
 		super(i);
 	}
 
-	public String getNamespace() {
-		return ((URI) this.boundValue).getNamespace();
+	public String getURI() {
+		if (this.boundValue == null)
+			throw new IllegalStateException("boundValue accessed before being initialized");
+		return ((URI) this.boundValue).getURI();
 	}
 
-	public String getLocalName() {
-		return ((URI) this.boundValue).getLocalName();
-	}
-
-	public ValueExpression getBoundValue(ValueBinder binder) {
+	protected ValueExpression getBoundValue(ValueBinder binder) {
 		try {
 			return new SPARQLURI(binder.getFactory().createURI(this.getURI(binder)));
 		} catch (RuntimeException e) {
@@ -37,6 +35,6 @@
 		}
 	}
 
-	public abstract String getURI(ValueBinder binder);
+	protected abstract String getURI(ValueBinder binder);
 
 }
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/model/ValueNode.java work-copy/src/main/name/levering/ryan/sparql/parser/model/ValueNode.java
--- upstream/src/main/name/levering/ryan/sparql/parser/model/ValueNode.java	2007-10-07 07:19:18.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/model/ValueNode.java	2007-10-21 12:35:16.000000000 -0400
@@ -41,7 +41,9 @@
     }
     
     public void applyBinding(ValueBinder binder) {
-        this.boundValue = getBoundValue(binder);
+ 		if (this.boundValue != null)
+			throw new IllegalStateException("boundValue already initialized");
+       this.boundValue = getBoundValue(binder);
     }
     
     public Object getNative() {
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/SPARQLParserConstants.java work-copy/src/main/name/levering/ryan/sparql/parser/SPARQLParserConstants.java
--- upstream/src/main/name/levering/ryan/sparql/parser/SPARQLParserConstants.java	2007-10-07 07:19:57.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/SPARQLParserConstants.java	2007-10-21 12:35:16.000000000 -0400
@@ -5,38 +5,36 @@
 
   int EOF = 0;
   int SINGLE_LINE_COMMENT = 7;
-  int FUNCTION_PAREN = 9;
-  int Q_IRI_REF = 11;
-  int QNAME_NS = 12;
-  int QNAME = 13;
-  int BNODE_LABEL = 14;
-  int VAR1 = 15;
-  int VAR2 = 16;
-  int LANGTAG = 17;
-  int INTEGER = 18;
-  int DECIMAL = 19;
-  int DOUBLE = 20;
-  int STRING_LITERAL1 = 21;
-  int STRING_LITERAL2 = 22;
-  int STRING_LITERAL_LONG1 = 23;
-  int STRING_LITERAL_LONG2 = 24;
-  int NIL = 25;
-  int ANON = 26;
-  int WS = 27;
-  int VARNAME = 28;
-  int NCCHAR = 29;
-  int NCNAME_PREFIX = 30;
-  int NCNAME = 31;
-  int EXPONENT = 32;
-  int ECHAR = 33;
-  int UCHAR = 34;
-  int HEX = 35;
-  int NCCHAR1 = 36;
-  int NCCHAR1P = 37;
+  int IRI_REF = 9;
+  int PNAME_NS = 10;
+  int QNAME = 11;
+  int BNODE_LABEL = 12;
+  int VAR1 = 13;
+  int VAR2 = 14;
+  int LANGTAG = 15;
+  int INTEGER = 16;
+  int DECIMAL = 17;
+  int DOUBLE = 18;
+  int STRING_LITERAL1 = 19;
+  int STRING_LITERAL2 = 20;
+  int STRING_LITERAL_LONG1 = 21;
+  int STRING_LITERAL_LONG2 = 22;
+  int NIL = 23;
+  int ANON = 24;
+  int WS = 25;
+  int VARNAME = 26;
+  int PN_CHARS = 27;
+  int PN_PREFIX = 28;
+  int PN_LOCAL = 29;
+  int EXPONENT = 30;
+  int ECHAR = 31;
+  int UCHAR = 32;
+  int HEX = 33;
+  int PN_CHARS_U = 34;
+  int PN_CHARS_BASE = 35;
 
   int DEFAULT = 0;
   int IN_SINGLE_LINE_COMMENT = 1;
-  int POSSIBLE_FUNCTION = 2;
 
   String[] tokenImage = {
     "<EOF>",
@@ -48,10 +46,8 @@
     "\"#\"",
     "<SINGLE_LINE_COMMENT>",
     "<token of kind 8>",
-    "\"(\"",
-    "<token of kind 10>",
-    "<Q_IRI_REF>",
-    "<QNAME_NS>",
+    "<IRI_REF>",
+    "<PNAME_NS>",
     "<QNAME>",
     "<BNODE_LABEL>",
     "<VAR1>",
@@ -68,19 +64,20 @@
     "<ANON>",
     "<WS>",
     "<VARNAME>",
-    "<NCCHAR>",
-    "<NCNAME_PREFIX>",
-    "<NCNAME>",
+    "<PN_CHARS>",
+    "<PN_PREFIX>",
+    "<PN_LOCAL>",
     "<EXPONENT>",
     "<ECHAR>",
     "<UCHAR>",
     "<HEX>",
-    "<NCCHAR1>",
-    "<NCCHAR1P>",
+    "<PN_CHARS_U>",
+    "<PN_CHARS_BASE>",
     "\"BASE\"",
     "\"PREFIX\"",
     "\"SELECT\"",
     "\"DISTINCT\"",
+    "\"REDUCED\"",
     "\"*\"",
     "\"CONSTRUCT\"",
     "\"DESCRIBE\"",
@@ -101,14 +98,13 @@
     "\"GRAPH\"",
     "\"UNION\"",
     "\"FILTER\"",
+    "\"(\"",
     "\",\"",
     "\")\"",
     "\";\"",
     "\"a\"",
     "\"[\"",
     "\"]\"",
-    "\"(\"",
-    "\"WITH\"",
     "\"+\"",
     "\"-\"",
     "\"||\"",
@@ -126,6 +122,7 @@
     "\"LANGMATCHES\"",
     "\"DATATYPE\"",
     "\"BOUND\"",
+    "\"sameTerm\"",
     "\"isIRI\"",
     "\"isURI\"",
     "\"isBLANK\"",
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/SPARQLParser.java work-copy/src/main/name/levering/ryan/sparql/parser/SPARQLParser.java
--- upstream/src/main/name/levering/ryan/sparql/parser/SPARQLParser.java	2007-10-07 07:19:39.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/SPARQLParser.java	2007-10-21 12:35:16.000000000 -0400
@@ -83,18 +83,18 @@
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
     try {
-      Prolog();
+      Prologue();
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 40:
+      case 38:
         SelectQuery();
         break;
-      case 43:
+      case 42:
         ConstructQuery();
         break;
-      case 44:
+      case 43:
         DescribeQuery();
         break;
-      case 45:
+      case 44:
         AskQuery();
         break;
       default:
@@ -128,9 +128,9 @@
     throw new Error("Missing return statement in function");
   }
 
-  final public void Prolog() throws ParseException {
+  final public void Prologue() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case 38:
+    case 36:
       BaseDecl();
       break;
     default:
@@ -140,7 +140,7 @@
     label_1:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 39:
+      case 37:
         ;
         break;
       default:
@@ -157,7 +157,7 @@
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
     try {
-      jj_consume_token(38);
+      jj_consume_token(36);
       QuotedIRIref();
     } catch (Throwable jjte000) {
           if (jjtc000) {
@@ -186,8 +186,8 @@
         boolean jjtc000 = true;
         jjtree.openNodeScope(jjtn000);Token qName;
     try {
-      jj_consume_token(39);
-      qName = jj_consume_token(QNAME_NS);
+      jj_consume_token(37);
+      qName = jj_consume_token(PNAME_NS);
       QuotedIRIref();
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
@@ -219,127 +219,62 @@
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
     try {
-      jj_consume_token(40);
+      jj_consume_token(38);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 41:
-        jj_consume_token(41);
+      case 39:
+      case 40:
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case 39:
+          jj_consume_token(39);
                                jjtn000.setDistinct(true);
+          break;
+        case 40:
+          jj_consume_token(40);
+                                                                          jjtn000.setReduced(true);
+          break;
+        default:
+          jj_la1[3] = jj_gen;
+          jj_consume_token(-1);
+          throw new ParseException();
+        }
         break;
       default:
-        jj_la1[3] = jj_gen;
+        jj_la1[4] = jj_gen;
         ;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case Q_IRI_REF:
-      case QNAME_NS:
-      case QNAME:
       case VAR1:
       case VAR2:
-      case 68:
-      case 82:
-      case 83:
-      case 84:
-      case 85:
-      case 86:
-      case 87:
-      case 88:
-      case 89:
-      case 90:
-      case 91:
         label_2:
         while (true) {
+          Var();
           switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
           case VAR1:
           case VAR2:
-            Var();
-            break;
-          case Q_IRI_REF:
-          case QNAME_NS:
-          case QNAME:
-          case 68:
-          case 82:
-          case 83:
-          case 84:
-          case 85:
-          case 86:
-          case 87:
-          case 88:
-          case 89:
-          case 90:
-          case 91:
-            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-            case 68:
-              BracketedExpression();
-              break;
-            case 82:
-            case 83:
-            case 84:
-            case 85:
-            case 86:
-            case 87:
-            case 88:
-            case 89:
-            case 90:
-            case 91:
-              BuiltInCall();
-              break;
-            case Q_IRI_REF:
-            case QNAME_NS:
-            case QNAME:
-              FunctionCall();
-              break;
-            default:
-              jj_la1[4] = jj_gen;
-              jj_consume_token(-1);
-              throw new ParseException();
-            }
-            break;
-          default:
-            jj_la1[5] = jj_gen;
-            jj_consume_token(-1);
-            throw new ParseException();
-          }
-          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-          case Q_IRI_REF:
-          case QNAME_NS:
-          case QNAME:
-          case VAR1:
-          case VAR2:
-          case 68:
-          case 82:
-          case 83:
-          case 84:
-          case 85:
-          case 86:
-          case 87:
-          case 88:
-          case 89:
-          case 90:
-          case 91:
             ;
             break;
           default:
-            jj_la1[6] = jj_gen;
+            jj_la1[5] = jj_gen;
             break label_2;
           }
         }
         break;
-      case 42:
-        jj_consume_token(42);
+      case 41:
+        jj_consume_token(41);
         break;
       default:
-        jj_la1[7] = jj_gen;
+        jj_la1[6] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
       label_3:
       while (true) {
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case 46:
+        case 45:
           ;
           break;
         default:
-          jj_la1[8] = jj_gen;
+          jj_la1[7] = jj_gen;
           break label_3;
         }
         DatasetClause();
@@ -373,25 +308,16 @@
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
     try {
-      jj_consume_token(43);
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 41:
-        jj_consume_token(41);
-                                  jjtn000.setDistinct(true);
-        break;
-      default:
-        jj_la1[9] = jj_gen;
-        ;
-      }
+      jj_consume_token(42);
       ConstructTemplate();
       label_4:
       while (true) {
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case 46:
+        case 45:
           ;
           break;
         default:
-          jj_la1[10] = jj_gen;
+          jj_la1[8] = jj_gen;
           break label_4;
         }
         DatasetClause();
@@ -425,79 +351,57 @@
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
     try {
-      jj_consume_token(44);
+      jj_consume_token(43);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case Q_IRI_REF:
-      case QNAME_NS:
+      case IRI_REF:
+      case PNAME_NS:
       case QNAME:
       case VAR1:
       case VAR2:
-      case 68:
-      case 82:
-      case 83:
-      case 84:
-      case 85:
-      case 86:
-      case 87:
-      case 88:
-      case 89:
-      case 90:
-      case 91:
         label_5:
         while (true) {
           VarOrIRIref();
           switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-          case Q_IRI_REF:
-          case QNAME_NS:
+          case IRI_REF:
+          case PNAME_NS:
           case QNAME:
           case VAR1:
           case VAR2:
-          case 68:
-          case 82:
-          case 83:
-          case 84:
-          case 85:
-          case 86:
-          case 87:
-          case 88:
-          case 89:
-          case 90:
-          case 91:
             ;
             break;
           default:
-            jj_la1[11] = jj_gen;
+            jj_la1[9] = jj_gen;
             break label_5;
           }
         }
         break;
-      case 42:
-        jj_consume_token(42);
+      case 41:
+        jj_consume_token(41);
         break;
       default:
-        jj_la1[12] = jj_gen;
+        jj_la1[10] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
       label_6:
       while (true) {
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case 46:
+        case 45:
           ;
           break;
         default:
-          jj_la1[13] = jj_gen;
+          jj_la1[11] = jj_gen;
           break label_6;
         }
         DatasetClause();
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 48:
-      case 55:
+      case 47:
+      case 54:
         WhereClause();
         break;
       default:
-        jj_la1[14] = jj_gen;
+        jj_la1[12] = jj_gen;
         ;
       }
       SolutionModifier();
@@ -528,15 +432,15 @@
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
     try {
-      jj_consume_token(45);
+      jj_consume_token(44);
       label_7:
       while (true) {
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case 46:
+        case 45:
           ;
           break;
         default:
-          jj_la1[15] = jj_gen;
+          jj_la1[13] = jj_gen;
           break label_7;
         }
         DatasetClause();
@@ -564,18 +468,18 @@
   }
 
   final public void DatasetClause() throws ParseException {
-    jj_consume_token(46);
+    jj_consume_token(45);
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case Q_IRI_REF:
-    case QNAME_NS:
+    case IRI_REF:
+    case PNAME_NS:
     case QNAME:
       DefaultGraphClause();
       break;
-    case 47:
+    case 46:
       NamedGraphClause();
       break;
     default:
-      jj_la1[16] = jj_gen;
+      jj_la1[14] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -615,7 +519,7 @@
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
     try {
-      jj_consume_token(47);
+      jj_consume_token(46);
       SourceSelector();
     } catch (Throwable jjte000) {
           if (jjtc000) {
@@ -644,11 +548,11 @@
 
   final public void WhereClause() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case 48:
-      jj_consume_token(48);
+    case 47:
+      jj_consume_token(47);
       break;
     default:
-      jj_la1[17] = jj_gen;
+      jj_la1[15] = jj_gen;
       ;
     }
     GroupGraphPattern();
@@ -656,28 +560,52 @@
 
   final public void SolutionModifier() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case 49:
+    case 48:
       OrderClause();
       break;
     default:
-      jj_la1[18] = jj_gen;
+      jj_la1[16] = jj_gen;
       ;
     }
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case 52:
     case 53:
-      LimitClause();
+      LimitOffsetClauses();
       break;
     default:
-      jj_la1[19] = jj_gen;
+      jj_la1[17] = jj_gen;
       ;
     }
+  }
+
+  final public void LimitOffsetClauses() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case 54:
+    case 52:
+      LimitClause();
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case 53:
+        OffsetClause();
+        break;
+      default:
+        jj_la1[18] = jj_gen;
+        ;
+      }
+      break;
+    case 53:
       OffsetClause();
+      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case 52:
+        LimitClause();
+        break;
+      default:
+        jj_la1[19] = jj_gen;
+        ;
+      }
       break;
     default:
       jj_la1[20] = jj_gen;
-      ;
+      jj_consume_token(-1);
+      throw new ParseException();
     }
   }
 
@@ -687,20 +615,20 @@
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
     try {
+      jj_consume_token(48);
       jj_consume_token(49);
-      jj_consume_token(50);
       label_8:
       while (true) {
         OrderCondition();
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case Q_IRI_REF:
-        case QNAME_NS:
+        case IRI_REF:
+        case PNAME_NS:
         case QNAME:
         case VAR1:
         case VAR2:
+        case 50:
         case 51:
-        case 52:
-        case 68:
+        case 61:
           ;
           break;
         default:
@@ -732,18 +660,18 @@
   final public void OrderCondition() throws ParseException {
 boolean ascending = true;
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case 50:
     case 51:
-    case 52:
             ASTDescOrder jjtn002 = new ASTDescOrder(JJTDESCORDER);
             boolean jjtc002 = true;
             jjtree.openNodeScope(jjtn002);
       try {
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case 50:
+          jj_consume_token(50);
+          break;
         case 51:
           jj_consume_token(51);
-          break;
-        case 52:
-          jj_consume_token(52);
                               ascending = false;
           break;
         default:
@@ -795,19 +723,19 @@
             }
       }
       break;
-    case Q_IRI_REF:
-    case QNAME_NS:
+    case IRI_REF:
+    case PNAME_NS:
     case QNAME:
     case VAR1:
     case VAR2:
-    case 68:
+    case 61:
                       ASTDefaultOrder jjtn003 = new ASTDefaultOrder(JJTDEFAULTORDER);
                       boolean jjtc003 = true;
                       jjtree.openNodeScope(jjtn003);
       try {
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case Q_IRI_REF:
-        case QNAME_NS:
+        case IRI_REF:
+        case PNAME_NS:
         case QNAME:
           FunctionCall();
           break;
@@ -815,7 +743,7 @@
         case VAR2:
           Var();
           break;
-        case 68:
+        case 61:
           BracketedExpression();
           break;
         default:
@@ -856,7 +784,7 @@
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token limit;
     try {
-      jj_consume_token(53);
+      jj_consume_token(52);
       limit = jj_consume_token(INTEGER);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
@@ -874,7 +802,7 @@
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token offset;
     try {
-      jj_consume_token(54);
+      jj_consume_token(53);
       offset = jj_consume_token(INTEGER);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
@@ -892,9 +820,9 @@
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
     try {
-      jj_consume_token(55);
+      jj_consume_token(54);
       GraphPattern();
-      jj_consume_token(56);
+      jj_consume_token(55);
     } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
@@ -919,13 +847,13 @@
   final public void GraphPattern() throws ParseException {
     FilteredBasicGraphPattern();
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case 55:
+    case 54:
+    case 57:
     case 58:
-    case 59:
       GraphPatternNotTriples();
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 57:
-        jj_consume_token(57);
+      case 56:
+        jj_consume_token(56);
         break;
       default:
         jj_la1[25] = jj_gen;
@@ -941,8 +869,8 @@
 
   final public void FilteredBasicGraphPattern() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case Q_IRI_REF:
-    case QNAME_NS:
+    case IRI_REF:
+    case PNAME_NS:
     case QNAME:
     case BNODE_LABEL:
     case VAR1:
@@ -956,23 +884,12 @@
     case STRING_LITERAL_LONG2:
     case NIL:
     case ANON:
+    case 61:
     case 66:
     case 68:
     case 69:
-    case 70:
-    case 71:
-    case 82:
-    case 83:
-    case 84:
-    case 85:
-    case 86:
-    case 87:
-    case 88:
-    case 89:
-    case 90:
-    case 91:
+    case 92:
     case 93:
-    case 94:
       BlockOfTriples();
       break;
     default:
@@ -980,11 +897,11 @@
       ;
     }
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case 61:
+    case 60:
       Constraint();
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 57:
-        jj_consume_token(57);
+      case 56:
+        jj_consume_token(56);
         break;
       default:
         jj_la1[28] = jj_gen;
@@ -1003,17 +920,17 @@
     label_9:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 57:
+      case 56:
         ;
         break;
       default:
         jj_la1[30] = jj_gen;
         break label_9;
       }
-      jj_consume_token(57);
+      jj_consume_token(56);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case Q_IRI_REF:
-      case QNAME_NS:
+      case IRI_REF:
+      case PNAME_NS:
       case QNAME:
       case BNODE_LABEL:
       case VAR1:
@@ -1027,23 +944,12 @@
       case STRING_LITERAL_LONG2:
       case NIL:
       case ANON:
+      case 61:
       case 66:
       case 68:
       case 69:
-      case 70:
-      case 71:
-      case 82:
-      case 83:
-      case 84:
-      case 85:
-      case 86:
-      case 87:
-      case 88:
-      case 89:
-      case 90:
-      case 91:
+      case 92:
       case 93:
-      case 94:
         TriplesSameSubject();
         break;
       default:
@@ -1055,13 +961,13 @@
 
   final public void GraphPatternNotTriples() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case 58:
+    case 57:
       OptionalGraphPattern();
       break;
-    case 55:
+    case 54:
       GroupOrUnionGraphPattern();
       break;
-    case 59:
+    case 58:
       GraphGraphPattern();
       break;
     default:
@@ -1077,7 +983,7 @@
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
     try {
-      jj_consume_token(58);
+      jj_consume_token(57);
       GroupGraphPattern();
     } catch (Throwable jjte000) {
           if (jjtc000) {
@@ -1106,12 +1012,12 @@
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
     try {
-      jj_consume_token(59);
+      jj_consume_token(58);
                   ASTGraph jjtn001 = new ASTGraph(JJTGRAPH);
                   boolean jjtc001 = true;
                   jjtree.openNodeScope(jjtn001);
       try {
-        VarOrBlankNodeOrIRIref();
+        VarOrIRIref();
       } catch (Throwable jjte001) {
                   if (jjtc001) {
                     jjtree.clearNodeScope(jjtn001);
@@ -1158,14 +1064,14 @@
     label_10:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 60:
+      case 59:
         ;
         break;
       default:
         jj_la1[33] = jj_gen;
         break label_10;
       }
-      jj_consume_token(60);
+      jj_consume_token(59);
                                        ASTUnionConstraint jjtn001 = new ASTUnionConstraint(JJTUNIONCONSTRAINT);
                                        boolean jjtc001 = true;
                                        jjtree.openNodeScope(jjtn001);
@@ -1199,11 +1105,13 @@
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
     try {
-      jj_consume_token(61);
+      jj_consume_token(60);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 68:
+      case 61:
         BracketedExpression();
         break;
+      case 80:
+      case 81:
       case 82:
       case 83:
       case 84:
@@ -1213,11 +1121,10 @@
       case 88:
       case 89:
       case 90:
-      case 91:
         BuiltInCall();
         break;
-      case Q_IRI_REF:
-      case QNAME_NS:
+      case IRI_REF:
+      case PNAME_NS:
       case QNAME:
         FunctionCall();
         break;
@@ -1282,58 +1189,70 @@
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
     try {
-      jj_consume_token(FUNCTION_PAREN);
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case Q_IRI_REF:
-      case QNAME_NS:
-      case QNAME:
-      case BNODE_LABEL:
-      case VAR1:
-      case VAR2:
-      case INTEGER:
-      case DECIMAL:
-      case DOUBLE:
-      case STRING_LITERAL1:
-      case STRING_LITERAL2:
-      case STRING_LITERAL_LONG1:
-      case STRING_LITERAL_LONG2:
-      case ANON:
-      case 68:
-      case 70:
-      case 71:
-      case 81:
-      case 82:
-      case 83:
-      case 84:
-      case 85:
-      case 86:
-      case 87:
-      case 88:
-      case 89:
-      case 90:
-      case 91:
-      case 93:
-      case 94:
-        Expression();
-        label_11:
-        while (true) {
-          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-          case 62:
-            ;
-            break;
-          default:
-            jj_la1[35] = jj_gen;
-            break label_11;
-          }
-          jj_consume_token(62);
+      case NIL:
+        jj_consume_token(NIL);
+        break;
+      case 61:
+        jj_consume_token(61);
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case IRI_REF:
+        case PNAME_NS:
+        case QNAME:
+        case BNODE_LABEL:
+        case VAR1:
+        case VAR2:
+        case INTEGER:
+        case DECIMAL:
+        case DOUBLE:
+        case STRING_LITERAL1:
+        case STRING_LITERAL2:
+        case STRING_LITERAL_LONG1:
+        case STRING_LITERAL_LONG2:
+        case ANON:
+        case 61:
+        case 68:
+        case 69:
+        case 79:
+        case 80:
+        case 81:
+        case 82:
+        case 83:
+        case 84:
+        case 85:
+        case 86:
+        case 87:
+        case 88:
+        case 89:
+        case 90:
+        case 92:
+        case 93:
           Expression();
+          label_11:
+          while (true) {
+            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+            case 62:
+              ;
+              break;
+            default:
+              jj_la1[35] = jj_gen;
+              break label_11;
+            }
+            jj_consume_token(62);
+            Expression();
+          }
+          break;
+        default:
+          jj_la1[36] = jj_gen;
+          ;
         }
+        jj_consume_token(63);
         break;
       default:
-        jj_la1[36] = jj_gen;
-        ;
+        jj_la1[37] = jj_gen;
+        jj_consume_token(-1);
+        throw new ParseException();
       }
-      jj_consume_token(63);
     } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
@@ -1361,16 +1280,9 @@
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
     try {
+      jj_consume_token(54);
+      ConstructTriples();
       jj_consume_token(55);
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 42:
-        jj_consume_token(42);
-        break;
-      default:
-        jj_la1[37] = jj_gen;
-        ConstructTriples();
-      }
-      jj_consume_token(56);
     } catch (Throwable jjte000) {
           if (jjtc000) {
             jjtree.clearNodeScope(jjtn000);
@@ -1394,8 +1306,8 @@
 
   final public void ConstructTriples() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case Q_IRI_REF:
-    case QNAME_NS:
+    case IRI_REF:
+    case PNAME_NS:
     case QNAME:
     case BNODE_LABEL:
     case VAR1:
@@ -1409,27 +1321,16 @@
     case STRING_LITERAL_LONG2:
     case NIL:
     case ANON:
+    case 61:
     case 66:
     case 68:
     case 69:
-    case 70:
-    case 71:
-    case 82:
-    case 83:
-    case 84:
-    case 85:
-    case 86:
-    case 87:
-    case 88:
-    case 89:
-    case 90:
-    case 91:
+    case 92:
     case 93:
-    case 94:
       TriplesSameSubject();
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 57:
-        jj_consume_token(57);
+      case 56:
+        jj_consume_token(56);
         ConstructTriples();
         break;
       default:
@@ -1444,89 +1345,95 @@
   }
 
   final public void TriplesSameSubject() throws ParseException {
-    if (jj_2_1(3)) {
-                                                                                   ASTTripleSet jjtn002 = new ASTTripleSet(JJTTRIPLESET);
-                                                                                   boolean jjtc002 = true;
-                                                                                   jjtree.openNodeScope(jjtn002);
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case IRI_REF:
+    case PNAME_NS:
+    case QNAME:
+    case BNODE_LABEL:
+    case VAR1:
+    case VAR2:
+    case INTEGER:
+    case DECIMAL:
+    case DOUBLE:
+    case STRING_LITERAL1:
+    case STRING_LITERAL2:
+    case STRING_LITERAL_LONG1:
+    case STRING_LITERAL_LONG2:
+    case NIL:
+    case ANON:
+    case 68:
+    case 69:
+    case 92:
+    case 93:
+          ASTTripleSet jjtn002 = new ASTTripleSet(JJTTRIPLESET);
+          boolean jjtc002 = true;
+          jjtree.openNodeScope(jjtn002);
       try {
         VarOrTerm();
-                                                                                                 ASTPropertyList jjtn001 = new ASTPropertyList(JJTPROPERTYLIST);
-                                                                                                 boolean jjtc001 = true;
-                                                                                                 jjtree.openNodeScope(jjtn001);
+                       ASTPropertyList jjtn001 = new ASTPropertyList(JJTPROPERTYLIST);
+                       boolean jjtc001 = true;
+                       jjtree.openNodeScope(jjtn001);
         try {
           PropertyListNotEmpty();
         } catch (Throwable jjte001) {
-                                                                                                 if (jjtc001) {
-                                                                                                   jjtree.clearNodeScope(jjtn001);
-                                                                                                   jjtc001 = false;
-                                                                                                 } else {
-                                                                                                   jjtree.popNode();
-                                                                                                 }
-                                                                                                 if (jjte001 instanceof RuntimeException) {
-                                                                                                   {if (true) throw (RuntimeException)jjte001;}
-                                                                                                 }
-                                                                                                 if (jjte001 instanceof ParseException) {
-                                                                                                   {if (true) throw (ParseException)jjte001;}
-                                                                                                 }
-                                                                                                 {if (true) throw (Error)jjte001;}
+                       if (jjtc001) {
+                         jjtree.clearNodeScope(jjtn001);
+                         jjtc001 = false;
+                       } else {
+                         jjtree.popNode();
+                       }
+                       if (jjte001 instanceof RuntimeException) {
+                         {if (true) throw (RuntimeException)jjte001;}
+                       }
+                       if (jjte001 instanceof ParseException) {
+                         {if (true) throw (ParseException)jjte001;}
+                       }
+                       {if (true) throw (Error)jjte001;}
         } finally {
-                                                                                                 if (jjtc001) {
-                                                                                                   jjtree.closeNodeScope(jjtn001, true);
-                                                                                                 }
+                       if (jjtc001) {
+                         jjtree.closeNodeScope(jjtn001, true);
+                       }
         }
       } catch (Throwable jjte002) {
-                                                                                   if (jjtc002) {
-                                                                                     jjtree.clearNodeScope(jjtn002);
-                                                                                     jjtc002 = false;
-                                                                                   } else {
-                                                                                     jjtree.popNode();
-                                                                                   }
-                                                                                   if (jjte002 instanceof RuntimeException) {
-                                                                                     {if (true) throw (RuntimeException)jjte002;}
-                                                                                   }
-                                                                                   if (jjte002 instanceof ParseException) {
-                                                                                     {if (true) throw (ParseException)jjte002;}
-                                                                                   }
-                                                                                   {if (true) throw (Error)jjte002;}
+          if (jjtc002) {
+            jjtree.clearNodeScope(jjtn002);
+            jjtc002 = false;
+          } else {
+            jjtree.popNode();
+          }
+          if (jjte002 instanceof RuntimeException) {
+            {if (true) throw (RuntimeException)jjte002;}
+          }
+          if (jjte002 instanceof ParseException) {
+            {if (true) throw (ParseException)jjte002;}
+          }
+          {if (true) throw (Error)jjte002;}
       } finally {
-                                                                                   if (jjtc002) {
-                                                                                     jjtree.closeNodeScope(jjtn002, true);
-                                                                                   }
+          if (jjtc002) {
+            jjtree.closeNodeScope(jjtn002, true);
+          }
       }
-    } else {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 66:
-      case 68:
-      case 69:
+      break;
+    case 61:
+    case 66:
                     ASTNodeSet jjtn004 = new ASTNodeSet(JJTNODESET);
                     boolean jjtc004 = true;
                     jjtree.openNodeScope(jjtn004);
-        try {
-          TriplesNode();
-          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-          case Q_IRI_REF:
-          case QNAME_NS:
-          case QNAME:
-          case VAR1:
-          case VAR2:
-          case 65:
-          case 68:
-          case 82:
-          case 83:
-          case 84:
-          case 85:
-          case 86:
-          case 87:
-          case 88:
-          case 89:
-          case 90:
-          case 91:
+      try {
+        TriplesNode();
+        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+        case IRI_REF:
+        case PNAME_NS:
+        case QNAME:
+        case VAR1:
+        case VAR2:
+        case 65:
                                     ASTPropertyList jjtn003 = new ASTPropertyList(JJTPROPERTYLIST);
                                     boolean jjtc003 = true;
                                     jjtree.openNodeScope(jjtn003);
-            try {
-              PropertyListNotEmpty();
-            } catch (Throwable jjte003) {
+          try {
+            PropertyListNotEmpty();
+          } catch (Throwable jjte003) {
                                     if (jjtc003) {
                                       jjtree.clearNodeScope(jjtn003);
                                       jjtc003 = false;
@@ -1540,17 +1447,17 @@
                                       {if (true) throw (ParseException)jjte003;}
                                     }
                                     {if (true) throw (Error)jjte003;}
-            } finally {
+          } finally {
                                     if (jjtc003) {
                                       jjtree.closeNodeScope(jjtn003, true);
                                     }
-            }
-            break;
-          default:
-            jj_la1[40] = jj_gen;
-            ;
           }
-        } catch (Throwable jjte004) {
+          break;
+        default:
+          jj_la1[40] = jj_gen;
+          ;
+        }
+      } catch (Throwable jjte004) {
                     if (jjtc004) {
                       jjtree.clearNodeScope(jjtn004);
                       jjtc004 = false;
@@ -1564,39 +1471,27 @@
                       {if (true) throw (ParseException)jjte004;}
                     }
                     {if (true) throw (Error)jjte004;}
-        } finally {
+      } finally {
                     if (jjtc004) {
                       jjtree.closeNodeScope(jjtn004, true);
                     }
-        }
-        break;
-      default:
-        jj_la1[41] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
       }
+      break;
+    default:
+      jj_la1[41] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
     }
   }
 
   final public void PropertyList() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case Q_IRI_REF:
-    case QNAME_NS:
+    case IRI_REF:
+    case PNAME_NS:
     case QNAME:
     case VAR1:
     case VAR2:
     case 65:
-    case 68:
-    case 82:
-    case 83:
-    case 84:
-    case 85:
-    case 86:
-    case 87:
-    case 88:
-    case 89:
-    case 90:
-    case 91:
       PropertyListNotEmpty();
       break;
     default:
@@ -1680,22 +1575,11 @@
 
   final public void Verb() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case Q_IRI_REF:
-    case QNAME_NS:
+    case IRI_REF:
+    case PNAME_NS:
     case QNAME:
     case VAR1:
     case VAR2:
-    case 68:
-    case 82:
-    case 83:
-    case 84:
-    case 85:
-    case 86:
-    case 87:
-    case 88:
-    case 89:
-    case 90:
-    case 91:
       VarOrIRIref();
       break;
     case 65:
@@ -1719,15 +1603,12 @@
 
   final public void TriplesNode() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case 68:
+    case 61:
       Collection();
       break;
     case 66:
       BlankNodePropertyList();
       break;
-    case 69:
-      WithExtension();
-      break;
     default:
       jj_la1[46] = jj_gen;
       jj_consume_token(-1);
@@ -1794,13 +1675,13 @@
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
     try {
-      jj_consume_token(68);
+      jj_consume_token(61);
       label_12:
       while (true) {
         GraphNode();
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case Q_IRI_REF:
-        case QNAME_NS:
+        case IRI_REF:
+        case PNAME_NS:
         case QNAME:
         case BNODE_LABEL:
         case VAR1:
@@ -1814,23 +1695,12 @@
         case STRING_LITERAL_LONG2:
         case NIL:
         case ANON:
+        case 61:
         case 66:
         case 68:
         case 69:
-        case 70:
-        case 71:
-        case 82:
-        case 83:
-        case 84:
-        case 85:
-        case 86:
-        case 87:
-        case 88:
-        case 89:
-        case 90:
-        case 91:
+        case 92:
         case 93:
-        case 94:
           ;
           break;
         default:
@@ -1860,50 +1730,37 @@
     }
   }
 
-  final public void WithExtension() throws ParseException {
- /*@bgen(jjtree) WithExtension */
-  ASTWithExtension jjtn000 = new ASTWithExtension(JJTWITHEXTENSION);
-  boolean jjtc000 = true;
-  jjtree.openNodeScope(jjtn000);
-    try {
-      jj_consume_token(69);
-      FunctionCall();
-    } catch (Throwable jjte000) {
-          if (jjtc000) {
-            jjtree.clearNodeScope(jjtn000);
-            jjtc000 = false;
-          } else {
-            jjtree.popNode();
-          }
-          if (jjte000 instanceof RuntimeException) {
-            {if (true) throw (RuntimeException)jjte000;}
-          }
-          if (jjte000 instanceof ParseException) {
-            {if (true) throw (ParseException)jjte000;}
-          }
-          {if (true) throw (Error)jjte000;}
-    } finally {
-          if (jjtc000) {
-            jjtree.closeNodeScope(jjtn000, true);
-          }
-    }
-  }
-
   final public void GraphNode() throws ParseException {
-    if (jj_2_2(3)) {
+    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case IRI_REF:
+    case PNAME_NS:
+    case QNAME:
+    case BNODE_LABEL:
+    case VAR1:
+    case VAR2:
+    case INTEGER:
+    case DECIMAL:
+    case DOUBLE:
+    case STRING_LITERAL1:
+    case STRING_LITERAL2:
+    case STRING_LITERAL_LONG1:
+    case STRING_LITERAL_LONG2:
+    case NIL:
+    case ANON:
+    case 68:
+    case 69:
+    case 92:
+    case 93:
       VarOrTerm();
-    } else {
-      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 66:
-      case 68:
-      case 69:
-        TriplesNode();
-        break;
-      default:
-        jj_la1[48] = jj_gen;
-        jj_consume_token(-1);
-        throw new ParseException();
-      }
+      break;
+    case 61:
+    case 66:
+      TriplesNode();
+      break;
+    default:
+      jj_la1[48] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
     }
   }
 
@@ -1913,62 +1770,29 @@
     case VAR2:
       Var();
       break;
+    case IRI_REF:
+    case PNAME_NS:
+    case QNAME:
+    case BNODE_LABEL:
+    case INTEGER:
+    case DECIMAL:
+    case DOUBLE:
+    case STRING_LITERAL1:
+    case STRING_LITERAL2:
+    case STRING_LITERAL_LONG1:
+    case STRING_LITERAL_LONG2:
+    case NIL:
+    case ANON:
+    case 68:
+    case 69:
+    case 92:
+    case 93:
+      GraphTerm();
+      break;
     default:
-      jj_la1[50] = jj_gen;
-      if (jj_2_3(2)) {
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case 68:
-          BracketedExpression();
-          break;
-        case 82:
-        case 83:
-        case 84:
-        case 85:
-        case 86:
-        case 87:
-        case 88:
-        case 89:
-        case 90:
-        case 91:
-          BuiltInCall();
-          break;
-        case Q_IRI_REF:
-        case QNAME_NS:
-        case QNAME:
-          FunctionCall();
-          break;
-        default:
-          jj_la1[49] = jj_gen;
-          jj_consume_token(-1);
-          throw new ParseException();
-        }
-      } else {
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case Q_IRI_REF:
-        case QNAME_NS:
-        case QNAME:
-        case BNODE_LABEL:
-        case INTEGER:
-        case DECIMAL:
-        case DOUBLE:
-        case STRING_LITERAL1:
-        case STRING_LITERAL2:
-        case STRING_LITERAL_LONG1:
-        case STRING_LITERAL_LONG2:
-        case NIL:
-        case ANON:
-        case 70:
-        case 71:
-        case 93:
-        case 94:
-          GraphTerm();
-          break;
-        default:
-          jj_la1[51] = jj_gen;
-          jj_consume_token(-1);
-          throw new ParseException();
-        }
-      }
+      jj_la1[49] = jj_gen;
+      jj_consume_token(-1);
+      throw new ParseException();
     }
   }
 
@@ -1978,68 +1802,13 @@
     case VAR2:
       Var();
       break;
+    case IRI_REF:
+    case PNAME_NS:
+    case QNAME:
+      IRIref();
+      break;
     default:
-      jj_la1[53] = jj_gen;
-      if (jj_2_4(2)) {
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case 68:
-          BracketedExpression();
-          break;
-        case 82:
-        case 83:
-        case 84:
-        case 85:
-        case 86:
-        case 87:
-        case 88:
-        case 89:
-        case 90:
-        case 91:
-          BuiltInCall();
-          break;
-        case Q_IRI_REF:
-        case QNAME_NS:
-        case QNAME:
-          FunctionCall();
-          break;
-        default:
-          jj_la1[52] = jj_gen;
-          jj_consume_token(-1);
-          throw new ParseException();
-        }
-      } else {
-        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-        case Q_IRI_REF:
-        case QNAME_NS:
-        case QNAME:
-          IRIref();
-          break;
-        default:
-          jj_la1[54] = jj_gen;
-          jj_consume_token(-1);
-          throw new ParseException();
-        }
-      }
-    }
-  }
-
-  final public void VarOrBlankNodeOrIRIref() throws ParseException {
-    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case VAR1:
-    case VAR2:
-      Var();
-      break;
-    case BNODE_LABEL:
-    case ANON:
-      BlankNode();
-      break;
-    case Q_IRI_REF:
-    case QNAME_NS:
-    case QNAME:
-      IRIref();
-      break;
-    default:
-      jj_la1[55] = jj_gen;
+      jj_la1[50] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2059,7 +1828,7 @@
         varName = jj_consume_token(VAR2);
         break;
       default:
-        jj_la1[56] = jj_gen;
+        jj_la1[51] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -2075,8 +1844,8 @@
 
   final public void GraphTerm() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case Q_IRI_REF:
-    case QNAME_NS:
+    case IRI_REF:
+    case PNAME_NS:
     case QNAME:
       IRIref();
       break;
@@ -2091,16 +1860,16 @@
     case DOUBLE:
       PositiveLiteral();
       break;
-    case 70:
-      jj_consume_token(70);
+    case 68:
+      jj_consume_token(68);
       PositiveLiteral();
       break;
-    case 71:
-      jj_consume_token(71);
+    case 69:
+      jj_consume_token(69);
       NegativeLiteral();
       break;
+    case 92:
     case 93:
-    case 94:
       BooleanLiteral();
       break;
     case BNODE_LABEL:
@@ -2120,7 +1889,7 @@
       }
       break;
     default:
-      jj_la1[57] = jj_gen;
+      jj_la1[52] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2135,14 +1904,14 @@
     label_13:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 72:
+      case 70:
         ;
         break;
       default:
-        jj_la1[58] = jj_gen;
+        jj_la1[53] = jj_gen;
         break label_13;
       }
-      jj_consume_token(72);
+      jj_consume_token(70);
                                              ASTOrNode jjtn001 = new ASTOrNode(JJTORNODE);
                                              boolean jjtc001 = true;
                                              jjtree.openNodeScope(jjtn001);
@@ -2175,14 +1944,14 @@
     label_14:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 73:
+      case 71:
         ;
         break;
       default:
-        jj_la1[59] = jj_gen;
+        jj_la1[54] = jj_gen;
         break label_14;
       }
-      jj_consume_token(73);
+      jj_consume_token(71);
                                ASTAndNode jjtn001 = new ASTAndNode(JJTANDNODE);
                                boolean jjtc001 = true;
                                jjtree.openNodeScope(jjtn001);
@@ -2217,15 +1986,15 @@
   final public void RelationalExpression() throws ParseException {
     NumericExpression();
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+    case 72:
+    case 73:
     case 74:
     case 75:
     case 76:
     case 77:
-    case 78:
-    case 79:
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 74:
-        jj_consume_token(74);
+      case 72:
+        jj_consume_token(72);
                         ASTEqualsNode jjtn001 = new ASTEqualsNode(JJTEQUALSNODE);
                         boolean jjtc001 = true;
                         jjtree.openNodeScope(jjtn001);
@@ -2251,8 +2020,8 @@
                         }
         }
         break;
-      case 75:
-        jj_consume_token(75);
+      case 73:
+        jj_consume_token(73);
                                    ASTNotEqualsNode jjtn002 = new ASTNotEqualsNode(JJTNOTEQUALSNODE);
                                    boolean jjtc002 = true;
                                    jjtree.openNodeScope(jjtn002);
@@ -2278,8 +2047,8 @@
                                    }
         }
         break;
-      case 76:
-        jj_consume_token(76);
+      case 74:
+        jj_consume_token(74);
                                   ASTLessThanNode jjtn003 = new ASTLessThanNode(JJTLESSTHANNODE);
                                   boolean jjtc003 = true;
                                   jjtree.openNodeScope(jjtn003);
@@ -2305,8 +2074,8 @@
                                   }
         }
         break;
-      case 77:
-        jj_consume_token(77);
+      case 75:
+        jj_consume_token(75);
                                    ASTLessThanEqualsNode jjtn004 = new ASTLessThanEqualsNode(JJTLESSTHANEQUALSNODE);
                                    boolean jjtc004 = true;
                                    jjtree.openNodeScope(jjtn004);
@@ -2332,8 +2101,8 @@
                                    }
         }
         break;
-      case 78:
-        jj_consume_token(78);
+      case 76:
+        jj_consume_token(76);
                                   ASTGreaterThanNode jjtn005 = new ASTGreaterThanNode(JJTGREATERTHANNODE);
                                   boolean jjtc005 = true;
                                   jjtree.openNodeScope(jjtn005);
@@ -2359,8 +2128,8 @@
                                   }
         }
         break;
-      case 79:
-        jj_consume_token(79);
+      case 77:
+        jj_consume_token(77);
                                    ASTGreaterThanEqualsNode jjtn006 = new ASTGreaterThanEqualsNode(JJTGREATERTHANEQUALSNODE);
                                    boolean jjtc006 = true;
                                    jjtree.openNodeScope(jjtn006);
@@ -2387,13 +2156,13 @@
         }
         break;
       default:
-        jj_la1[60] = jj_gen;
+        jj_la1[55] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
       break;
     default:
-      jj_la1[61] = jj_gen;
+      jj_la1[56] = jj_gen;
       ;
     }
   }
@@ -2407,17 +2176,17 @@
     label_15:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 70:
-      case 71:
+      case 68:
+      case 69:
         ;
         break;
       default:
-        jj_la1[62] = jj_gen;
+        jj_la1[57] = jj_gen;
         break label_15;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 70:
-        jj_consume_token(70);
+      case 68:
+        jj_consume_token(68);
                   ASTAdditionNode jjtn001 = new ASTAdditionNode(JJTADDITIONNODE);
                   boolean jjtc001 = true;
                   jjtree.openNodeScope(jjtn001);
@@ -2443,8 +2212,8 @@
                   }
         }
         break;
-      case 71:
-        jj_consume_token(71);
+      case 69:
+        jj_consume_token(69);
                           ASTSubtractionNode jjtn002 = new ASTSubtractionNode(JJTSUBTRACTIONNODE);
                           boolean jjtc002 = true;
                           jjtree.openNodeScope(jjtn002);
@@ -2471,7 +2240,7 @@
         }
         break;
       default:
-        jj_la1[63] = jj_gen;
+        jj_la1[58] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -2483,17 +2252,17 @@
     label_16:
     while (true) {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 42:
-      case 80:
+      case 41:
+      case 78:
         ;
         break;
       default:
-        jj_la1[64] = jj_gen;
+        jj_la1[59] = jj_gen;
         break label_16;
       }
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-      case 42:
-        jj_consume_token(42);
+      case 41:
+        jj_consume_token(41);
                   ASTMultiplicationNode jjtn001 = new ASTMultiplicationNode(JJTMULTIPLICATIONNODE);
                   boolean jjtc001 = true;
                   jjtree.openNodeScope(jjtn001);
@@ -2519,8 +2288,8 @@
                   }
         }
         break;
-      case 80:
-        jj_consume_token(80);
+      case 78:
+        jj_consume_token(78);
                           ASTDivisionNode jjtn002 = new ASTDivisionNode(JJTDIVISIONNODE);
                           boolean jjtc002 = true;
                           jjtree.openNodeScope(jjtn002);
@@ -2547,7 +2316,7 @@
         }
         break;
       default:
-        jj_la1[65] = jj_gen;
+        jj_la1[60] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -2556,8 +2325,8 @@
 
   final public void UnaryExpression() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case 81:
-      jj_consume_token(81);
+    case 79:
+      jj_consume_token(79);
               ASTNotNode jjtn001 = new ASTNotNode(JJTNOTNODE);
               boolean jjtc001 = true;
               jjtree.openNodeScope(jjtn001);
@@ -2583,8 +2352,8 @@
               }
       }
       break;
-    case 70:
-      jj_consume_token(70);
+    case 68:
+      jj_consume_token(68);
                         ASTPlusNode jjtn002 = new ASTPlusNode(JJTPLUSNODE);
                         boolean jjtc002 = true;
                         jjtree.openNodeScope(jjtn002);
@@ -2610,8 +2379,8 @@
                         }
       }
       break;
-    case 71:
-      jj_consume_token(71);
+    case 69:
+      jj_consume_token(69);
                         ASTMinusNode jjtn003 = new ASTMinusNode(JJTMINUSNODE);
                         boolean jjtc003 = true;
                         jjtree.openNodeScope(jjtn003);
@@ -2637,8 +2406,8 @@
                         }
       }
       break;
-    case Q_IRI_REF:
-    case QNAME_NS:
+    case IRI_REF:
+    case PNAME_NS:
     case QNAME:
     case BNODE_LABEL:
     case VAR1:
@@ -2651,7 +2420,9 @@
     case STRING_LITERAL_LONG1:
     case STRING_LITERAL_LONG2:
     case ANON:
-    case 68:
+    case 61:
+    case 80:
+    case 81:
     case 82:
     case 83:
     case 84:
@@ -2661,13 +2432,12 @@
     case 88:
     case 89:
     case 90:
-    case 91:
+    case 92:
     case 93:
-    case 94:
       PrimaryExpression();
       break;
     default:
-      jj_la1[66] = jj_gen;
+      jj_la1[61] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2675,9 +2445,11 @@
 
   final public void PrimaryExpression() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case 68:
+    case 61:
       BracketedExpression();
       break;
+    case 80:
+    case 81:
     case 82:
     case 83:
     case 84:
@@ -2687,11 +2459,10 @@
     case 88:
     case 89:
     case 90:
-    case 91:
       BuiltInCall();
       break;
-    case Q_IRI_REF:
-    case QNAME_NS:
+    case IRI_REF:
+    case PNAME_NS:
     case QNAME:
       IRIrefOrFunction();
       break;
@@ -2706,8 +2477,8 @@
     case DOUBLE:
       PositiveLiteral();
       break;
+    case 92:
     case 93:
-    case 94:
       BooleanLiteral();
       break;
     case BNODE_LABEL:
@@ -2719,23 +2490,23 @@
       Var();
       break;
     default:
-      jj_la1[67] = jj_gen;
+      jj_la1[62] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
   }
 
   final public void BracketedExpression() throws ParseException {
-    jj_consume_token(68);
+    jj_consume_token(61);
     Expression();
     jj_consume_token(63);
   }
 
   final public void BuiltInCall() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case 82:
-      jj_consume_token(82);
-      jj_consume_token(68);
+    case 80:
+      jj_consume_token(80);
+      jj_consume_token(61);
       Expression();
                                  ASTStrFuncNode jjtn001 = new ASTStrFuncNode(JJTSTRFUNCNODE);
                                  boolean jjtc001 = true;
@@ -2748,9 +2519,9 @@
                                  }
       }
       break;
-    case 83:
-      jj_consume_token(83);
-      jj_consume_token(68);
+    case 81:
+      jj_consume_token(81);
+      jj_consume_token(61);
       Expression();
                                             ASTLangFuncNode jjtn002 = new ASTLangFuncNode(JJTLANGFUNCNODE);
                                             boolean jjtc002 = true;
@@ -2763,9 +2534,9 @@
                                             }
       }
       break;
-    case 84:
-      jj_consume_token(84);
-      jj_consume_token(68);
+    case 82:
+      jj_consume_token(82);
+      jj_consume_token(61);
       Expression();
       jj_consume_token(62);
       Expression();
@@ -2780,9 +2551,9 @@
                                                                     }
       }
       break;
-    case 85:
-      jj_consume_token(85);
-      jj_consume_token(68);
+    case 83:
+      jj_consume_token(83);
+      jj_consume_token(61);
       Expression();
                                                 ASTDTFuncNode jjtn004 = new ASTDTFuncNode(JJTDTFUNCNODE);
                                                 boolean jjtc004 = true;
@@ -2795,9 +2566,9 @@
                                                 }
       }
       break;
-    case 86:
-      jj_consume_token(86);
-      jj_consume_token(68);
+    case 84:
+      jj_consume_token(84);
+      jj_consume_token(61);
       Var();
                                       ASTBoundFuncNode jjtn005 = new ASTBoundFuncNode(JJTBOUNDFUNCNODE);
                                       boolean jjtc005 = true;
@@ -2810,9 +2581,17 @@
                                       }
       }
       break;
-    case 87:
-      jj_consume_token(87);
-      jj_consume_token(68);
+    case 85:
+      jj_consume_token(85);
+      jj_consume_token(61);
+      Expression();
+      jj_consume_token(62);
+      Expression();
+      jj_consume_token(63);
+      break;
+    case 86:
+      jj_consume_token(86);
+      jj_consume_token(61);
       Expression();
                                              ASTURIFuncNode jjtn006 = new ASTURIFuncNode(JJTURIFUNCNODE);
                                              boolean jjtc006 = true;
@@ -2825,9 +2604,9 @@
                                              }
       }
       break;
-    case 88:
-      jj_consume_token(88);
-      jj_consume_token(68);
+    case 87:
+      jj_consume_token(87);
+      jj_consume_token(61);
       Expression();
                                              ASTURIFuncNode jjtn007 = new ASTURIFuncNode(JJTURIFUNCNODE);
                                              boolean jjtc007 = true;
@@ -2840,9 +2619,9 @@
                                              }
       }
       break;
-    case 89:
-      jj_consume_token(89);
-      jj_consume_token(68);
+    case 88:
+      jj_consume_token(88);
+      jj_consume_token(61);
       Expression();
                                                ASTBlankFuncNode jjtn008 = new ASTBlankFuncNode(JJTBLANKFUNCNODE);
                                                boolean jjtc008 = true;
@@ -2855,9 +2634,9 @@
                                                }
       }
       break;
-    case 90:
-      jj_consume_token(90);
-      jj_consume_token(68);
+    case 89:
+      jj_consume_token(89);
+      jj_consume_token(61);
       Expression();
                                                  ASTLiteralFuncNode jjtn009 = new ASTLiteralFuncNode(JJTLITERALFUNCNODE);
                                                  boolean jjtc009 = true;
@@ -2870,11 +2649,11 @@
                                                  }
       }
       break;
-    case 91:
+    case 90:
       RegexExpression();
       break;
     default:
-      jj_la1[68] = jj_gen;
+      jj_la1[63] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -2886,8 +2665,8 @@
   boolean jjtc000 = true;
   jjtree.openNodeScope(jjtn000);
     try {
-      jj_consume_token(91);
-      jj_consume_token(68);
+      jj_consume_token(90);
+      jj_consume_token(61);
       Expression();
       jj_consume_token(62);
       Expression();
@@ -2897,7 +2676,7 @@
         Expression();
         break;
       default:
-        jj_la1[69] = jj_gen;
+        jj_la1[64] = jj_gen;
         ;
       }
       jj_consume_token(63);
@@ -2925,7 +2704,8 @@
   final public void IRIrefOrFunction() throws ParseException {
     IRIref();
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case FUNCTION_PAREN:
+    case NIL:
+    case 61:
                     ASTFunctionCall jjtn001 = new ASTFunctionCall(JJTFUNCTIONCALL);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
@@ -2952,7 +2732,7 @@
       }
       break;
     default:
-      jj_la1[70] = jj_gen;
+      jj_la1[65] = jj_gen;
       ;
     }
   }
@@ -2982,7 +2762,7 @@
                                                  literal = label.image.substring(3, label.image.length() - 3);
         break;
       default:
-        jj_la1[71] = jj_gen;
+        jj_la1[66] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -2990,24 +2770,24 @@
                                         jjtn000.setLabel(SPARQLParser.unescape(literal));
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
       case LANGTAG:
-      case 92:
+      case 91:
         switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
         case LANGTAG:
           language = jj_consume_token(LANGTAG);
                                        jjtn000.setLanguage(language.image.substring(1));
           break;
-        case 92:
-          jj_consume_token(92);
+        case 91:
+          jj_consume_token(91);
           IRIref();
           break;
         default:
-          jj_la1[72] = jj_gen;
+          jj_la1[67] = jj_gen;
           jj_consume_token(-1);
           throw new ParseException();
         }
         break;
       default:
-        jj_la1[73] = jj_gen;
+        jj_la1[68] = jj_gen;
         ;
       }
     } catch (Throwable jjte000) {
@@ -3051,7 +2831,7 @@
                   jjtn000.setDatatype("http://www.w3.org/2001/XMLSchema#double");
         break;
       default:
-        jj_la1[74] = jj_gen;
+        jj_la1[69] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -3085,7 +2865,7 @@
                   jjtn000.setDatatype("http://www.w3.org/2001/XMLSchema#double");
         break;
       default:
-        jj_la1[75] = jj_gen;
+        jj_la1[70] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -3106,14 +2886,14 @@
 jjtree.openNodeScope(jjtn000);Token bool;
     try {
       switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
+      case 92:
+        bool = jj_consume_token(92);
+        break;
       case 93:
         bool = jj_consume_token(93);
         break;
-      case 94:
-        bool = jj_consume_token(94);
-        break;
       default:
-        jj_la1[76] = jj_gen;
+        jj_la1[71] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -3130,15 +2910,15 @@
 
   final public void IRIref() throws ParseException {
     switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
-    case Q_IRI_REF:
+    case IRI_REF:
       QuotedIRIref();
       break;
-    case QNAME_NS:
+    case PNAME_NS:
     case QNAME:
       QName();
       break;
     default:
-      jj_la1[77] = jj_gen;
+      jj_la1[72] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -3154,11 +2934,11 @@
       case QNAME:
         qName = jj_consume_token(QNAME);
         break;
-      case QNAME_NS:
-        qName = jj_consume_token(QNAME_NS);
+      case PNAME_NS:
+        qName = jj_consume_token(PNAME_NS);
         break;
       default:
-        jj_la1[78] = jj_gen;
+        jj_la1[73] = jj_gen;
         jj_consume_token(-1);
         throw new ParseException();
       }
@@ -3204,7 +2984,7 @@
       }
       break;
     default:
-      jj_la1[79] = jj_gen;
+      jj_la1[74] = jj_gen;
       jj_consume_token(-1);
       throw new ParseException();
     }
@@ -3216,7 +2996,7 @@
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);Token qRef;
     try {
-      qRef = jj_consume_token(Q_IRI_REF);
+      qRef = jj_consume_token(IRI_REF);
           jjtree.closeNodeScope(jjtn000, true);
           jjtc000 = false;
           jjtn000.setQRef(qRef.image.substring(1, qRef.image.length() - 1));
@@ -3227,1007 +3007,89 @@
     }
   }
 
-  final private boolean jj_2_1(int xla) {
-    jj_la = xla; jj_lastpos = jj_scanpos = token;
-    try { return !jj_3_1(); }
-    catch(LookaheadSuccess ls) { return true; }
-    finally { jj_save(0, xla); }
-  }
-
-  final private boolean jj_2_2(int xla) {
-    jj_la = xla; jj_lastpos = jj_scanpos = token;
-    try { return !jj_3_2(); }
-    catch(LookaheadSuccess ls) { return true; }
-    finally { jj_save(1, xla); }
-  }
-
-  final private boolean jj_2_3(int xla) {
-    jj_la = xla; jj_lastpos = jj_scanpos = token;
-    try { return !jj_3_3(); }
-    catch(LookaheadSuccess ls) { return true; }
-    finally { jj_save(2, xla); }
-  }
-
-  final private boolean jj_2_4(int xla) {
-    jj_la = xla; jj_lastpos = jj_scanpos = token;
-    try { return !jj_3_4(); }
-    catch(LookaheadSuccess ls) { return true; }
-    finally { jj_save(3, xla); }
-  }
+  public SPARQLParserTokenManager token_source;
+  JavaCharStream jj_input_stream;
+  public Token token, jj_nt;
+  private int jj_ntk;
+  private int jj_gen;
+  final private int[] jj_la1 = new int[75];
+  static private int[] jj_la1_0;
+  static private int[] jj_la1_1;
+  static private int[] jj_la1_2;
+  static {
+      jj_la1_0();
+      jj_la1_1();
+      jj_la1_2();
+   }
+   private static void jj_la1_0() {
+      jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x0,0x6000,0x6000,0x0,0x0,0x6e00,0x6e00,0x0,0x0,0x0,0xe00,0x0,0x0,0x0,0x0,0x0,0x0,0x6e00,0x0,0x6e00,0x6e00,0x0,0x0,0x1ff7e00,0x0,0x0,0x0,0x1ff7e00,0x0,0x0,0xe00,0x0,0x17f7e00,0x800000,0x0,0x1ff7e00,0x6e00,0x1ff7e00,0x6e00,0x0,0x0,0x6e00,0x0,0x1ff7e00,0x1ff7e00,0x1ff7e00,0x6e00,0x6000,0x1ff1e00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x17f7e00,0x17f7e00,0x0,0x0,0x800000,0x780000,0x8000,0x8000,0x70000,0x70000,0x0,0xe00,0xc00,0x1001000,};
+   }
+   private static void jj_la1_1() {
+      jj_la1_1 = new int[] {0x1c40,0x10,0x20,0x180,0x180,0x0,0x200,0x2000,0x2000,0x0,0x200,0x2000,0x408000,0x2000,0x4000,0x8000,0x10000,0x300000,0x200000,0x100000,0x300000,0x200c0000,0xc0000,0x20000000,0x200c0000,0x1000000,0x6400000,0x20000000,0x1000000,0x10000000,0x1000000,0x20000000,0x6400000,0x8000000,0x20000000,0x40000000,0x20000000,0x20000000,0x1000000,0x20000000,0x0,0x20000000,0x0,0x0,0x40000000,0x0,0x20000000,0x20000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x200,0x20000000,0x20000000,0x0,0x40000000,0x20000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
+   }
+   private static void jj_la1_2() {
+      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x30000034,0x0,0x0,0x0,0x30000034,0x0,0x0,0x7ff0000,0x0,0x37ff8030,0x0,0x0,0x30000034,0x2,0x30000034,0x2,0x1,0x0,0x2,0x4,0x30000034,0x30000034,0x30000030,0x0,0x0,0x30000030,0x40,0x80,0x3f00,0x3f00,0x30,0x30,0x4000,0x4000,0x37ff8030,0x37ff0000,0x7ff0000,0x0,0x0,0x0,0x8000000,0x8000000,0x0,0x0,0x30000000,0x0,0x0,0x0,};
+   }
 
-  final private boolean jj_3R_128() {
-    if (jj_3R_67()) return true;
-    return false;
+  public SPARQLParser(java.io.InputStream stream) {
+     this(stream, null);
   }
-
-  final private boolean jj_3R_127() {
-    if (jj_3R_65()) return true;
-    return false;
+  public SPARQLParser(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source = new SPARQLParserTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 75; i++) jj_la1[i] = -1;
   }
 
-  final private boolean jj_3_1() {
-    if (jj_3R_17()) return true;
-    if (jj_3R_18()) return true;
-    return false;
+  public void ReInit(java.io.InputStream stream) {
+     ReInit(stream, null);
   }
-
-  final private boolean jj_3R_75() {
-    if (jj_3R_37()) return true;
-    return false;
+  public void ReInit(java.io.InputStream stream, String encoding) {
+    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jjtree.reset();
+    jj_gen = 0;
+    for (int i = 0; i < 75; i++) jj_la1[i] = -1;
   }
 
-  final private boolean jj_3R_126() {
-    if (jj_3R_64()) return true;
-    return false;
+  public SPARQLParser(java.io.Reader stream) {
+    jj_input_stream = new JavaCharStream(stream, 1, 1);
+    token_source = new SPARQLParserTokenManager(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 75; i++) jj_la1[i] = -1;
   }
 
-  final private boolean jj_3R_29() {
-    if (jj_scan_token(68)) return true;
-    if (jj_3R_37()) return true;
-    if (jj_scan_token(63)) return true;
-    return false;
+  public void ReInit(java.io.Reader stream) {
+    jj_input_stream.ReInit(stream, 1, 1);
+    token_source.ReInit(jj_input_stream);
+    token = new Token();
+    jj_ntk = -1;
+    jjtree.reset();
+    jj_gen = 0;
+    for (int i = 0; i < 75; i++) jj_la1[i] = -1;
   }
 
-  final private boolean jj_3R_125() {
-    if (jj_3R_131()) return true;
-    return false;
+  public SPARQLParser(SPARQLParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jj_gen = 0;
+    for (int i = 0; i < 75; i++) jj_la1[i] = -1;
   }
 
-  final private boolean jj_3R_124() {
-    if (jj_3R_30()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_116() {
-    if (jj_3R_120()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_115() {
-    if (jj_scan_token(71)) return true;
-    if (jj_3R_120()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_114() {
-    if (jj_scan_token(70)) return true;
-    if (jj_3R_120()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_123() {
-    if (jj_3R_29()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_120() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_123()) {
-    jj_scanpos = xsp;
-    if (jj_3R_124()) {
-    jj_scanpos = xsp;
-    if (jj_3R_125()) {
-    jj_scanpos = xsp;
-    if (jj_3R_126()) {
-    jj_scanpos = xsp;
-    if (jj_3R_127()) {
-    jj_scanpos = xsp;
-    if (jj_3R_128()) {
-    jj_scanpos = xsp;
-    if (jj_3R_129()) {
-    jj_scanpos = xsp;
-    if (jj_3R_130()) return true;
-    }
-    }
-    }
-    }
-    }
-    }
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_24() {
-    if (jj_3R_31()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_49() {
-    if (jj_scan_token(FUNCTION_PAREN)) return true;
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_75()) jj_scanpos = xsp;
-    if (jj_scan_token(63)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_122() {
-    if (jj_scan_token(80)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_113() {
-    if (jj_scan_token(81)) return true;
-    if (jj_3R_120()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_111() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_113()) {
-    jj_scanpos = xsp;
-    if (jj_3R_114()) {
-    jj_scanpos = xsp;
-    if (jj_3R_115()) {
-    jj_scanpos = xsp;
-    if (jj_3R_116()) return true;
-    }
-    }
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_31() {
-    if (jj_3R_48()) return true;
-    if (jj_3R_49()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_21() {
-    if (jj_3R_31()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_121() {
-    if (jj_scan_token(42)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_119() {
-    if (jj_scan_token(71)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_117() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_121()) {
-    jj_scanpos = xsp;
-    if (jj_3R_122()) return true;
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_104() {
-    if (jj_3R_111()) return true;
-    Token xsp;
-    while (true) {
-      xsp = jj_scanpos;
-      if (jj_3R_117()) { jj_scanpos = xsp; break; }
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_23() {
-    if (jj_3R_30()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_110() {
-    if (jj_scan_token(79)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_109() {
-    if (jj_scan_token(78)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_118() {
-    if (jj_scan_token(70)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_112() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_118()) {
-    jj_scanpos = xsp;
-    if (jj_3R_119()) return true;
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_108() {
-    if (jj_scan_token(77)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_107() {
-    if (jj_scan_token(76)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_106() {
-    if (jj_scan_token(75)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_20() {
-    if (jj_3R_30()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_102() {
-    if (jj_3R_104()) return true;
-    Token xsp;
-    while (true) {
-      xsp = jj_scanpos;
-      if (jj_3R_112()) { jj_scanpos = xsp; break; }
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_101() {
-    if (jj_3R_102()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_93() {
-    if (jj_scan_token(72)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_105() {
-    if (jj_scan_token(74)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_103() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_105()) {
-    jj_scanpos = xsp;
-    if (jj_3R_106()) {
-    jj_scanpos = xsp;
-    if (jj_3R_107()) {
-    jj_scanpos = xsp;
-    if (jj_3R_108()) {
-    jj_scanpos = xsp;
-    if (jj_3R_109()) {
-    jj_scanpos = xsp;
-    if (jj_3R_110()) return true;
-    }
-    }
-    }
-    }
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_22() {
-    if (jj_3R_29()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_100() {
-    if (jj_scan_token(73)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_73() {
-    if (jj_scan_token(Q_IRI_REF)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_99() {
-    if (jj_3R_101()) return true;
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_103()) jj_scanpos = xsp;
-    return false;
-  }
-
-  final private boolean jj_3R_19() {
-    if (jj_3R_29()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_88() {
-    if (jj_scan_token(ANON)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_92() {
-    if (jj_3R_99()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_87() {
-    if (jj_scan_token(BNODE_LABEL)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_68() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_87()) {
-    jj_scanpos = xsp;
-    if (jj_3R_88()) return true;
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_63() {
-    if (jj_3R_74()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_72() {
-    if (jj_3R_92()) return true;
-    Token xsp;
-    while (true) {
-      xsp = jj_scanpos;
-      if (jj_3R_100()) { jj_scanpos = xsp; break; }
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_74() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_scan_token(13)) {
-    jj_scanpos = xsp;
-    if (jj_scan_token(12)) return true;
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_60() {
-    if (jj_3R_72()) return true;
-    Token xsp;
-    while (true) {
-      xsp = jj_scanpos;
-      if (jj_3R_93()) { jj_scanpos = xsp; break; }
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_57() {
-    if (jj_scan_token(NIL)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_56() {
-    if (jj_3R_68()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_55() {
-    if (jj_3R_67()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_54() {
-    if (jj_scan_token(71)) return true;
-    if (jj_3R_66()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_37() {
-    if (jj_3R_60()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_53() {
-    if (jj_scan_token(70)) return true;
-    if (jj_3R_65()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_48() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_62()) {
-    jj_scanpos = xsp;
-    if (jj_3R_63()) return true;
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_62() {
-    if (jj_3R_73()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_52() {
-    if (jj_3R_65()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_51() {
-    if (jj_3R_64()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_67() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_scan_token(93)) {
-    jj_scanpos = xsp;
-    if (jj_scan_token(94)) return true;
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_33() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_50()) {
-    jj_scanpos = xsp;
-    if (jj_3R_51()) {
-    jj_scanpos = xsp;
-    if (jj_3R_52()) {
-    jj_scanpos = xsp;
-    if (jj_3R_53()) {
-    jj_scanpos = xsp;
-    if (jj_3R_54()) {
-    jj_scanpos = xsp;
-    if (jj_3R_55()) {
-    jj_scanpos = xsp;
-    if (jj_3R_56()) {
-    jj_scanpos = xsp;
-    if (jj_3R_57()) return true;
-    }
-    }
-    }
-    }
-    }
-    }
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_50() {
-    if (jj_3R_48()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_83() {
-    if (jj_scan_token(DOUBLE)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_82() {
-    if (jj_scan_token(DECIMAL)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_81() {
-    if (jj_scan_token(INTEGER)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_32() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_scan_token(15)) {
-    jj_scanpos = xsp;
-    if (jj_scan_token(16)) return true;
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_70() {
-    if (jj_3R_48()) return true;
-    return false;
-  }
-
-  final private boolean jj_3_4() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_22()) {
-    jj_scanpos = xsp;
-    if (jj_3R_23()) {
-    jj_scanpos = xsp;
-    if (jj_3R_24()) return true;
-    }
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_65() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_81()) {
-    jj_scanpos = xsp;
-    if (jj_3R_82()) {
-    jj_scanpos = xsp;
-    if (jj_3R_83()) return true;
-    }
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_86() {
-    if (jj_scan_token(DOUBLE)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_26() {
-    if (jj_3R_33()) return true;
-    return false;
-  }
-
-  final private boolean jj_3_3() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_19()) {
-    jj_scanpos = xsp;
-    if (jj_3R_20()) {
-    jj_scanpos = xsp;
-    if (jj_3R_21()) return true;
-    }
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_91() {
-    if (jj_3R_98()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_85() {
-    if (jj_scan_token(DECIMAL)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_58() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_69()) {
-    jj_scanpos = xsp;
-    if (jj_3_4()) {
-    jj_scanpos = xsp;
-    if (jj_3R_70()) return true;
-    }
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_69() {
-    if (jj_3R_32()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_84() {
-    if (jj_scan_token(INTEGER)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_59() {
-    if (jj_3R_71()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_17() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_25()) {
-    jj_scanpos = xsp;
-    if (jj_3_3()) {
-    jj_scanpos = xsp;
-    if (jj_3R_26()) return true;
-    }
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_25() {
-    if (jj_3R_32()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_66() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_84()) {
-    jj_scanpos = xsp;
-    if (jj_3R_85()) {
-    jj_scanpos = xsp;
-    if (jj_3R_86()) return true;
-    }
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_95() {
-    if (jj_scan_token(92)) return true;
-    if (jj_3R_48()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_94() {
-    if (jj_scan_token(LANGTAG)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_80() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_94()) {
-    jj_scanpos = xsp;
-    if (jj_3R_95()) return true;
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_36() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3_2()) {
-    jj_scanpos = xsp;
-    if (jj_3R_59()) return true;
-    }
-    return false;
-  }
-
-  final private boolean jj_3_2() {
-    if (jj_3R_17()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_79() {
-    if (jj_scan_token(STRING_LITERAL_LONG2)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_98() {
-    if (jj_scan_token(69)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_78() {
-    if (jj_scan_token(STRING_LITERAL_LONG1)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_90() {
-    if (jj_3R_97()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_77() {
-    if (jj_scan_token(STRING_LITERAL2)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_76() {
-    if (jj_scan_token(STRING_LITERAL1)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_96() {
-    if (jj_scan_token(68)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_35() {
-    if (jj_scan_token(65)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_132() {
-    if (jj_3R_49()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_97() {
-    if (jj_scan_token(66)) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_64() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_76()) {
-    jj_scanpos = xsp;
-    if (jj_3R_77()) {
-    jj_scanpos = xsp;
-    if (jj_3R_78()) {
-    jj_scanpos = xsp;
-    if (jj_3R_79()) return true;
-    }
-    }
-    }
-    xsp = jj_scanpos;
-    if (jj_3R_80()) jj_scanpos = xsp;
-    return false;
-  }
-
-  final private boolean jj_3R_89() {
-    if (jj_3R_96()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_71() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_89()) {
-    jj_scanpos = xsp;
-    if (jj_3R_90()) {
-    jj_scanpos = xsp;
-    if (jj_3R_91()) return true;
-    }
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_131() {
-    if (jj_3R_48()) return true;
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_132()) jj_scanpos = xsp;
-    return false;
-  }
-
-  final private boolean jj_3R_34() {
-    if (jj_3R_58()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_27() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_34()) {
-    jj_scanpos = xsp;
-    if (jj_3R_35()) return true;
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_47() {
-    if (jj_3R_61()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_46() {
-    if (jj_scan_token(90)) return true;
-    if (jj_scan_token(68)) return true;
-    if (jj_3R_37()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_45() {
-    if (jj_scan_token(89)) return true;
-    if (jj_scan_token(68)) return true;
-    if (jj_3R_37()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_44() {
-    if (jj_scan_token(88)) return true;
-    if (jj_scan_token(68)) return true;
-    if (jj_3R_37()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_43() {
-    if (jj_scan_token(87)) return true;
-    if (jj_scan_token(68)) return true;
-    if (jj_3R_37()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_61() {
-    if (jj_scan_token(91)) return true;
-    if (jj_scan_token(68)) return true;
-    if (jj_3R_37()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_28() {
-    if (jj_3R_36()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_42() {
-    if (jj_scan_token(86)) return true;
-    if (jj_scan_token(68)) return true;
-    if (jj_3R_32()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_41() {
-    if (jj_scan_token(85)) return true;
-    if (jj_scan_token(68)) return true;
-    if (jj_3R_37()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_40() {
-    if (jj_scan_token(84)) return true;
-    if (jj_scan_token(68)) return true;
-    if (jj_3R_37()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_39() {
-    if (jj_scan_token(83)) return true;
-    if (jj_scan_token(68)) return true;
-    if (jj_3R_37()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_18() {
-    if (jj_3R_27()) return true;
-    if (jj_3R_28()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_38() {
-    if (jj_scan_token(82)) return true;
-    if (jj_scan_token(68)) return true;
-    if (jj_3R_37()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_30() {
-    Token xsp;
-    xsp = jj_scanpos;
-    if (jj_3R_38()) {
-    jj_scanpos = xsp;
-    if (jj_3R_39()) {
-    jj_scanpos = xsp;
-    if (jj_3R_40()) {
-    jj_scanpos = xsp;
-    if (jj_3R_41()) {
-    jj_scanpos = xsp;
-    if (jj_3R_42()) {
-    jj_scanpos = xsp;
-    if (jj_3R_43()) {
-    jj_scanpos = xsp;
-    if (jj_3R_44()) {
-    jj_scanpos = xsp;
-    if (jj_3R_45()) {
-    jj_scanpos = xsp;
-    if (jj_3R_46()) {
-    jj_scanpos = xsp;
-    if (jj_3R_47()) return true;
-    }
-    }
-    }
-    }
-    }
-    }
-    }
-    }
-    }
-    return false;
-  }
-
-  final private boolean jj_3R_130() {
-    if (jj_3R_32()) return true;
-    return false;
-  }
-
-  final private boolean jj_3R_129() {
-    if (jj_3R_68()) return true;
-    return false;
-  }
-
-  public SPARQLParserTokenManager token_source;
-  JavaCharStream jj_input_stream;
-  public Token token, jj_nt;
-  private int jj_ntk;
-  private Token jj_scanpos, jj_lastpos;
-  private int jj_la;
-  public boolean lookingAhead = false;
-  private boolean jj_semLA;
-  private int jj_gen;
-  final private int[] jj_la1 = new int[80];
-  static private int[] jj_la1_0;
-  static private int[] jj_la1_1;
-  static private int[] jj_la1_2;
-  static {
-      jj_la1_0();
-      jj_la1_1();
-      jj_la1_2();
-   }
-   private static void jj_la1_0() {
-      jj_la1_0 = new int[] {0x0,0x0,0x0,0x0,0x3800,0x1b800,0x1b800,0x1b800,0x0,0x0,0x0,0x1b800,0x1b800,0x0,0x0,0x0,0x3800,0x0,0x0,0x0,0x0,0x1b800,0x0,0x1b800,0x1b800,0x0,0x0,0x7fdf800,0x0,0x0,0x0,0x7fdf800,0x0,0x0,0x3800,0x0,0x5fdf800,0x0,0x0,0x7fdf800,0x1b800,0x0,0x1b800,0x0,0x0,0x1b800,0x0,0x7fdf800,0x0,0x3800,0x18000,0x7fc7800,0x3800,0x18000,0x3800,0x401f800,0x18000,0x7fc7800,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x5fdf800,0x5fdf800,0x0,0x0,0x200,0x1e00000,0x20000,0x20000,0x1c0000,0x1c0000,0x0,0x3800,0x3000,0x4004000,};
-   }
-   private static void jj_la1_1() {
-      jj_la1_1 = new int[] {0x3900,0x40,0x80,0x200,0x0,0x0,0x0,0x400,0x4000,0x200,0x4000,0x0,0x400,0x4000,0x810000,0x4000,0x8000,0x10000,0x20000,0x200000,0x400000,0x180000,0x180000,0x0,0x180000,0x2000000,0xc800000,0x0,0x2000000,0x20000000,0x2000000,0x0,0xc800000,0x10000000,0x0,0x40000000,0x0,0x400,0x2000000,0x0,0x0,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0x400,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
-   }
-   private static void jj_la1_2() {
-      jj_la1_2 = new int[] {0x0,0x0,0x0,0x0,0xffc0010,0xffc0010,0xffc0010,0xffc0010,0x0,0x0,0x0,0xffc0010,0xffc0010,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x10,0x10,0x0,0x0,0x6ffc00f4,0x0,0x0,0x0,0x6ffc00f4,0x0,0x0,0xffc0010,0x0,0x6ffe00d0,0x0,0x0,0x6ffc00f4,0xffc0012,0x34,0xffc0012,0x1,0x0,0xffc0012,0x34,0x6ffc00f4,0x34,0xffc0010,0x0,0x600000c0,0xffc0010,0x0,0x0,0x0,0x0,0x600000c0,0x100,0x200,0xfc00,0xfc00,0xc0,0xc0,0x10000,0x10000,0x6ffe00d0,0x6ffc0010,0xffc0000,0x0,0x0,0x0,0x10000000,0x10000000,0x0,0x0,0x60000000,0x0,0x0,0x0,};
-   }
-  final private JJCalls[] jj_2_rtns = new JJCalls[4];
-  private boolean jj_rescan = false;
-  private int jj_gc = 0;
-
-  public SPARQLParser(java.io.InputStream stream) {
-    jj_input_stream = new JavaCharStream(stream, 1, 1);
-    token_source = new SPARQLParserTokenManager(jj_input_stream);
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 80; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  public void ReInit(java.io.InputStream stream) {
-    jj_input_stream.ReInit(stream, 1, 1);
-    token_source.ReInit(jj_input_stream);
-    token = new Token();
-    jj_ntk = -1;
-    jjtree.reset();
-    jj_gen = 0;
-    for (int i = 0; i < 80; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  public SPARQLParser(java.io.Reader stream) {
-    jj_input_stream = new JavaCharStream(stream, 1, 1);
-    token_source = new SPARQLParserTokenManager(jj_input_stream);
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 80; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  public void ReInit(java.io.Reader stream) {
-    jj_input_stream.ReInit(stream, 1, 1);
-    token_source.ReInit(jj_input_stream);
-    token = new Token();
-    jj_ntk = -1;
-    jjtree.reset();
-    jj_gen = 0;
-    for (int i = 0; i < 80; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  public SPARQLParser(SPARQLParserTokenManager tm) {
-    token_source = tm;
-    token = new Token();
-    jj_ntk = -1;
-    jj_gen = 0;
-    for (int i = 0; i < 80; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
-  }
-
-  public void ReInit(SPARQLParserTokenManager tm) {
-    token_source = tm;
-    token = new Token();
-    jj_ntk = -1;
-    jjtree.reset();
-    jj_gen = 0;
-    for (int i = 0; i < 80; i++) jj_la1[i] = -1;
-    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
+  public void ReInit(SPARQLParserTokenManager tm) {
+    token_source = tm;
+    token = new Token();
+    jj_ntk = -1;
+    jjtree.reset();
+    jj_gen = 0;
+    for (int i = 0; i < 75; i++) jj_la1[i] = -1;
   }
 
   final private Token jj_consume_token(int kind) throws ParseException {
@@ -4237,16 +3099,6 @@
     jj_ntk = -1;
     if (token.kind == kind) {
       jj_gen++;
-      if (++jj_gc > 100) {
-        jj_gc = 0;
-        for (int i = 0; i < jj_2_rtns.length; i++) {
-          JJCalls c = jj_2_rtns[i];
-          while (c != null) {
-            if (c.gen < jj_gen) c.first = null;
-            c = c.next;
-          }
-        }
-      }
       return token;
     }
     token = oldToken;
@@ -4254,29 +3106,6 @@
     throw generateParseException();
   }
 
-  static private final class LookaheadSuccess extends java.lang.Error { }
-  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
-  final private boolean jj_scan_token(int kind) {
-    if (jj_scanpos == jj_lastpos) {
-      jj_la--;
-      if (jj_scanpos.next == null) {
-        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
-      } else {
-        jj_lastpos = jj_scanpos = jj_scanpos.next;
-      }
-    } else {
-      jj_scanpos = jj_scanpos.next;
-    }
-    if (jj_rescan) {
-      int i = 0; Token tok = token;
-      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
-      if (tok != null) jj_add_error_token(kind, i);
-    }
-    if (jj_scanpos.kind != kind) return true;
-    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
-    return false;
-  }
-
   final public Token getNextToken() {
     if (token.next != null) token = token.next;
     else token = token.next = token_source.getNextToken();
@@ -4286,7 +3115,7 @@
   }
 
   final public Token getToken(int index) {
-    Token t = lookingAhead ? jj_scanpos : token;
+    Token t = token;
     for (int i = 0; i < index; i++) {
       if (t.next != null) t = t.next;
       else t = t.next = token_source.getNextToken();
@@ -4304,48 +3133,18 @@
   private java.util.Vector jj_expentries = new java.util.Vector();
   private int[] jj_expentry;
   private int jj_kind = -1;
-  private int[] jj_lasttokens = new int[100];
-  private int jj_endpos;
-
-  private void jj_add_error_token(int kind, int pos) {
-    if (pos >= 100) return;
-    if (pos == jj_endpos + 1) {
-      jj_lasttokens[jj_endpos++] = kind;
-    } else if (jj_endpos != 0) {
-      jj_expentry = new int[jj_endpos];
-      for (int i = 0; i < jj_endpos; i++) {
-        jj_expentry[i] = jj_lasttokens[i];
-      }
-      boolean exists = false;
-      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
-        int[] oldentry = (int[])(e.nextElement());
-        if (oldentry.length == jj_expentry.length) {
-          exists = true;
-          for (int i = 0; i < jj_expentry.length; i++) {
-            if (oldentry[i] != jj_expentry[i]) {
-              exists = false;
-              break;
-            }
-          }
-          if (exists) break;
-        }
-      }
-      if (!exists) jj_expentries.addElement(jj_expentry);
-      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
-    }
-  }
 
   public ParseException generateParseException() {
     jj_expentries.removeAllElements();
-    boolean[] la1tokens = new boolean[95];
-    for (int i = 0; i < 95; i++) {
+    boolean[] la1tokens = new boolean[94];
+    for (int i = 0; i < 94; i++) {
       la1tokens[i] = false;
     }
     if (jj_kind >= 0) {
       la1tokens[jj_kind] = true;
       jj_kind = -1;
     }
-    for (int i = 0; i < 80; i++) {
+    for (int i = 0; i < 75; i++) {
       if (jj_la1[i] == jj_gen) {
         for (int j = 0; j < 32; j++) {
           if ((jj_la1_0[i] & (1<<j)) != 0) {
@@ -4360,16 +3159,13 @@
         }
       }
     }
-    for (int i = 0; i < 95; i++) {
+    for (int i = 0; i < 94; i++) {
       if (la1tokens[i]) {
         jj_expentry = new int[1];
         jj_expentry[0] = i;
         jj_expentries.addElement(jj_expentry);
       }
     }
-    jj_endpos = 0;
-    jj_rescan_token();
-    jj_add_error_token(0, 0);
     int[][] exptokseq = new int[jj_expentries.size()][];
     for (int i = 0; i < jj_expentries.size(); i++) {
       exptokseq[i] = (int[])jj_expentries.elementAt(i);
@@ -4383,40 +3179,4 @@
   final public void disable_tracing() {
   }
 
-  final private void jj_rescan_token() {
-    jj_rescan = true;
-    for (int i = 0; i < 4; i++) {
-      JJCalls p = jj_2_rtns[i];
-      do {
-        if (p.gen > jj_gen) {
-          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
-          switch (i) {
-            case 0: jj_3_1(); break;
-            case 1: jj_3_2(); break;
-            case 2: jj_3_3(); break;
-            case 3: jj_3_4(); break;
-          }
-        }
-        p = p.next;
-      } while (p != null);
-    }
-    jj_rescan = false;
-  }
-
-  final private void jj_save(int index, int xla) {
-    JJCalls p = jj_2_rtns[index];
-    while (p.gen > jj_gen) {
-      if (p.next == null) { p = p.next = new JJCalls(); break; }
-      p = p.next;
-    }
-    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
-  }
-
-  static final class JJCalls {
-    int gen;
-    Token first;
-    int arg;
-    JJCalls next;
-  }
-
 }
diff -urN --exclude=.svn --exclude=.settings --exclude=META-INF upstream/src/main/name/levering/ryan/sparql/parser/SPARQLParserTokenManager.java work-copy/src/main/name/levering/ryan/sparql/parser/SPARQLParserTokenManager.java
--- upstream/src/main/name/levering/ryan/sparql/parser/SPARQLParserTokenManager.java	2007-10-07 07:19:57.000000000 -0400
+++ work-copy/src/main/name/levering/ryan/sparql/parser/SPARQLParserTokenManager.java	2007-10-21 12:35:16.000000000 -0400
@@ -7,65 +7,65 @@
 {
   public  java.io.PrintStream debugStream = System.out;
   public  void setDebugStream(java.io.PrintStream ds) { debugStream = ds; }
-private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1)
+private final int jjStopStringLiteralDfa_0(int pos, long active0, long active1)
 {
-   switch (pos)
+   switch (pos)
    {
       case 0:
-         if ((active0 & 0x3c7ffbc000000000L) != 0L || (active1 & 0x6ffc0022L) != 0L)
+         if ((active0 & 0x1e3ffdf000000000L) != 0L || (active1 & 0x37ff0002L) != 0L)
             return 337;
          if ((active1 & 0x4L) != 0L)
             return 338;
-         if ((active1 & 0x10L) != 0L)
+         if ((active0 & 0x2000000000000000L) != 0L)
             return 339;
-         if ((active0 & 0x200000000000000L) != 0L)
+         if ((active0 & 0x100000000000000L) != 0L)
             return 340;
-         if ((active1 & 0x3000L) != 0L)
+         if ((active1 & 0xc00L) != 0L)
             return 341;
          return -1;
       case 1:
-         if ((active0 & 0x3c7ffbc000000000L) != 0L || (active1 & 0x6ffc0020L) != 0L)
+         if ((active0 & 0x1e3ffdf000000000L) != 0L || (active1 & 0x37ff0000L) != 0L)
             return 337;
-         if ((active1 & 0x2000L) != 0L)
+         if ((active1 & 0x800L) != 0L)
             return 341;
          return -1;
       case 2:
-         if ((active0 & 0x3c7bfbc000000000L) != 0L || (active1 & 0x6ffc0020L) != 0L)
+         if ((active0 & 0x1e3dfdf000000000L) != 0L || (active1 & 0x37ff0000L) != 0L)
             return 337;
          return -1;
       case 3:
-         if ((active0 & 0x3c73dbc000000000L) != 0L || (active1 & 0x6ff80020L) != 0L)
+         if ((active0 & 0x1e39edf000000000L) != 0L || (active1 & 0x37fe0000L) != 0L)
             return 337;
          return -1;
       case 4:
-         if ((active0 & 0x3c639b8000000000L) != 0L || (active1 & 0x4ff00000L) != 0L)
+         if ((active0 & 0x1e31cde000000000L) != 0L || (active1 & 0x27fc0000L) != 0L)
             return 337;
          return -1;
       case 5:
-         if ((active0 & 0x24401b8000000000L) != 0L || (active1 & 0x6300000L) != 0L)
+         if ((active0 & 0x12200de000000000L) != 0L || (active1 & 0x32c0000L) != 0L)
             return 337;
          return -1;
       case 6:
-         if ((active0 & 0x4001a0000000000L) != 0L || (active1 & 0x6300000L) != 0L)
+         if ((active0 & 0x2000d8000000000L) != 0L || (active1 & 0x32c0000L) != 0L)
             return 337;
          return -1;
       case 7:
-         if ((active0 & 0x4001a0000000000L) != 0L || (active1 & 0x4300000L) != 0L)
+         if ((active0 & 0x2000c8000000000L) != 0L || (active1 & 0x22c0000L) != 0L)
             return 337;
          return -1;
       case 8:
-         if ((active0 & 0x80000000000L) != 0L || (active1 & 0x4100000L) != 0L)
+         if ((active0 & 0x40000000000L) != 0L || (active1 & 0x2040000L) != 0L)
             return 337;
          return -1;
       case 9:
-         if ((active1 & 0x100000L) != 0L)
+         if ((active1 & 0x40000L) != 0L)
             return 337;
          return -1;
       default :
          return -1;
    }
 }
-private final int jjStartNfa_0(int pos, long active0, long active1)
+private final int jjStartNfa_0(int pos, long active0, long active1)
 {
    return jjMoveNfa_0(jjStopStringLiteralDfa_0(pos, active0, active1), pos + 1);
 }
@@ -88,99 +88,99 @@
    switch(curChar)
    {
       case 33:
-         jjmatchedKind = 81;
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x800L);
+         jjmatchedKind = 79;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x200L);
       case 35:
          return jjStopAtPos(0, 6);
       case 38:
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x200L);
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x80L);
       case 40:
-         return jjStartNfaWithStates_0(0, 68, 339);
+         return jjStartNfaWithStates_0(0, 61, 339);
       case 41:
          return jjStopAtPos(0, 63);
       case 42:
-         return jjStopAtPos(0, 42);
+         return jjStopAtPos(0, 41);
       case 43:
-         return jjStopAtPos(0, 70);
+         return jjStopAtPos(0, 68);
       case 44:
          return jjStopAtPos(0, 62);
       case 45:
-         return jjStopAtPos(0, 71);
+         return jjStopAtPos(0, 69);
       case 46:
-         return jjStartNfaWithStates_0(0, 57, 340);
+         return jjStartNfaWithStates_0(0, 56, 340);
       case 47:
-         return jjStopAtPos(0, 80);
+         return jjStopAtPos(0, 78);
       case 59:
          return jjStopAtPos(0, 64);
       case 60:
-         jjmatchedKind = 76;
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x2000L);
+         jjmatchedKind = 74;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x800L);
       case 61:
-         return jjStopAtPos(0, 74);
+         return jjStopAtPos(0, 72);
       case 62:
-         jjmatchedKind = 78;
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x8000L);
+         jjmatchedKind = 76;
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x2000L);
       case 91:
          return jjStartNfaWithStates_0(0, 66, 338);
       case 93:
          return jjStopAtPos(0, 67);
       case 94:
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x10000000L);
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x8000000L);
       case 65:
       case 97:
          jjmatchedKind = 65;
-         return jjMoveStringLiteralDfa1_0(0x8200000000000L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x4100000000000L, 0x0L);
       case 66:
       case 98:
-         return jjMoveStringLiteralDfa1_0(0x4004000000000L, 0x400000L);
+         return jjMoveStringLiteralDfa1_0(0x2001000000000L, 0x100000L);
       case 67:
       case 99:
-         return jjMoveStringLiteralDfa1_0(0x80000000000L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x40000000000L, 0x0L);
       case 68:
       case 100:
-         return jjMoveStringLiteralDfa1_0(0x10120000000000L, 0x200000L);
+         return jjMoveStringLiteralDfa1_0(0x8088000000000L, 0x80000L);
       case 70:
       case 102:
-         return jjMoveStringLiteralDfa1_0(0x2000400000000000L, 0x40000000L);
+         return jjMoveStringLiteralDfa1_0(0x1000200000000000L, 0x20000000L);
       case 71:
       case 103:
-         return jjMoveStringLiteralDfa1_0(0x800000000000000L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x400000000000000L, 0x0L);
       case 73:
       case 105:
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x7800000L);
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x3c00000L);
       case 76:
       case 108:
-         return jjMoveStringLiteralDfa1_0(0x20000000000000L, 0x180000L);
+         return jjMoveStringLiteralDfa1_0(0x10000000000000L, 0x60000L);
       case 78:
       case 110:
-         return jjMoveStringLiteralDfa1_0(0x800000000000L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x400000000000L, 0x0L);
       case 79:
       case 111:
-         return jjMoveStringLiteralDfa1_0(0x442000000000000L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x221000000000000L, 0x0L);
       case 80:
       case 112:
-         return jjMoveStringLiteralDfa1_0(0x8000000000L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x2000000000L, 0x0L);
       case 82:
       case 114:
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x8000000L);
+         return jjMoveStringLiteralDfa1_0(0x10000000000L, 0x4000000L);
       case 83:
       case 115:
-         return jjMoveStringLiteralDfa1_0(0x10000000000L, 0x40000L);
+         return jjMoveStringLiteralDfa1_0(0x4000000000L, 0x210000L);
       case 84:
       case 116:
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x20000000L);
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x10000000L);
       case 85:
       case 117:
-         return jjMoveStringLiteralDfa1_0(0x1000000000000000L, 0x0L);
+         return jjMoveStringLiteralDfa1_0(0x800000000000000L, 0x0L);
       case 87:
       case 119:
-         return jjMoveStringLiteralDfa1_0(0x1000000000000L, 0x20L);
+         return jjMoveStringLiteralDfa1_0(0x800000000000L, 0x0L);
       case 123:
-         return jjStopAtPos(0, 55);
+         return jjStopAtPos(0, 54);
       case 124:
-         return jjMoveStringLiteralDfa1_0(0x0L, 0x100L);
+         return jjMoveStringLiteralDfa1_0(0x0L, 0x40L);
       case 125:
-         return jjStopAtPos(0, 56);
+         return jjStopAtPos(0, 55);
       default :
          return jjMoveNfa_0(0, 0);
    }
@@ -195,62 +195,62 @@
    switch(curChar)
    {
       case 38:
-         if ((active1 & 0x200L) != 0L)
-            return jjStopAtPos(1, 73);
+         if ((active1 & 0x80L) != 0L)
+            return jjStopAtPos(1, 71);
          break;
       case 61:
-         if ((active1 & 0x800L) != 0L)
-            return jjStopAtPos(1, 75);
+         if ((active1 & 0x200L) != 0L)
+            return jjStopAtPos(1, 73);
+         else if ((active1 & 0x800L) != 0L)
+            return jjStartNfaWithStates_0(1, 75, 341);
          else if ((active1 & 0x2000L) != 0L)
-            return jjStartNfaWithStates_0(1, 77, 341);
-         else if ((active1 & 0x8000L) != 0L)
-            return jjStopAtPos(1, 79);
+            return jjStopAtPos(1, 77);
          break;
       case 94:
-         if ((active1 & 0x10000000L) != 0L)
-            return jjStopAtPos(1, 92);
+         if ((active1 & 0x8000000L) != 0L)
+            return jjStopAtPos(1, 91);
          break;
       case 65:
       case 97:
-         return jjMoveStringLiteralDfa2_0(active0, 0x804000000000L, active1, 0x40380000L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x401000000000L, active1, 0x202e0000L);
       case 69:
       case 101:
-         return jjMoveStringLiteralDfa2_0(active0, 0x10110000000000L, active1, 0x8000000L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x8094000000000L, active1, 0x4000000L);
       case 70:
       case 102:
-         return jjMoveStringLiteralDfa2_0(active0, 0x40000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x20000000000000L, active1, 0L);
       case 72:
       case 104:
-         return jjMoveStringLiteralDfa2_0(active0, 0x1000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x800000000000L, active1, 0L);
       case 73:
       case 105:
-         return jjMoveStringLiteralDfa2_0(active0, 0x2020020000000000L, active1, 0x20L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x1010008000000000L, active1, 0L);
       case 78:
       case 110:
-         return jjMoveStringLiteralDfa2_0(active0, 0x1000000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x800000000000000L, active1, 0L);
       case 79:
       case 111:
-         return jjMoveStringLiteralDfa2_0(active0, 0x80000000000L, active1, 0x400000L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x40000000000L, active1, 0x100000L);
       case 80:
       case 112:
-         return jjMoveStringLiteralDfa2_0(active0, 0x400000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x200000000000000L, active1, 0L);
       case 82:
       case 114:
-         return jjMoveStringLiteralDfa2_0(active0, 0x802408000000000L, active1, 0x20000000L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x401202000000000L, active1, 0x10000000L);
       case 83:
       case 115:
-         return jjMoveStringLiteralDfa2_0(active0, 0x8200000000000L, active1, 0x7800000L);
+         return jjMoveStringLiteralDfa2_0(active0, 0x4100000000000L, active1, 0x3c00000L);
       case 84:
       case 116:
-         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x40000L);
+         return jjMoveStringLiteralDfa2_0(active0, 0L, active1, 0x10000L);
       case 89:
       case 121:
-         if ((active0 & 0x4000000000000L) != 0L)
-            return jjStartNfaWithStates_0(1, 50, 337);
+         if ((active0 & 0x2000000000000L) != 0L)
+            return jjStartNfaWithStates_0(1, 49, 337);
          break;
       case 124:
-         if ((active1 & 0x100L) != 0L)
-            return jjStopAtPos(1, 72);
+         if ((active1 & 0x40L) != 0L)
+            return jjStopAtPos(1, 70);
          break;
       default :
          break;
@@ -270,61 +270,61 @@
    {
       case 65:
       case 97:
-         return jjMoveStringLiteralDfa3_0(active0, 0x800000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0L);
       case 66:
       case 98:
-         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x2000000L);
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x1000000L);
       case 67:
       case 99:
-         if ((active0 & 0x8000000000000L) != 0L)
-            return jjStartNfaWithStates_0(2, 51, 337);
+         if ((active0 & 0x4000000000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 50, 337);
          break;
       case 68:
       case 100:
-         return jjMoveStringLiteralDfa3_0(active0, 0x2000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x1010000000000L, active1, 0L);
       case 69:
       case 101:
-         return jjMoveStringLiteralDfa3_0(active0, 0x1008000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x802000000000L, active1, 0L);
       case 70:
       case 102:
-         return jjMoveStringLiteralDfa3_0(active0, 0x40000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x20000000000000L, active1, 0L);
       case 71:
       case 103:
-         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x8000000L);
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x4000000L);
       case 73:
       case 105:
-         return jjMoveStringLiteralDfa3_0(active0, 0x1000000000000000L, active1, 0x800000L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x800000000000000L, active1, 0x400000L);
       case 75:
       case 107:
-         if ((active0 & 0x200000000000L) != 0L)
-            return jjStartNfaWithStates_0(2, 45, 337);
+         if ((active0 & 0x100000000000L) != 0L)
+            return jjStartNfaWithStates_0(2, 44, 337);
          break;
       case 76:
       case 108:
-         return jjMoveStringLiteralDfa3_0(active0, 0x2000010000000000L, active1, 0x44000000L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x1000004000000000L, active1, 0x22000000L);
       case 77:
       case 109:
-         return jjMoveStringLiteralDfa3_0(active0, 0x20800000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x10400000000000L, active1, 0x200000L);
       case 78:
       case 110:
-         return jjMoveStringLiteralDfa3_0(active0, 0x80000000000L, active1, 0x180000L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x40000000000L, active1, 0x60000L);
       case 79:
       case 111:
-         return jjMoveStringLiteralDfa3_0(active0, 0x400000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x200000000000L, active1, 0L);
       case 82:
       case 114:
-         if ((active1 & 0x40000L) != 0L)
-            return jjStartNfaWithStates_0(2, 82, 337);
+         if ((active1 & 0x10000L) != 0L)
+            return jjStartNfaWithStates_0(2, 80, 337);
          break;
       case 83:
       case 115:
-         return jjMoveStringLiteralDfa3_0(active0, 0x10124000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x8089000000000L, active1, 0L);
       case 84:
       case 116:
-         return jjMoveStringLiteralDfa3_0(active0, 0x400000000000000L, active1, 0x200020L);
+         return jjMoveStringLiteralDfa3_0(active0, 0x200000000000000L, active1, 0x80000L);
       case 85:
       case 117:
-         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x21400000L);
+         return jjMoveStringLiteralDfa3_0(active0, 0L, active1, 0x10900000L);
       default :
          break;
    }
@@ -343,67 +343,65 @@
    {
       case 65:
       case 97:
-         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x200000L);
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x80000L);
       case 67:
       case 99:
-         if ((active0 & 0x10000000000000L) != 0L)
+         if ((active0 & 0x8000000000000L) != 0L)
          {
-            jjmatchedKind = 52;
+            jjmatchedKind = 51;
             jjmatchedPos = 3;
          }
-         return jjMoveStringLiteralDfa4_0(active0, 0x100000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x80000000000L, active1, 0L);
       case 69:
       case 101:
-         if ((active0 & 0x4000000000L) != 0L)
-            return jjStartNfaWithStates_0(3, 38, 337);
-         else if ((active1 & 0x20000000L) != 0L)
-            return jjStartNfaWithStates_0(3, 93, 337);
-         return jjMoveStringLiteralDfa4_0(active0, 0x2810000000000L, active1, 0x8000000L);
+         if ((active0 & 0x1000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 36, 337);
+         else if ((active1 & 0x10000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 92, 337);
+         return jjMoveStringLiteralDfa4_0(active0, 0x1404000000000L, active1, 0x4200000L);
       case 70:
       case 102:
-         return jjMoveStringLiteralDfa4_0(active0, 0x8000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x2000000000L, active1, 0L);
       case 71:
       case 103:
-         if ((active1 & 0x80000L) != 0L)
+         if ((active1 & 0x20000L) != 0L)
          {
-            jjmatchedKind = 83;
+            jjmatchedKind = 81;
             jjmatchedPos = 3;
          }
-         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x100000L);
-      case 72:
-      case 104:
-         if ((active1 & 0x20L) != 0L)
-            return jjStartNfaWithStates_0(3, 69, 337);
-         break;
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x40000L);
       case 73:
       case 105:
-         return jjMoveStringLiteralDfa4_0(active0, 0x420000000000000L, active1, 0x4000000L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x210000000000000L, active1, 0x2000000L);
       case 76:
       case 108:
-         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x2000000L);
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x1000000L);
       case 77:
       case 109:
-         if ((active0 & 0x400000000000L) != 0L)
-            return jjStartNfaWithStates_0(3, 46, 337);
+         if ((active0 & 0x200000000000L) != 0L)
+            return jjStartNfaWithStates_0(3, 45, 337);
          break;
       case 78:
       case 110:
-         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x400000L);
+         return jjMoveStringLiteralDfa4_0(active0, 0L, active1, 0x100000L);
       case 79:
       case 111:
-         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x800000000000000L, active1, 0L);
       case 80:
       case 112:
-         return jjMoveStringLiteralDfa4_0(active0, 0x800000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x400000000000000L, active1, 0L);
       case 82:
       case 114:
-         return jjMoveStringLiteralDfa4_0(active0, 0x1000000000000L, active1, 0x1800000L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x800000000000L, active1, 0xc00000L);
       case 83:
       case 115:
-         return jjMoveStringLiteralDfa4_0(active0, 0x40080000000000L, active1, 0x40000000L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x20040000000000L, active1, 0x20000000L);
       case 84:
       case 116:
-         return jjMoveStringLiteralDfa4_0(active0, 0x2000020000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa4_0(active0, 0x1000008000000000L, active1, 0L);
+      case 85:
+      case 117:
+         return jjMoveStringLiteralDfa4_0(active0, 0x10000000000L, active1, 0L);
       default :
          break;
    }
@@ -422,61 +420,61 @@
    {
       case 65:
       case 97:
-         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x2000000L);
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x1000000L);
       case 67:
       case 99:
-         return jjMoveStringLiteralDfa5_0(active0, 0x10000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x14000000000L, active1, 0L);
       case 68:
       case 100:
-         if ((active0 & 0x800000000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 47, 337);
-         else if ((active1 & 0x400000L) != 0L)
-            return jjStartNfaWithStates_0(4, 86, 337);
+         if ((active0 & 0x400000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 46, 337);
+         else if ((active1 & 0x100000L) != 0L)
+            return jjStartNfaWithStates_0(4, 84, 337);
          break;
       case 69:
       case 101:
-         if ((active0 & 0x1000000000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 48, 337);
-         else if ((active1 & 0x40000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 94, 337);
-         return jjMoveStringLiteralDfa5_0(active0, 0x2040000000000000L, active1, 0L);
+         if ((active0 & 0x800000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 47, 337);
+         else if ((active1 & 0x20000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 93, 337);
+         return jjMoveStringLiteralDfa5_0(active0, 0x1020000000000000L, active1, 0L);
       case 72:
       case 104:
-         if ((active0 & 0x800000000000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 59, 337);
+         if ((active0 & 0x400000000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 58, 337);
          break;
       case 73:
       case 105:
-         if ((active1 & 0x800000L) != 0L)
+         if ((active1 & 0x400000L) != 0L)
+            return jjStartNfaWithStates_0(4, 86, 337);
+         else if ((active1 & 0x800000L) != 0L)
             return jjStartNfaWithStates_0(4, 87, 337);
-         else if ((active1 & 0x1000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 88, 337);
-         return jjMoveStringLiteralDfa5_0(active0, 0x28000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa5_0(active0, 0xa000000000L, active1, 0L);
       case 77:
       case 109:
-         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x100000L);
+         return jjMoveStringLiteralDfa5_0(active0, 0L, active1, 0x40000L);
       case 78:
       case 110:
-         if ((active0 & 0x1000000000000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 60, 337);
+         if ((active0 & 0x800000000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 59, 337);
          break;
       case 79:
       case 111:
-         return jjMoveStringLiteralDfa5_0(active0, 0x400000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa5_0(active0, 0x200000000000000L, active1, 0L);
       case 82:
       case 114:
-         if ((active0 & 0x2000000000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 49, 337);
-         return jjMoveStringLiteralDfa5_0(active0, 0x100000000000L, active1, 0L);
+         if ((active0 & 0x1000000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 48, 337);
+         return jjMoveStringLiteralDfa5_0(active0, 0x80000000000L, active1, 0L);
       case 84:
       case 116:
-         if ((active0 & 0x20000000000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 53, 337);
-         return jjMoveStringLiteralDfa5_0(active0, 0x80000000000L, active1, 0x4200000L);
+         if ((active0 & 0x10000000000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 52, 337);
+         return jjMoveStringLiteralDfa5_0(active0, 0x40000000000L, active1, 0x2280000L);
       case 88:
       case 120:
-         if ((active1 & 0x8000000L) != 0L)
-            return jjStartNfaWithStates_0(4, 91, 337);
+         if ((active1 & 0x4000000L) != 0L)
+            return jjStartNfaWithStates_0(4, 90, 337);
          break;
       default :
          break;
@@ -496,36 +494,36 @@
    {
       case 65:
       case 97:
-         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x100000L);
+         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x40000L);
       case 69:
       case 101:
-         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x4000000L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x10000000000L, active1, 0x2200000L);
       case 73:
       case 105:
-         return jjMoveStringLiteralDfa6_0(active0, 0x100000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x80000000000L, active1, 0L);
       case 78:
       case 110:
-         return jjMoveStringLiteralDfa6_0(active0, 0x400020000000000L, active1, 0x2000000L);
+         return jjMoveStringLiteralDfa6_0(active0, 0x200008000000000L, active1, 0x1000000L);
       case 82:
       case 114:
-         if ((active0 & 0x2000000000000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 61, 337);
-         return jjMoveStringLiteralDfa6_0(active0, 0x80000000000L, active1, 0L);
+         if ((active0 & 0x1000000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 60, 337);
+         return jjMoveStringLiteralDfa6_0(active0, 0x40000000000L, active1, 0L);
       case 84:
       case 116:
-         if ((active0 & 0x10000000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 40, 337);
-         else if ((active0 & 0x40000000000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 54, 337);
+         if ((active0 & 0x4000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 38, 337);
+         else if ((active0 & 0x20000000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 53, 337);
          break;
       case 88:
       case 120:
-         if ((active0 & 0x8000000000L) != 0L)
-            return jjStartNfaWithStates_0(5, 39, 337);
+         if ((active0 & 0x2000000000L) != 0L)
+            return jjStartNfaWithStates_0(5, 37, 337);
          break;
       case 89:
       case 121:
-         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x200000L);
+         return jjMoveStringLiteralDfa6_0(active0, 0L, active1, 0x80000L);
       default :
          break;
    }
@@ -544,30 +542,35 @@
    {
       case 65:
       case 97:
-         return jjMoveStringLiteralDfa7_0(active0, 0x400000000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa7_0(active0, 0x200000000000000L, active1, 0L);
       case 66:
       case 98:
-         return jjMoveStringLiteralDfa7_0(active0, 0x100000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa7_0(active0, 0x80000000000L, active1, 0L);
       case 67:
       case 99:
-         return jjMoveStringLiteralDfa7_0(active0, 0x20000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa7_0(active0, 0x8000000000L, active1, 0L);
+      case 68:
+      case 100:
+         if ((active0 & 0x10000000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 40, 337);
+         break;
       case 75:
       case 107:
-         if ((active1 & 0x2000000L) != 0L)
-            return jjStartNfaWithStates_0(6, 89, 337);
+         if ((active1 & 0x1000000L) != 0L)
+            return jjStartNfaWithStates_0(6, 88, 337);
          break;
       case 80:
       case 112:
-         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x200000L);
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x80000L);
       case 82:
       case 114:
-         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x4000000L);
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x2200000L);
       case 84:
       case 116:
-         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x100000L);
+         return jjMoveStringLiteralDfa7_0(active0, 0L, active1, 0x40000L);
       case 85:
       case 117:
-         return jjMoveStringLiteralDfa7_0(active0, 0x80000000000L, active1, 0L);
+         return jjMoveStringLiteralDfa7_0(active0, 0x40000000000L, active1, 0L);
       default :
          break;
    }
@@ -586,26 +589,31 @@
    {
       case 65:
       case 97:
-         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x4000000L);
+         return jjMoveStringLiteralDfa8_0(active0, 0L, active1, 0x2000000L);
       case 67:
       case 99:
-         return jjMoveStringLiteralDfa8_0(active0, 0x80000000000L, active1, 0x100000L);
+         return jjMoveStringLiteralDfa8_0(active0, 0x40000000000L, active1, 0x40000L);
       case 69:
       case 101:
-         if ((active0 & 0x100000000000L) != 0L)
-            return jjStartNfaWithStates_0(7, 44, 337);
-         else if ((active1 & 0x200000L) != 0L)
-            return jjStartNfaWithStates_0(7, 85, 337);
+         if ((active0 & 0x80000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 43, 337);
+         else if ((active1 & 0x80000L) != 0L)
+            return jjStartNfaWithStates_0(7, 83, 337);
          break;
       case 76:
       case 108:
-         if ((active0 & 0x400000000000000L) != 0L)
-            return jjStartNfaWithStates_0(7, 58, 337);
+         if ((active0 & 0x200000000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 57, 337);
+         break;
+      case 77:
+      case 109:
+         if ((active1 & 0x200000L) != 0L)
+            return jjStartNfaWithStates_0(7, 85, 337);
          break;
       case 84:
       case 116:
-         if ((active0 & 0x20000000000L) != 0L)
-            return jjStartNfaWithStates_0(7, 41, 337);
+         if ((active0 & 0x8000000000L) != 0L)
+            return jjStartNfaWithStates_0(7, 39, 337);
          break;
       default :
          break;
@@ -625,16 +633,16 @@
    {
       case 72:
       case 104:
-         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x100000L);
+         return jjMoveStringLiteralDfa9_0(active0, 0L, active1, 0x40000L);
       case 76:
       case 108:
-         if ((active1 & 0x4000000L) != 0L)
-            return jjStartNfaWithStates_0(8, 90, 337);
+         if ((active1 & 0x2000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 89, 337);
          break;
       case 84:
       case 116:
-         if ((active0 & 0x80000000000L) != 0L)
-            return jjStartNfaWithStates_0(8, 43, 337);
+         if ((active0 & 0x40000000000L) != 0L)
+            return jjStartNfaWithStates_0(8, 42, 337);
          break;
       default :
          break;
@@ -654,7 +662,7 @@
    {
       case 69:
       case 101:
-         return jjMoveStringLiteralDfa10_0(active1, 0x100000L);
+         return jjMoveStringLiteralDfa10_0(active1, 0x40000L);
       default :
          break;
    }
@@ -673,8 +681,8 @@
    {
       case 83:
       case 115:
-         if ((active1 & 0x100000L) != 0L)
-            return jjStartNfaWithStates_0(10, 84, 337);
+         if ((active1 & 0x40000L) != 0L)
+            return jjStartNfaWithStates_0(10, 82, 337);
          break;
       default :
          break;
@@ -711,44 +719,44 @@
    jjCheckNAdd(jjnextStates[start]);
    jjCheckNAdd(jjnextStates[start + 1]);
 }
-static final long[] jjbitVec0 = {
-   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+static final long[] jjbitVec0 = {
+   0xfffffffffffffffeL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
 };
-static final long[] jjbitVec2 = {
-   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
+static final long[] jjbitVec2 = {
+   0x0L, 0x0L, 0xffffffffffffffffL, 0xffffffffffffffffL
 };
-static final long[] jjbitVec3 = {
-   0xfffe7000fffffff6L, 0xffffffffffffffffL, 0xffffffffffffffffL, 0x5e00000000ffffffL
+static final long[] jjbitVec3 = {
+   0xfffe7000fffffff6L, 0xffffffffffffffffL, 0xffffffffffffffffL, 0x5e00000000ffffffL
 };
-static final long[] jjbitVec4 = {
-   0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL
+static final long[] jjbitVec4 = {
+   0x0L, 0x0L, 0x0L, 0xff7fffffff7fffffL
 };
-static final long[] jjbitVec5 = {
-   0x0L, 0xbfff000000000000L, 0xffffffffffffffffL, 0xffffffffffffffffL
+static final long[] jjbitVec5 = {
+   0x0L, 0xbfff000000000000L, 0xffffffffffffffffL, 0xffffffffffffffffL
 };
-static final long[] jjbitVec6 = {
-   0x3000L, 0xffff000000000000L, 0xffffffffffffffffL, 0xffffffffffffffffL
+static final long[] jjbitVec6 = {
+   0x3000L, 0xffff000000000000L, 0xffffffffffffffffL, 0xffffffffffffffffL
 };
-static final long[] jjbitVec7 = {
-   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffL, 0x0L
+static final long[] jjbitVec7 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffL, 0x0L
 };
-static final long[] jjbitVec8 = {
-   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffL
+static final long[] jjbitVec8 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffL
 };
-static final long[] jjbitVec9 = {
-   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffff00000000ffffL
+static final long[] jjbitVec9 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0xffff00000000ffffL
 };
-static final long[] jjbitVec10 = {
-   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffffffffL
+static final long[] jjbitVec10 = {
+   0xffffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL, 0x3fffffffffffffffL
 };
-static final long[] jjbitVec11 = {
-   0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL
+static final long[] jjbitVec11 = {
+   0x0L, 0x0L, 0x80000000000000L, 0xff7fffffff7fffffL
 };
-static final long[] jjbitVec12 = {
-   0xffffffffffffffffL, 0xbfffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
+static final long[] jjbitVec12 = {
+   0xffffffffffffffffL, 0xbfffffffffffffffL, 0xffffffffffffffffL, 0xffffffffffffffffL
 };
-static final long[] jjbitVec13 = {
-   0x8000000000003000L, 0xffff000000000001L, 0xffffffffffffffffL, 0xffffffffffffffffL
+static final long[] jjbitVec13 = {
+   0x8000000000003000L, 0xffff000000000001L, 0xffffffffffffffffL, 0xffffffffffffffffL
 };
 private final int jjMoveNfa_0(int startState, int curPos)
 {
@@ -772,16 +780,16 @@
                case 0:
                   if ((0x3ff000000000000L & l) != 0L)
                   {
-                     if (kind > 18)
-                        kind = 18;
+                     if (kind > 16)
+                        kind = 16;
                      jjCheckNAddStates(0, 6);
                   }
                   else if (curChar == 46)
                      jjCheckNAddTwoStates(332, 333);
                   else if (curChar == 58)
                   {
-                     if (kind > 12)
-                        kind = 12;
+                     if (kind > 10)
+                        kind = 10;
                      jjCheckNAddTwoStates(224, 252);
                   }
                   else if (curChar == 40)
@@ -811,8 +819,8 @@
                      jjCheckNAddTwoStates(187, 188);
                   else if (curChar == 41)
                   {
-                     if (kind > 25)
-                        kind = 25;
+                     if (kind > 23)
+                        kind = 23;
                   }
                   break;
                case 340:
@@ -820,8 +828,8 @@
                      jjCheckNAddTwoStates(333, 334);
                   if ((0x3ff000000000000L & l) != 0L)
                   {
-                     if (kind > 19)
-                        kind = 19;
+                     if (kind > 17)
+                        kind = 17;
                      jjCheckNAdd(332);
                   }
                   break;
@@ -830,8 +838,8 @@
                      jjCheckNAddTwoStates(1, 2);
                   else if (curChar == 62)
                   {
-                     if (kind > 11)
-                        kind = 11;
+                     if (kind > 9)
+                        kind = 9;
                   }
                   break;
                case 337:
@@ -839,16 +847,16 @@
                      jjCheckNAddStates(17, 19);
                   else if (curChar == 58)
                   {
-                     if (kind > 13)
-                        kind = 13;
+                     if (kind > 11)
+                        kind = 11;
                      jjCheckNAddTwoStates(224, 252);
                   }
                   if ((0x3ff600000000000L & l) != 0L)
                      jjCheckNAddStates(20, 22);
                   else if (curChar == 58)
                   {
-                     if (kind > 12)
-                        kind = 12;
+                     if (kind > 10)
+                        kind = 10;
                   }
                   if ((0x3ff200000000000L & l) != 0L)
                      jjCheckNAdd(223);
@@ -860,20 +868,28 @@
                      jjCheckNAddTwoStates(1, 2);
                   break;
                case 2:
-                  if (curChar == 62 && kind > 11)
-                     kind = 11;
+                  if (curChar == 62 && kind > 9)
+                     kind = 9;
                   break;
                case 3:
                   if (curChar == 58)
                      jjAddStates(23, 24);
                   break;
+               case 4:
+               case 37:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 12)
+                     kind = 12;
+                  jjCheckNAddStates(25, 27);
+                  break;
                case 5:
                   if ((0x3ff600000000000L & l) != 0L)
                      jjCheckNAddStates(25, 27);
                   break;
                case 6:
-                  if ((0x3ff200000000000L & l) != 0L && kind > 14)
-                     kind = 14;
+                  if ((0x3ff200000000000L & l) != 0L && kind > 12)
+                     kind = 12;
                   break;
                case 9:
                   if ((0x3ff000000000000L & l) != 0L)
@@ -889,8 +905,8 @@
                      jjCheckNAdd(12);
                   break;
                case 12:
-                  if ((0x3ff000000000000L & l) != 0L && kind > 14)
-                     kind = 14;
+                  if ((0x3ff000000000000L & l) != 0L && kind > 12)
+                     kind = 12;
                   break;
                case 13:
                   if ((0x3ff000000000000L & l) != 0L)
@@ -970,13 +986,6 @@
                   if ((0x3ff000000000000L & l) != 0L)
                      jjCheckNAdd(37);
                   break;
-               case 37:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 14)
-                     kind = 14;
-                  jjCheckNAddStates(25, 27);
-                  break;
                case 38:
                   if ((0x3ff000000000000L & l) != 0L)
                      jjstateSet[jjnewStateCnt++] = 39;
@@ -1010,8 +1019,8 @@
                case 54:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 15)
-                     kind = 15;
+                  if (kind > 13)
+                     kind = 13;
                   jjCheckNAddTwoStates(48, 49);
                   break;
                case 51:
@@ -1094,8 +1103,8 @@
                case 82:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 16)
-                     kind = 16;
+                  if (kind > 14)
+                     kind = 14;
                   jjCheckNAddTwoStates(76, 77);
                   break;
                case 79:
@@ -1176,8 +1185,8 @@
                case 105:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 17)
-                     kind = 17;
+                  if (kind > 15)
+                     kind = 15;
                   jjCheckNAddTwoStates(104, 105);
                   break;
                case 106:
@@ -1189,8 +1198,8 @@
                      jjCheckNAddStates(14, 16);
                   break;
                case 108:
-                  if (curChar == 39 && kind > 21)
-                     kind = 21;
+                  if (curChar == 39 && kind > 19)
+                     kind = 19;
                   break;
                case 110:
                   if ((0x8400000000L & l) != 0L)
@@ -1246,8 +1255,8 @@
                      jjCheckNAddStates(11, 13);
                   break;
                case 125:
-                  if (curChar == 34 && kind > 22)
-                     kind = 22;
+                  if (curChar == 34 && kind > 20)
+                     kind = 20;
                   break;
                case 127:
                   if ((0x8400000000L & l) != 0L)
@@ -1357,8 +1366,8 @@
                      jjstateSet[jjnewStateCnt++] = 158;
                   break;
                case 159:
-                  if (curChar == 39 && kind > 23)
-                     kind = 23;
+                  if (curChar == 39 && kind > 21)
+                     kind = 21;
                   break;
                case 160:
                   if (curChar == 39)
@@ -1435,8 +1444,8 @@
                      jjstateSet[jjnewStateCnt++] = 181;
                   break;
                case 182:
-                  if (curChar == 34 && kind > 24)
-                     kind = 24;
+                  if (curChar == 34 && kind > 22)
+                     kind = 22;
                   break;
                case 183:
                   if (curChar == 34)
@@ -1459,8 +1468,8 @@
                      jjCheckNAddTwoStates(187, 188);
                   break;
                case 188:
-                  if (curChar == 41 && kind > 25)
-                     kind = 25;
+                  if (curChar == 41 && kind > 23)
+                     kind = 23;
                   break;
                case 193:
                   if ((0x3ff600000000000L & l) != 0L)
@@ -1471,8 +1480,8 @@
                      jjCheckNAdd(195);
                   break;
                case 195:
-                  if (curChar == 58 && kind > 12)
-                     kind = 12;
+                  if (curChar == 58 && kind > 10)
+                     kind = 10;
                   break;
                case 198:
                   if ((0x3ff000000000000L & l) != 0L)
@@ -1567,17 +1576,25 @@
                case 223:
                   if (curChar != 58)
                      break;
-                  if (kind > 13)
-                     kind = 13;
+                  if (kind > 11)
+                     kind = 11;
                   jjCheckNAddTwoStates(224, 252);
                   break;
+               case 224:
+               case 257:
+                  if ((0x3ff000000000000L & l) == 0L)
+                     break;
+                  if (kind > 11)
+                     kind = 11;
+                  jjCheckNAddStates(40, 42);
+                  break;
                case 225:
                   if ((0x3ff600000000000L & l) != 0L)
                      jjCheckNAddStates(40, 42);
                   break;
                case 226:
-                  if ((0x3ff200000000000L & l) != 0L && kind > 13)
-                     kind = 13;
+                  if ((0x3ff200000000000L & l) != 0L && kind > 11)
+                     kind = 11;
                   break;
                case 229:
                   if ((0x3ff000000000000L & l) != 0L)
@@ -1593,8 +1610,8 @@
                      jjCheckNAdd(232);
                   break;
                case 232:
-                  if ((0x3ff000000000000L & l) != 0L && kind > 13)
-                     kind = 13;
+                  if ((0x3ff000000000000L & l) != 0L && kind > 11)
+                     kind = 11;
                   break;
                case 233:
                   if ((0x3ff000000000000L & l) != 0L)
@@ -1674,13 +1691,6 @@
                   if ((0x3ff000000000000L & l) != 0L)
                      jjCheckNAdd(257);
                   break;
-               case 257:
-                  if ((0x3ff000000000000L & l) == 0L)
-                     break;
-                  if (kind > 13)
-                     kind = 13;
-                  jjCheckNAddStates(40, 42);
-                  break;
                case 258:
                   if ((0x3ff000000000000L & l) != 0L)
                      jjstateSet[jjnewStateCnt++] = 259;
@@ -1872,22 +1882,22 @@
                case 315:
                   if (curChar != 58)
                      break;
-                  if (kind > 12)
-                     kind = 12;
+                  if (kind > 10)
+                     kind = 10;
                   jjCheckNAddTwoStates(224, 252);
                   break;
                case 316:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 18)
-                     kind = 18;
+                  if (kind > 16)
+                     kind = 16;
                   jjCheckNAddStates(0, 6);
                   break;
                case 317:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 18)
-                     kind = 18;
+                  if (kind > 16)
+                     kind = 16;
                   jjCheckNAdd(317);
                   break;
                case 318:
@@ -1897,15 +1907,15 @@
                case 319:
                   if (curChar != 46)
                      break;
-                  if (kind > 19)
-                     kind = 19;
+                  if (kind > 17)
+                     kind = 17;
                   jjCheckNAdd(320);
                   break;
                case 320:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 19)
-                     kind = 19;
+                  if (kind > 17)
+                     kind = 17;
                   jjCheckNAdd(320);
                   break;
                case 321:
@@ -1927,8 +1937,8 @@
                case 326:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 20)
-                     kind = 20;
+                  if (kind > 18)
+                     kind = 18;
                   jjCheckNAdd(326);
                   break;
                case 327:
@@ -1942,8 +1952,8 @@
                case 330:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 20)
-                     kind = 20;
+                  if (kind > 18)
+                     kind = 18;
                   jjCheckNAdd(330);
                   break;
                case 331:
@@ -1953,8 +1963,8 @@
                case 332:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 19)
-                     kind = 19;
+                  if (kind > 17)
+                     kind = 17;
                   jjCheckNAdd(332);
                   break;
                case 333:
@@ -1968,8 +1978,8 @@
                case 336:
                   if ((0x3ff000000000000L & l) == 0L)
                      break;
-                  if (kind > 20)
-                     kind = 20;
+                  if (kind > 18)
+                     kind = 18;
                   jjCheckNAdd(336);
                   break;
                default : break;
@@ -1984,7 +1994,7 @@
             switch(jjstateSet[--i])
             {
                case 0:
-                  if ((0x7fffffe07fffffeL & l) != 0L)
+                  if ((0x7fffffe87fffffeL & l) != 0L)
                      jjCheckNAddStates(51, 58);
                   else if (curChar == 92)
                      jjAddStates(59, 60);
@@ -1992,13 +2002,13 @@
                      jjAddStates(61, 62);
                   else if (curChar == 64)
                      jjCheckNAdd(103);
-                  else if (curChar == 95)
+                  if (curChar == 95)
                      jjstateSet[jjnewStateCnt++] = 3;
                   break;
                case 338:
                case 191:
-                  if (curChar == 93 && kind > 26)
-                     kind = 26;
+                  if (curChar == 93 && kind > 24)
+                     kind = 24;
                   break;
                case 341:
                case 1:
@@ -2022,8 +2032,8 @@
                case 4:
                   if ((0x7fffffe87fffffeL & l) == 0L)
                      break;
-                  if (kind > 14)
-                     kind = 14;
+                  if (kind > 12)
+                     kind = 12;
                   jjCheckNAddStates(25, 27);
                   break;
                case 5:
@@ -2031,8 +2041,8 @@
                      jjCheckNAddStates(25, 27);
                   break;
                case 6:
-                  if ((0x7fffffe87fffffeL & l) != 0L && kind > 14)
-                     kind = 14;
+                  if ((0x7fffffe87fffffeL & l) != 0L && kind > 12)
+                     kind = 12;
                   break;
                case 7:
                   if (curChar == 92)
@@ -2056,8 +2066,8 @@
                      jjCheckNAdd(12);
                   break;
                case 12:
-                  if ((0x7e0000007eL & l) != 0L && kind > 14)
-                     kind = 14;
+                  if ((0x7e0000007eL & l) != 0L && kind > 12)
+                     kind = 12;
                   break;
                case 13:
                   if ((0x7e0000007eL & l) != 0L)
@@ -2152,8 +2162,8 @@
                case 37:
                   if ((0x7e0000007eL & l) == 0L)
                      break;
-                  if (kind > 14)
-                     kind = 14;
+                  if (kind > 12)
+                     kind = 12;
                   jjCheckNAddStates(25, 27);
                   break;
                case 38:
@@ -2188,8 +2198,8 @@
                case 48:
                   if ((0x7fffffe87fffffeL & l) == 0L)
                      break;
-                  if (kind > 15)
-                     kind = 15;
+                  if (kind > 13)
+                     kind = 13;
                   jjCheckNAddTwoStates(48, 49);
                   break;
                case 49:
@@ -2218,8 +2228,8 @@
                case 54:
                   if ((0x7e0000007eL & l) == 0L)
                      break;
-                  if (kind > 15)
-                     kind = 15;
+                  if (kind > 13)
+                     kind = 13;
                   jjCheckNAddTwoStates(48, 49);
                   break;
                case 55:
@@ -2290,8 +2300,8 @@
                case 76:
                   if ((0x7fffffe87fffffeL & l) == 0L)
                      break;
-                  if (kind > 16)
-                     kind = 16;
+                  if (kind > 14)
+                     kind = 14;
                   jjCheckNAddTwoStates(76, 77);
                   break;
                case 77:
@@ -2320,8 +2330,8 @@
                case 82:
                   if ((0x7e0000007eL & l) == 0L)
                      break;
-                  if (kind > 16)
-                     kind = 16;
+                  if (kind > 14)
+                     kind = 14;
                   jjCheckNAddTwoStates(76, 77);
                   break;
                case 83:
@@ -2395,15 +2405,15 @@
                case 103:
                   if ((0x7fffffe07fffffeL & l) == 0L)
                      break;
-                  if (kind > 17)
-                     kind = 17;
+                  if (kind > 15)
+                     kind = 15;
                   jjCheckNAddTwoStates(103, 104);
                   break;
                case 105:
                   if ((0x7fffffe07fffffeL & l) == 0L)
                      break;
-                  if (kind > 17)
-                     kind = 17;
+                  if (kind > 15)
+                     kind = 15;
                   jjCheckNAddTwoStates(104, 105);
                   break;
                case 107:
@@ -2639,7 +2649,7 @@
                      jjAddStates(61, 62);
                   break;
                case 192:
-                  if ((0x7fffffe07fffffeL & l) != 0L)
+                  if ((0x7fffffe87fffffeL & l) != 0L)
                      jjCheckNAddStates(51, 58);
                   break;
                case 193:
@@ -2755,8 +2765,8 @@
                case 224:
                   if ((0x7fffffe87fffffeL & l) == 0L)
                      break;
-                  if (kind > 13)
-                     kind = 13;
+                  if (kind > 11)
+                     kind = 11;
                   jjCheckNAddStates(40, 42);
                   break;
                case 225:
@@ -2764,8 +2774,8 @@
                      jjCheckNAddStates(40, 42);
                   break;
                case 226:
-                  if ((0x7fffffe87fffffeL & l) != 0L && kind > 13)
-                     kind = 13;
+                  if ((0x7fffffe87fffffeL & l) != 0L && kind > 11)
+                     kind = 11;
                   break;
                case 227:
                   if (curChar == 92)
@@ -2789,8 +2799,8 @@
                      jjCheckNAdd(232);
                   break;
                case 232:
-                  if ((0x7e0000007eL & l) != 0L && kind > 13)
-                     kind = 13;
+                  if ((0x7e0000007eL & l) != 0L && kind > 11)
+                     kind = 11;
                   break;
                case 233:
                   if ((0x7e0000007eL & l) != 0L)
@@ -2885,8 +2895,8 @@
                case 257:
                   if ((0x7e0000007eL & l) == 0L)
                      break;
-                  if (kind > 13)
-                     kind = 13;
+                  if (kind > 11)
+                     kind = 11;
                   jjCheckNAddStates(40, 42);
                   break;
                case 258:
@@ -3150,8 +3160,8 @@
                case 4:
                   if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 14)
-                     kind = 14;
+                  if (kind > 12)
+                     kind = 12;
                   jjCheckNAddStates(25, 27);
                   break;
                case 5:
@@ -3159,35 +3169,35 @@
                      jjCheckNAddStates(25, 27);
                   break;
                case 6:
-                  if (jjCanMove_2(hiByte, i1, i2, l1, l2) && kind > 14)
-                     kind = 14;
+                  if (jjCanMove_2(hiByte, i1, i2, l1, l2) && kind > 12)
+                     kind = 12;
                   break;
                case 47:
                   if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 15)
-                     kind = 15;
+                  if (kind > 13)
+                     kind = 13;
                   jjCheckNAddTwoStates(48, 49);
                   break;
                case 48:
                   if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 15)
-                     kind = 15;
+                  if (kind > 13)
+                     kind = 13;
                   jjCheckNAddTwoStates(48, 49);
                   break;
                case 75:
                   if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 16)
-                     kind = 16;
+                  if (kind > 14)
+                     kind = 14;
                   jjCheckNAddTwoStates(76, 77);
                   break;
                case 76:
                   if (!jjCanMove_2(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 16)
-                     kind = 16;
+                  if (kind > 14)
+                     kind = 14;
                   jjCheckNAddTwoStates(76, 77);
                   break;
                case 107:
@@ -3225,8 +3235,8 @@
                case 224:
                   if (!jjCanMove_1(hiByte, i1, i2, l1, l2))
                      break;
-                  if (kind > 13)
-                     kind = 13;
+                  if (kind > 11)
+                     kind = 11;
                   jjCheckNAddStates(40, 42);
                   break;
                case 225:
@@ -3234,8 +3244,8 @@
                      jjCheckNAddStates(40, 42);
                   break;
                case 226:
-                  if (jjCanMove_2(hiByte, i1, i2, l1, l2) && kind > 13)
-                     kind = 13;
+                  if (jjCanMove_2(hiByte, i1, i2, l1, l2) && kind > 11)
+                     kind = 11;
                   break;
                default : break;
             }
@@ -3337,25 +3347,15 @@
       catch(java.io.IOException e) { return curPos; }
    }
 }
-private final int jjMoveStringLiteralDfa0_2()
-{
-   switch(curChar)
-   {
-      case 40:
-         return jjStopAtPos(0, 9);
-      default :
-         return 1;
-   }
-}
-static final int[] jjnextStates = {
-   317, 318, 319, 321, 322, 327, 328, 47, 62, 75, 90, 124, 125, 126, 107, 108, 
-   109, 221, 222, 265, 193, 194, 196, 4, 32, 5, 6, 7, 141, 142, 143, 145, 
-   144, 160, 164, 165, 166, 168, 167, 183, 225, 226, 227, 221, 222, 223, 265, 193, 
-   194, 195, 196, 193, 194, 195, 221, 222, 223, 265, 196, 291, 303, 190, 191, 197, 
-   209, 266, 278, 8, 20, 9, 13, 21, 25, 34, 38, 51, 55, 64, 67, 79, 
-   83, 92, 95, 110, 111, 112, 116, 127, 128, 129, 133, 146, 147, 148, 152, 169, 
-   170, 171, 175, 198, 202, 210, 214, 228, 240, 229, 233, 241, 245, 254, 258, 267, 
-   271, 279, 283, 292, 296, 304, 308, 325, 326, 329, 330, 335, 336, 
+static final int[] jjnextStates = {
+   317, 318, 319, 321, 322, 327, 328, 47, 62, 75, 90, 124, 125, 126, 107, 108, 
+   109, 221, 222, 265, 193, 194, 196, 4, 32, 5, 6, 7, 141, 142, 143, 145, 
+   144, 160, 164, 165, 166, 168, 167, 183, 225, 226, 227, 221, 222, 223, 265, 193, 
+   194, 195, 196, 193, 194, 195, 221, 222, 223, 265, 196, 291, 303, 190, 191, 197, 
+   209, 266, 278, 8, 20, 9, 13, 21, 25, 34, 38, 51, 55, 64, 67, 79, 
+   83, 92, 95, 110, 111, 112, 116, 127, 128, 129, 133, 146, 147, 148, 152, 169, 
+   170, 171, 175, 198, 202, 210, 214, 228, 240, 229, 233, 241, 245, 254, 258, 267, 
+   271, 279, 283, 292, 296, 304, 308, 325, 326, 329, 330, 335, 336, 
 };
 private static final boolean jjCanMove_0(int hiByte, int i1, int i2, long l1, long l2)
 {
@@ -3422,36 +3422,35 @@
    }
 }
 public static final String[] jjstrLiteralImages = {
-"", null, null, null, null, null, null, null, null, "\50", null, null, null, 
+"", null, null, null, null, null, null, null, null, null, null, null, null, 
 null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
 null, null, null, null, null, null, null, null, null, null, null, null, null, null, 
-null, "\52", null, null, null, null, null, null, null, null, null, null, null, null, 
-"\173", "\175", "\56", null, null, null, null, "\54", "\51", "\73", null, "\133", 
-"\135", "\50", null, "\53", "\55", "\174\174", "\46\46", "\75", "\41\75", "\74", 
-"\74\75", "\76", "\76\75", "\57", "\41", null, null, null, null, null, null, null, null, 
+"\52", null, null, null, null, null, null, null, null, null, null, null, null, 
+"\173", "\175", "\56", null, null, null, null, "\50", "\54", "\51", "\73", null, 
+"\133", "\135", "\53", "\55", "\174\174", "\46\46", "\75", "\41\75", "\74", "\74\75", 
+"\76", "\76\75", "\57", "\41", null, null, null, null, null, null, null, null, null, 
 null, null, "\136\136", null, null, };
 public static final String[] lexStateNames = {
    "DEFAULT", 
    "IN_SINGLE_LINE_COMMENT", 
-   "POSSIBLE_FUNCTION", 
 };
-public static final int[] jjnewLexState = {
-   -1, -1, -1, -1, -1, -1, 1, 0, -1, 0, 0, 2, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
-   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+public static final int[] jjnewLexState = {
+   -1, -1, -1, -1, -1, -1, 1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
+   -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
 };
-static final long[] jjtoToken = {
-   0xffffffc007fffa01L, 0x7fffffffL, 
+static final long[] jjtoToken = {
+   0xfffffff001fffe01L, 0x3fffffffL, 
 };
-static final long[] jjtoSkip = {
-   0x4beL, 0x0L, 
+static final long[] jjtoSkip = {
+   0xbeL, 0x0L, 
 };
-static final long[] jjtoSpecial = {
-   0x80L, 0x0L, 
+static final long[] jjtoSpecial = {
+   0x80L, 0x0L, 
 };
-static final long[] jjtoMore = {
-   0x140L, 0x0L, 
+static final long[] jjtoMore = {
+   0x140L, 0x0L, 
 };
 protected JavaCharStream input_stream;
 private final int[] jjrounds = new int[337];
@@ -3460,14 +3459,12 @@
 int jjimageLen;
 int lengthOfMatch;
 protected char curChar;
-public SPARQLParserTokenManager(JavaCharStream stream)
-{
+public SPARQLParserTokenManager(JavaCharStream stream){
    if (JavaCharStream.staticFlag)
       throw new Error("ERROR: Cannot use a static CharStream class with a non-static lexical analyzer.");
    input_stream = stream;
 }
-public SPARQLParserTokenManager(JavaCharStream stream, int lexState)
-{
+public SPARQLParserTokenManager(JavaCharStream stream, int lexState){
    this(stream);
    SwitchTo(lexState);
 }
@@ -3492,7 +3489,7 @@
 }
 public void SwitchTo(int lexState)
 {
-   if (lexState >= 3 || lexState < 0)
+   if (lexState >= 2 || lexState < 0)
       throw new TokenMgrError("Error: Ignoring invalid lexical state : " + lexState + ". State unchanged.", TokenMgrError.INVALID_LEXICAL_STATE);
    else
       curLexState = lexState;
@@ -3525,7 +3522,7 @@
   Token matchedToken;
   int curPos = 0;
 
-  EOFLoop :
+  EOFLoop :
   for (;;)
   {   
    try   
@@ -3565,15 +3562,6 @@
             jjmatchedKind = 8;
          }
          break;
-       case 2:
-         jjmatchedKind = 0x7fffffff;
-         jjmatchedPos = 0;
-         curPos = jjMoveStringLiteralDfa0_2();
-         if (jjmatchedPos == 0 && jjmatchedKind > 10)
-         {
-            jjmatchedKind = 10;
-         }
-         break;
      }
      if (jjmatchedKind != 0x7fffffff)
      {
@@ -3646,13 +3634,6 @@
 {
    switch(jjmatchedKind)
    {
-      case 10 :
-         if (image == null)
-            image = new StringBuffer(new String(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1))));
-         else
-            image.append(input_stream.GetSuffix(jjimageLen + (lengthOfMatch = jjmatchedPos + 1)));
-           input_stream.backup(1);
-         break;
       default :
          break;
    }
